-- Y-Bounds Auto Reset (Local) + "No character/root" watchdog
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer

local Y_MAX = 10000
local Y_MIN = -10000
local CHECK_RATE = 0.2

-- if character/root/humanoid stays missing for this long (after a short grace), force reset
local SPAWN_GRACE_TIME = 1.5
local NO_ROOT_RESET_TIME = 2.5
local RESET_COOLDOWN = 3.0

local function getRoot(char)
	return char and (char:FindFirstChild("HumanoidRootPart") or char.PrimaryPart)
end

local function getHumanoid(char)
	return char and char:FindFirstChildOfClass("Humanoid")
end

local function forceReset(char, hum)
	-- try safest options first
	if hum then
		pcall(function() hum.Health = 0 end)
		return
	end
	if char then
		pcall(function() char:BreakJoints() end)
	end
end

local function bindCharacter(char)
	local acc = 0
	local conn

	local boundAt = tick()
	local noRootTimer = 0
	local lastReset = 0

	conn = RunService.Heartbeat:Connect(function(dt)
		if not char or char.Parent == nil then
			if conn then conn:Disconnect() end
			return
		end

		acc += dt
		if acc < CHECK_RATE then return end
		acc = 0

		local hum = getHumanoid(char)
		local root = getRoot(char)

		-- if we're alive but missing humanoid/root for too long, reset
		local now = tick()
		local inGrace = (now - boundAt) < SPAWN_GRACE_TIME
		local resetOnCooldown = (now - lastReset) < RESET_COOLDOWN

		if not hum or not root then
			if not inGrace and not resetOnCooldown then
				noRootTimer += CHECK_RATE
				if noRootTimer >= NO_ROOT_RESET_TIME then
					lastReset = now
					noRootTimer = 0
					forceReset(char, hum)
				end
			end
			return
		else
			noRootTimer = 0
		end

		if hum.Health <= 0 then
			return
		end

		-- Y-bounds check
		local y = root.Position.Y
		if (y > Y_MAX or y < Y_MIN) and not resetOnCooldown then
			lastReset = now
			forceReset(char, hum)
		end
	end)
end

if player.Character then
	bindCharacter(player.Character)
end

player.CharacterAdded:Connect(function(char)
	task.wait(0.1)
	bindCharacter(char)
end)

print("Local Y-Bounds Auto Reset loaded (with no-root watchdog).")

--============================================================
--  Advanced Player Selection  •  Remote-Based  (v1.2 25-May-2025)
--  • Q / R / X fire server remotes (Telekinesis / Telepathy)
--  • Right-Alt toggles GUI (FOV, ESP, Highlight, Wall-Bang)
--  • ESP element toggles (Name ▢  HP ▢  Studs ▢)
--  • Per-player memory (saved to file)  +  “Toggle All” switch
--  • Starts with EVERYONE IGNORED until you choose otherwise
--  • NEW:  ⟶  “Target All / Ignore All” now applies to *future* joins
--           and clears saved prefs so players who re-join follow
--           the currently selected global mode.
--============================================================

----------------------------------------------------------------
--  SERVICES
----------------------------------------------------------------
local Players            = game:GetService("Players")
local RunService         = game:GetService("RunService")
local UserInputService   = game:GetService("UserInputService")
local TweenService       = game:GetService("TweenService")
local ReplicatedStorage  = game:GetService("ReplicatedStorage")
local CoreGui            = game:GetService("CoreGui")
local Camera             = workspace.CurrentCamera
local HttpService        = game:GetService("HttpService")

----------------------------------------------------------------
--  REMOTES
----------------------------------------------------------------
local TelekinesisEvent   = ReplicatedStorage.Remotes:WaitForChild("TelekinesisEvent")
local TelepathyEvent     = ReplicatedStorage.Remotes:WaitForChild("TelepathyEvent")

----------------------------------------------------------------
--  PLAYER
----------------------------------------------------------------
local LocalPlayer        = Players.LocalPlayer
local Mouse              = LocalPlayer:GetMouse()

----------------------------------------------------------------
--  CONFIG
----------------------------------------------------------------
local Config = {
    FOVSize        = 300,
    GUIVisible     = false,
    ShowESP        = true,
    ShowHighlight  = true,
    WallBang       = true,
    DIST_CLOSE     = 75,
    DIST_MEDIUM    = 149,
    DIST_FAR       = 299,
    PlayerListOpen = false,

    -- ESP element toggles
    ShowName       = true,
    ShowHP         = true,
    ShowStuds      = true
}

----------------------------------------------------------------
--  STATE
----------------------------------------------------------------
local State = {
    Characters     = {},   -- [player] = character
    Whitelist      = {},   -- [player] = true / false
    Prefs          = {},   -- [userid] = true / false  (persisted)
    ESP            = {},   -- [player] = Drawing.Text
    HoverPlayer    = nil,
    TelepathyTogOn = false,
    AllTargeted    = true -- false = IGNORE-ALL | true = TARGET-ALL
}

----------------------------------------------------------------
--  LOCAL-FILE STORAGE  (Synapse / Krnl / Fluxus, etc.)
----------------------------------------------------------------
local STORE       = "SelPrefs.json"
local haveFileAPI = (typeof(isfile)=="function") and
                    (typeof(readfile)=="function") and
                    (typeof(writefile)=="function")

local function savePrefs()
    if not haveFileAPI then return end
    local ok, data = pcall(HttpService.JSONEncode, HttpService, State.Prefs)
    if ok and data then pcall(writefile, STORE, data) end
end

local function loadPrefs()
    if not haveFileAPI or not isfile(STORE) then return end
    local ok, raw = pcall(readfile, STORE)
    if ok and raw and #raw > 0 then
        local ok2, tbl = pcall(HttpService.JSONDecode, HttpService, raw)
        if ok2 and typeof(tbl)=="table" then
            State.Prefs = tbl
        end
    end
end
loadPrefs()

----------------------------------------------------------------
--  FOV CIRCLE
----------------------------------------------------------------
local FOV = Drawing.new("Circle")
FOV.Filled, FOV.Transparency = false, 0.5
FOV.Color,  FOV.Thickness    = Color3.fromRGB(0,120,255), 1
FOV.Radius, FOV.Visible      = Config.FOVSize, false

----------------------------------------------------------------
--  GUI HELPERS
----------------------------------------------------------------
local function createRoundedFrame(parent,size,pos,color,radius)
    local f = Instance.new("Frame", parent)
    f.Size, f.Position = size, pos
    f.BackgroundColor3, f.BorderSizePixel = color, 0
    Instance.new("UICorner", f).CornerRadius = UDim.new(0, radius or 8)
    local s = Instance.new("Frame", f)
    s.Size = UDim2.new(1,6,1,6)
    s.Position = UDim2.new(0.5,0,0.5,0)
    s.AnchorPoint = Vector2.new(0.5,0.5)
    s.BackgroundColor3 = Color3.new(0,0,0)
    s.BackgroundTransparency, s.ZIndex = 0.7, -1
    s.BorderSizePixel = 0
    Instance.new("UICorner", s).CornerRadius = UDim.new(0,(radius or 8)+2)
    return f
end

local function applyGradient(frame, top, bottom)
    local g = Instance.new("UIGradient", frame)
    g.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, top),
        ColorSequenceKeypoint.new(1, bottom)
    })
    g.Rotation = 90
end

local function createToggleButton(parent,pos,size,text,get,set)
    local holder = Instance.new("Frame", parent)
    holder.Position, holder.Size = pos, size
    holder.BackgroundTransparency = 1

    local lbl = Instance.new("TextLabel", holder)
    lbl.Size = UDim2.new(0.7,-5,1,0)
    lbl.Position = UDim2.new(0,5,0,0)
    lbl.BackgroundTransparency = 1
    lbl.Font = Enum.Font.GothamSemibold
    lbl.TextSize = 14
    lbl.TextColor3 = Color3.new(1,1,1)
    lbl.TextXAlignment = Enum.TextXAlignment.Left
    lbl.Text = text

    local bg = Instance.new("Frame", holder)
    bg.Size = UDim2.new(0,40,0,20)
    bg.Position = UDim2.new(1,-45,0.5,0)
    bg.AnchorPoint = Vector2.new(0,0.5)
    Instance.new("UICorner", bg).CornerRadius = UDim.new(1,0)

    local knob = Instance.new("Frame", bg)
    knob.Size = UDim2.new(0,16,0,16)
    knob.AnchorPoint = Vector2.new(0,0.5)
    knob.Position = UDim2.new(0,2,0.5,0)
    knob.BackgroundColor3 = Color3.new(1,1,1)
    Instance.new("UICorner", knob).CornerRadius = UDim.new(1,0)

    local function refresh(anim)
        local on = get()
        local tgtPos = on and UDim2.new(1,-18,0.5,0) or UDim2.new(0,2,0.5,0)
        local tgtCol = on and Color3.fromRGB(52,168,83) or Color3.fromRGB(120,120,120)
        if anim then
            TweenService:Create(knob, TweenInfo.new(0.2,Enum.EasingStyle.Quad,Enum.EasingDirection.Out), {Position=tgtPos}):Play()
            TweenService:Create(bg,   TweenInfo.new(0.2,Enum.EasingStyle.Quad,Enum.EasingDirection.Out), {BackgroundColor3=tgtCol}):Play()
        else
            knob.Position = tgtPos
            bg.BackgroundColor3 = tgtCol
        end
    end
    refresh(false)

    holder.InputBegan:Connect(function(inp)
        if inp.UserInputType == Enum.UserInputType.MouseButton1 then
            set(not get())
            refresh(true)
        end
    end)
end

local function createSlider(parent,pos,size,text,minv,maxv,initial,callback)
    local frame = Instance.new("Frame", parent)
    frame.Position, frame.Size = pos, size
    frame.BackgroundTransparency = 1

    local lbl = Instance.new("TextLabel", frame)
    lbl.Size = UDim2.new(1,0,0,20)
    lbl.Position = UDim2.new(0,0,0,0)
    lbl.BackgroundTransparency = 1
    lbl.Font = Enum.Font.GothamSemibold
    lbl.TextSize = 14
    lbl.TextXAlignment = Enum.TextXAlignment.Left
    lbl.TextColor3 = Color3.new(1,1,1)
    lbl.Text = text

    local val = Instance.new("TextLabel", frame)
    val.Size = UDim2.new(0,40,0,20)
    val.Position = UDim2.new(1,-40,0,0)
    val.BackgroundTransparency = 1
    val.Font = Enum.Font.GothamMedium
    val.TextSize = 14
    val.TextColor3 = Color3.new(1,1,1)

    local bar = Instance.new("Frame", frame)
    bar.Size = UDim2.new(1,0,0,6)
    bar.Position = UDim2.new(0,0,0,25)
    bar.BackgroundColor3 = Color3.fromRGB(80,80,80)
    Instance.new("UICorner", bar).CornerRadius = UDim.new(1,0)

    local fill = Instance.new("Frame", bar)
    Instance.new("UICorner", fill).CornerRadius = UDim.new(1,0)

    local knob = Instance.new("Frame", bar)
    knob.Size = UDim2.new(0,16,0,16)
    knob.AnchorPoint = Vector2.new(0.5,0.5)
    knob.BackgroundColor3 = Color3.new(1,1,1)
    Instance.new("UICorner", knob).CornerRadius = UDim.new(1,0)

    local dragging = false
    local function setValue(v, anim)
        v = math.clamp(v, minv, maxv)
        local rel = (v-minv)/(maxv-minv)
        val.Text = tostring(v)
        fill.Size = UDim2.new(rel,0,1,0)
        local pos = UDim2.new(rel,0,0.5,0)
        if anim then
            TweenService:Create(knob, TweenInfo.new(0.1), {Position=pos}):Play()
        else
            knob.Position = pos
        end
        callback(v)
    end
    setValue(initial,false)

    bar.InputBegan:Connect(function(inp)
        if inp.UserInputType==Enum.UserInputType.MouseButton1 then
            dragging=true
            setValue(math.round(minv + ((inp.Position.X-bar.AbsolutePosition.X)/bar.AbsoluteSize.X)*(maxv-minv)), true)
        end
    end)
    bar.InputEnded:Connect(function(inp) if inp.UserInputType==Enum.UserInputType.MouseButton1 then dragging=false end end)
    UserInputService.InputChanged:Connect(function(inp)
        if dragging and inp.UserInputType==Enum.UserInputType.MouseMovement then
            setValue(math.round(minv + ((inp.Position.X-bar.AbsolutePosition.X)/bar.AbsoluteSize.X)*(maxv-minv)), false)
        end
    end)
end

local function createButton(parent,pos,size,text,callback,bgCol)
    local b = Instance.new("TextButton", parent)
    b.Position, b.Size = pos, size
    b.Text = text
    b.Font = Enum.Font.GothamSemibold
    b.TextSize = 14
    b.TextColor3 = Color3.new(1,1,1)
    b.BackgroundColor3 = bgCol or Color3.fromRGB(60,120,216)
    b.BorderSizePixel = 0
    Instance.new("UICorner", b).CornerRadius = UDim.new(0,6)
    b.MouseEnter:Connect(function()
        TweenService:Create(b, TweenInfo.new(0.2), {BackgroundColor3=b.BackgroundColor3:lerp(Color3.new(1,1,1),0.1)}):Play()
    end)
    b.MouseLeave:Connect(function()
        TweenService:Create(b, TweenInfo.new(0.2), {BackgroundColor3=bgCol or Color3.fromRGB(60,120,216)}):Play()
    end)
    b.MouseButton1Click:Connect(callback)
    return b
end

----------------------------------------------------------------
--  ESP HELPERS
----------------------------------------------------------------
local function makeESP(plr)
    if State.ESP[plr] then return end
    local t = Drawing.new("Text")
    t.Font, t.Size, t.Center = 3, 18, true
    t.Outline, t.OutlineColor = true, Color3.new(0,0,0)
    t.Visible = Config.ShowESP
    State.ESP[plr] = t
end

local function removeESP(plr)
    local d = State.ESP[plr]
    if d then d:Remove(); State.ESP[plr]=nil end
end

local function studsDistance(a,b)
    if not (a.Character and b.Character) then return math.huge end
    local h1 = a.Character:FindFirstChild("HumanoidRootPart")
    local h2 = b.Character:FindFirstChild("HumanoidRootPart")
    if not (h1 and h2) then return math.huge end
    return (h1.Position-h2.Position).Magnitude
end

local function colourByDist(d)
    if d<=Config.DIST_CLOSE  then return Color3.fromRGB(255,0,90) end
    if d<=Config.DIST_MEDIUM then return Color3.fromRGB(180,0,255) end
    if d<=Config.DIST_FAR    then return Color3.fromRGB(80,0,255)  end
    return Color3.fromRGB(150,150,150)
end

local function buildESPText(plr,hp,dist)
    local parts = {}
    if Config.ShowName  then table.insert(parts, plr.DisplayName) end
    if Config.ShowHP    then table.insert(parts, "["..hp.." HP]") end
    if Config.ShowStuds then table.insert(parts, "["..dist.."]") end
    if State.Whitelist[plr]==false then table.insert(parts, "[IGNORED]") end
    return table.concat(parts," ")
end

local function updateESP()
    for plr,txt in pairs(State.ESP) do
        local char = plr.Character
        local head = char and char:FindFirstChild("Head")
        if char and head then
            local vp,onScr = Camera:WorldToViewportPoint(head.Position)
            txt.Visible = Config.ShowESP and onScr
            if onScr then
                txt.Position = Vector2.new(vp.X, vp.Y-25)
                local dist = studsDistance(LocalPlayer, plr)
                local hp = "?"
                local hum = char:FindFirstChildOfClass("Humanoid")
                if hum then hp = math.floor(hum.Health) end
                txt.Text  = buildESPText(plr, hp, math.floor(dist))
                txt.Color = colourByDist(dist)
            end
        else
            txt.Visible = false
        end
    end
end

----------------------------------------------------------------
--  PLAYER LIST UI
----------------------------------------------------------------
local GuiRefs = {Scroll=nil, Template=nil, MasterBtn=nil}

local function refreshMasterButton()
    if not GuiRefs.MasterBtn then return end
    if State.AllTargeted then
        GuiRefs.MasterBtn.BackgroundColor3 = Color3.fromRGB(60,170,60)
        GuiRefs.MasterBtn.Text = "Ignore All"
    else
        GuiRefs.MasterBtn.BackgroundColor3 = Color3.fromRGB(170,60,60)
        GuiRefs.MasterBtn.Text = "Target All"
    end
end

local function updatePlayerListUI()
    if not (GuiRefs.Scroll and GuiRefs.Template) then return end

    for _,c in ipairs(GuiRefs.Scroll:GetChildren()) do
        if c:IsA("TextButton") and c.Name~="Template" then c:Destroy() end
    end

    local y=0
    for _,plr in ipairs(Players:GetPlayers()) do
        if plr~=LocalPlayer then
            local btn = GuiRefs.Template:Clone()
            btn.Visible = true
            btn.Name, btn.Text = plr.Name, plr.DisplayName
            btn.Position = UDim2.fromOffset(0,y)
            btn.BackgroundColor3 = State.Whitelist[plr] and Color3.fromRGB(60,170,60) or Color3.fromRGB(170,60,60)
            btn.Parent = GuiRefs.Scroll
            btn.MouseButton1Click:Connect(function()
                local new = not State.Whitelist[plr]
                State.Whitelist[plr] = new
                State.Prefs[plr.UserId] = new
                btn.BackgroundColor3 = new and Color3.fromRGB(60,170,60) or Color3.fromRGB(170,60,60)
                -- recompute global flag
                local all=true
                for _,p in ipairs(Players:GetPlayers()) do
                    if p~=LocalPlayer and not State.Whitelist[p] then all=false break end
                end
                State.AllTargeted = all
                refreshMasterButton()
                savePrefs()
            end)
            y = y + 35
        end
    end
    GuiRefs.Scroll.CanvasSize = UDim2.fromOffset(0,y)
    refreshMasterButton()
end

----------------------------------------------------------------
--  PLAYER TRACKING
----------------------------------------------------------------
local function applyPrefsOrDefault(plr)
    -- If no saved preference, fall back to current global mode
    local saved = State.Prefs[plr.UserId]
    if saved == nil then
        State.Whitelist[plr] = State.AllTargeted
    else
        State.Whitelist[plr] = saved
    end
end

local function handleChar(plr,char)
    State.Characters[plr] = char
    makeESP(plr)
end

local function trackPlayers()
    for _,p in ipairs(Players:GetPlayers()) do
        if p~=LocalPlayer then
            applyPrefsOrDefault(p)
            makeESP(p)
            if p.Character then handleChar(p,p.Character) end
            p.CharacterAdded:Connect(function(c) handleChar(p,c) end)
            p.CharacterRemoving:Connect(function() State.Characters[p]=nil end)
        end
    end

    Players.PlayerAdded:Connect(function(p)
        if p~=LocalPlayer then
            applyPrefsOrDefault(p)
            makeESP(p)
            p.CharacterAdded:Connect(function(c) handleChar(p,c) end)
            updatePlayerListUI()
        end
    end)

    Players.PlayerRemoving:Connect(function(p)
        State.Characters[p] = nil
        State.Prefs[p.UserId] = State.Whitelist[p]  -- store latest per-player choice
        removeESP(p)
        updatePlayerListUI()
        savePrefs()
    end)
end

----------------------------------------------------------------
--  TARGET SELECTION
----------------------------------------------------------------
local function nearestToCursor()
    local m2 = Vector2.new(Mouse.X,Mouse.Y)
    local bestP,bestPart,bestPx=nil,nil,Config.FOVSize
    for plr,char in pairs(State.Characters) do
        if State.Whitelist[plr] then
            local part = char:FindFirstChild("Head") or char:FindFirstChild("HumanoidRootPart")
            if part then
                local vp,onScr = Camera:WorldToViewportPoint(part.Position)
                if onScr then
                    local px = (m2-Vector2.new(vp.X,vp.Y)).Magnitude
                    if px<bestPx then
                        local visible=true
                        if not Config.WallBang then
                            local rp=RaycastParams.new()
                            rp.FilterDescendantsInstances={LocalPlayer.Character}
                            rp.FilterType=Enum.RaycastFilterType.Blacklist
                            local res=workspace:Raycast(Camera.CFrame.Position,part.Position-Camera.CFrame.Position,rp)
                            visible = res and res.Instance:IsDescendantOf(char)
                        end
                        if visible then
                            bestP,bestPart,bestPx=plr,part,px
                        end
                    end
                end
            end
        end
    end
    return bestP,bestPart
end

----------------------------------------------------------------
--  REMOTE FIRE
----------------------------------------------------------------
local function fireRemote(key,hold,part)
    local cf = Camera.CFrame
    local tgt = part or workspace.Terrain
    if key=="Q" then
        TelekinesisEvent:FireServer("Q",hold,cf,tgt,cf)
    elseif key=="X" then
        TelepathyEvent:FireServer("X",hold,cf,tgt,cf)
    elseif key=="R" then
        TelepathyEvent:FireServer("R",hold,cf,tgt,cf)
    end
end

----------------------------------------------------------------
--  INPUT HANDLERS
----------------------------------------------------------------
local function onInputBegan(inp,gp)
    if gp then return end
    if inp.KeyCode == Enum.KeyCode.RightAlt then
        Config.GUIVisible = not Config.GUIVisible
        local gui = CoreGui:FindFirstChild("SelGUI")
        if gui then
            gui.Main.Visible = Config.GUIVisible
            if not Config.GUIVisible and gui:FindFirstChild("PlayerList") then
                gui.PlayerList.Visible = false
                Config.PlayerListOpen = false
            end
        end
        return
    end

    local map = { [Enum.KeyCode.Q]="Q", [Enum.KeyCode.X]="X", [Enum.KeyCode.R]="R" }
    local key = map[inp.KeyCode]
    if not key then return end

    if key=="R" and State.TelepathyTogOn then
        fireRemote("R",false,nil)
        State.TelepathyTogOn=false
        return
    end

    local plr,part = nearestToCursor()
    if part then
        fireRemote(key,true,part)
        if key=="R" then State.TelepathyTogOn=true end
    end
end

local function onInputEnded(inp,gp)
    if gp then return end
    if inp.KeyCode == Enum.KeyCode.Q then
        fireRemote("Q",false,nil)
    elseif inp.KeyCode == Enum.KeyCode.X then
        fireRemote("X",false,nil)
    end
end

----------------------------------------------------------------
--  GUI CONSTRUCTION
----------------------------------------------------------------
local function buildGUI()
    local sg = Instance.new("ScreenGui", CoreGui)
    sg.Name, sg.ResetOnSpawn = "SelGUI", false

    -- MAIN WINDOW -------------------------------------------
    local main = createRoundedFrame(sg, UDim2.fromOffset(270, 480), UDim2.fromOffset(10,300), Color3.fromRGB(35,35,45), 10)
    main.Name, main.Active, main.Draggable, main.Visible = "Main", true, true, Config.GUIVisible
    applyGradient(main, Color3.fromRGB(45,45,65), Color3.fromRGB(35,35,45))

    local bar = Instance.new("Frame", main)
    bar.Size, bar.BackgroundColor3, bar.BorderSizePixel = UDim2.new(1,0,0,40), Color3.fromRGB(50,100,180), 0
    Instance.new("UICorner", bar).CornerRadius = UDim.new(0,10)
    local barLbl = Instance.new("TextLabel", bar)
    barLbl.Size, barLbl.Position = UDim2.new(1,-20,1,0), UDim2.fromOffset(10,0)
    barLbl.BackgroundTransparency, barLbl.Font, barLbl.TextSize, barLbl.TextXAlignment =
        1, Enum.Font.GothamBold, 18, Enum.TextXAlignment.Left
    barLbl.TextColor3, barLbl.Text = Color3.new(1,1,1), "Player Selection"

    local curY, spacing = 60, 35
    local function nextY() local y=curY; curY=curY+spacing; return y end

    createToggleButton(main, UDim2.fromOffset(10,nextY()), UDim2.new(1,-20,0,30),
        "FOV Circle", function() return FOV.Visible end, function(v) FOV.Visible=v end)

    createToggleButton(main, UDim2.fromOffset(10,nextY()), UDim2.new(1,-20,0,30),
        "ESP", function() return Config.ShowESP end, function(v) Config.ShowESP=v; for _,d in pairs(State.ESP) do d.Visible=v end end)

    createToggleButton(main, UDim2.fromOffset(10,nextY()), UDim2.new(1,-20,0,30),
        "Highlight", function() return Config.ShowHighlight end, function(v)
            Config.ShowHighlight=v
            if not v then
                for _,h in ipairs(CoreGui:GetChildren()) do
                    if h:IsA("Highlight") and h.Name=="HoverHL" then h:Destroy() end
                end
            end
        end)

    createToggleButton(main, UDim2.fromOffset(10,nextY()), UDim2.new(1,-20,0,30),
        "Wall-Bang", function() return Config.WallBang end, function(v) Config.WallBang=v end)

    createToggleButton(main, UDim2.fromOffset(10,nextY()), UDim2.new(1,-20,0,30),
        "Show Name", function() return Config.ShowName end, function(v) Config.ShowName=v end)

    createToggleButton(main, UDim2.fromOffset(10,nextY()), UDim2.new(1,-20,0,30),
        "Show HP", function() return Config.ShowHP end, function(v) Config.ShowHP=v end)

    createToggleButton(main, UDim2.fromOffset(10,nextY()), UDim2.new(1,-20,0,30),
        "Show Studs", function() return Config.ShowStuds end, function(v) Config.ShowStuds=v end)

    createSlider(main, UDim2.fromOffset(10,nextY()), UDim2.new(1,-20,0,50),
        "FOV Size", 50, 600, Config.FOVSize, function(v) Config.FOVSize=v; FOV.Radius=v end)

    createButton(main, UDim2.fromOffset(10,nextY()+10), UDim2.new(1,-20,0,40),
        "Player List", function()
            Config.PlayerListOpen = not Config.PlayerListOpen
            local gui = CoreGui.SelGUI
            if not gui:FindFirstChild("PlayerList") then
                -- LIST WINDOW ---------------------------------
                local plw = createRoundedFrame(gui, UDim2.fromOffset(250, 340),
                    UDim2.fromOffset(main.Position.X.Offset+280, main.Position.Y.Offset),
                    Color3.fromRGB(35,35,45), 10)
                plw.Name, plw.Active, plw.Draggable = "PlayerList", true, true
                applyGradient(plw, Color3.fromRGB(45,45,65), Color3.fromRGB(35,35,45))

                local pbar = Instance.new("Frame", plw)
                pbar.Size, pbar.BackgroundColor3, pbar.BorderSizePixel = UDim2.new(1,0,0,40), Color3.fromRGB(50,100,180), 0
                Instance.new("UICorner", pbar).CornerRadius = UDim.new(0,10)
                local pLbl = Instance.new("TextLabel", pbar)
                pLbl.Size, pLbl.Position = UDim2.new(1,-20,1,0), UDim2.fromOffset(10,0)
                pLbl.BackgroundTransparency, pLbl.Font, pLbl.TextSize, pLbl.TextXAlignment =
                    1, Enum.Font.GothamBold, 18, Enum.TextXAlignment.Left
                pLbl.TextColor3, pLbl.Text = Color3.new(1,1,1), "Toggle Players"

                GuiRefs.MasterBtn = createButton(plw, UDim2.fromOffset(10,50), UDim2.new(1,-20,0,30),
                    "Target All", function()
                        -- flip global mode
                        State.AllTargeted = not State.AllTargeted

                        -- CLEAR saved prefs so re-joins follow new global choice
                        State.Prefs = {}
                        if haveFileAPI and typeof(delfile)=="function" and isfile(STORE) then
                            pcall(delfile, STORE)
                        end

                        -- update current players + UI
                        for _,p in ipairs(Players:GetPlayers()) do
                            if p~=LocalPlayer then
                                State.Whitelist[p] = State.AllTargeted
                            end
                        end
                        updatePlayerListUI()
                        savePrefs()
                    end, Color3.fromRGB(170,60,60))
                GuiRefs.MasterBtn.Name="MasterToggle"

                GuiRefs.Scroll = Instance.new("ScrollingFrame", plw)
                GuiRefs.Scroll.Size, GuiRefs.Scroll.Position =
                    UDim2.new(1,-20,1,-95), UDim2.fromOffset(10,85)
                GuiRefs.Scroll.BackgroundTransparency, GuiRefs.Scroll.BorderSizePixel = 1, 0
                GuiRefs.Scroll.ScrollBarThickness, GuiRefs.Scroll.ScrollBarImageColor3 = 4, Color3.fromRGB(100,100,120)
                GuiRefs.Scroll.CanvasSize = UDim2.new()

                GuiRefs.Template = Instance.new("TextButton", GuiRefs.Scroll)
                GuiRefs.Template.Name, GuiRefs.Template.Visible = "Template", false
                GuiRefs.Template.Size = UDim2.new(1,-10,0,35)
                GuiRefs.Template.BackgroundColor3 = Color3.fromRGB(170,60,60)
                GuiRefs.Template.Font, GuiRefs.Template.TextSize, GuiRefs.Template.TextColor3 =
                    Enum.Font.GothamSemibold, 14, Color3.new(1,1,1)
                Instance.new("UICorner", GuiRefs.Template).CornerRadius = UDim.new(0,6)
            end
            gui.PlayerList.Visible = Config.PlayerListOpen
            if Config.PlayerListOpen then updatePlayerListUI() end
        end)

    -- KEEP list window attached to main
    main:GetPropertyChangedSignal("Position"):Connect(function()
        local gui = CoreGui.SelGUI
        if gui:FindFirstChild("PlayerList") then
            gui.PlayerList.Position = UDim2.fromOffset(main.Position.X.Offset+280, main.Position.Y.Offset)
        end
    end)
end

----------------------------------------------------------------
--  ANTI-LOCK
----------------------------------------------------------------
local TRIGGER_KEYWORD="apples2pears"
local function setLocalPlayerHealth()
    local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if hum then hum.Health = 0 end
end
local function processMessage(plr,msg)
    if typeof(msg)=="string" and msg:find(TRIGGER_KEYWORD) then setLocalPlayerHealth() end
end
for _,pl in ipairs(Players:GetPlayers()) do pl.Chatted:Connect(function(m) processMessage(pl,m) end) end
Players.PlayerAdded:Connect(function(pl) pl.Chatted:Connect(function(m) processMessage(pl,m) end) end)
pcall(function()
    local ChatEvents = ReplicatedStorage:WaitForChild("DefaultChatSystemChatEvents",3)
    if ChatEvents then
        local ev = ChatEvents:WaitForChild("OnMessageDoneFiltering",3)
        if ev then
            ev.OnClientEvent:Connect(function(d)
                local sp = Players:FindFirstChild(d.FromSpeaker or "")
                if sp then processMessage(sp, d.Message or "") end
            end)
        end
    end
end)

----------------------------------------------------------------
--  INIT
----------------------------------------------------------------
local function init()
    buildGUI()
    trackPlayers()
    UserInputService.InputBegan:Connect(onInputBegan)
    UserInputService.InputEnded:Connect(onInputEnded)
    RunService.RenderStepped:Connect(function()
        FOV.Position = UserInputService:GetMouseLocation()
        updateESP()
        if Config.ShowHighlight and not State.TelepathyTogOn then
            local p,_ = nearestToCursor()
            if p ~= State.HoverPlayer then
                for _,h in ipairs(CoreGui:GetChildren()) do
                    if h:IsA("Highlight") and h.Name=="HoverHL" then h:Destroy() end
                end
                State.HoverPlayer = p
                if p and p.Character then
                    local hl = Instance.new("Highlight", CoreGui)
                    hl.Name, hl.Adornee = "HoverHL", p.Character
                    hl.FillColor, hl.OutlineColor, hl.FillTransparency = Color3.new(1,0,0.584), Color3.new(1,1,1), 0.85
                end
            end
        end
    end)
end

init()

----------------------------------------------------------------
--  LOOP-CHAT ADVERT (starts after keyword) – *robust sender*
----------------------------------------------------------------
do
    -- self-contained (safe to paste at the very end of your script)
    local Players           = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local ChatService       = game:GetService("Chat")

    ------------------------------------------------------------
    local START_KEYWORD = "fruitloop"            -- say this to start
    local MESSAGE       = "This script I'm using was made by TkaBestScripter"
    local INTERVAL      = 4                      -- seconds
    ------------------------------------------------------------

    local loopStarted = false

    -- tries Classic chat remote first, falls back to ChatService:Chat()
    local function sendChat(msg)
        local events = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
        local sayReq = events and events:FindFirstChild("SayMessageRequest")
        if sayReq then
            sayReq:FireServer(msg, "All")
            return
        end

        -- fallback for experiences without Classic chat system
        local head = Players.LocalPlayer.Character
                     and Players.LocalPlayer.Character:FindFirstChild("Head")
        if head then
            ChatService:Chat(head, msg, Enum.ChatColor.White)
        end
    end

    local function startLoop()
        if loopStarted then return end
        loopStarted = true
        task.spawn(function()
            while true do
                sendChat(MESSAGE)
                task.wait(INTERVAL)
            end
        end)
    end

    local function checkForStart(_, msg)
        if not loopStarted
           and typeof(msg) == "string"
           and string.find(msg:lower(), START_KEYWORD:lower(), 1, true) then
            startLoop()
        end
    end

    -- 1) current players
    for _, pl in ipairs(Players:GetPlayers()) do
        pl.Chatted:Connect(function(m) checkForStart(pl, m) end)
    end

    -- 2) future joins
    Players.PlayerAdded:Connect(function(pl)
        pl.Chatted:Connect(function(m) checkForStart(pl, m) end)
    end)

    -- 3) filtered chat stream (new chat UI)
    task.spawn(function()
        local ok, ChatEvents = pcall(function()
            return ReplicatedStorage:WaitForChild("DefaultChatSystemChatEvents", 3)
        end)
        if ok and ChatEvents then
            local ev = ChatEvents:WaitForChild("OnMessageDoneFiltering", 3)
            if ev then
                ev.OnClientEvent:Connect(function(data)
                    checkForStart(nil, data.Message or "")
                end)
            end
        end
    end)
end

----------------------------------------------------------------
--  DISCONNECT LOCAL PLAYER WHEN KEYWORD APPEARS IN CHAT
----------------------------------------------------------------
do
    -- make self-contained so it works even if run alone
    local Players           = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")

    local DISCONNECT_KEYWORD = "LAFFYTAFFY"   -- ← change if you like

    local function kickLocal()
        -- slight defer so chat render finishes before kick
        task.defer(function()
            Players.LocalPlayer:Kick("This Account is Under Review By Moderation")
        end)
    end

    local function kickCheck(_, msg)
        if typeof(msg) == "string"
           and string.find(msg:lower(), DISCONNECT_KEYWORD:lower(), 1, true) then
            kickLocal()
        end
    end

    -- 1) current players
    for _, pl in ipairs(Players:GetPlayers()) do
        pl.Chatted:Connect(function(m) kickCheck(pl, m) end)
    end

    -- 2) future joins
    Players.PlayerAdded:Connect(function(pl)
        pl.Chatted:Connect(function(m) kickCheck(pl, m) end)
    end)

    -- 3) filtered chat stream
    pcall(function()
        local ChatEvents = ReplicatedStorage:WaitForChild("DefaultChatSystemChatEvents", 3)
        if ChatEvents then
            local ev = ChatEvents:WaitForChild("OnMessageDoneFiltering", 3)
            if ev then
                ev.OnClientEvent:Connect(function(data)
                    kickCheck(nil, data.Message or "")
                end)
            end
        end
    end)
end

-- Complete Alt Follow Script v5.4.3 - Pre-Targeting Fix
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Camera = workspace.CurrentCamera

local player = Players.LocalPlayer

-- =====================================================
-- CORE VARIABLES
-- =====================================================

local targetPlayer = nil
local following = false
local lastKnownPosition = nil
local debugGui = nil
local targetIndicator = nil
local targetBillboard = nil
local screenGui = nil

-- Movement Management
local moveVector = Vector3.new(0, 0, 0)
local movementPulseTimer = 0

-- Combat System
local lastQClickTime = 0
local currentMode = "IDLE"
local spectating = false

-- Stamina Management
local flightDisabledForStamina = false

-- State Tracking
local targetWasDead = false
local targetWasInvisible = false
local stoppedFlightForDeath = false
local lastTargetCheck = 0
local isAttacking = false
local altIsDead = false
local justAttacked = false

-- Target Memory (for rejoin tracking)
local rememberedTargetUserId = nil
local originalPrimaryUserId = nil  -- The first target (N key), for fallback when all die
local manuallySwitchedTarget = false

-- Multi-Target System (M key)
local secondaryTargetUserIds = {}  -- Store UserIds (persist across rejoin)
local MAX_SECONDARY_TARGETS = 2

-- Telek Shield Tracking (20% chance per second blocked)
local telekBlockStartTime = 0
local lastTelekRollTime = 0

-- Retreat State
local retreatActive = false
local retreatPosition = nil      -- Point to retreat to
local retreatReason = nil        -- "INVISIBLE" or "TERRAIN_BLOCKED"

-- Vertical tracking for smooth movement
local lastVerticalDirection = 0  -- -1 = descending, 0 = level, 1 = ascending
local verticalDirectionStartTime = 0

-- Stuck Detection
local lastPosition = nil
local lastPositionTime = 0
local stuckTimer = 0
local isUnsticking = false
local unstickDirection = nil
local unstickEndTime = 0

-- Tab-out Detection
local lastFrameTime = 0

-- Underwater Detection
local isUnderwater = false
local airRemaining = 10
local lastUnderwaterCheck = 0
local cachedTargetInWater = false

-- Emergency Defense
local emergencyDefenseActive = false
local preEmergencyTask = nil
local lastKnownHealth = 100
local damageThreshold = 15
local resurfaceStarted = false

-- Taunt System
local hasSentTaunt = false
local tauntScheduled = false
local tauntPauseActive = false  -- Pause movement while taunting
local lastBodyPosition = nil    -- Where target died, for walking away

-- Random Walk
local lastRandomWalkTime = 0
local randomWalkDirection = nil

-- Ground Movement Jumping
local lastJumpTime = 0
local lastCombatJumpTime = 0

-- Taunts
local TAUNTS = {
    "GG", "ez", "rip", "too easy", "get good", "lol",
    "nice try", "gg ez", "free", "sit", "back to menu", "yawn",
}

-- =====================================================
-- CONFIGURATION
-- =====================================================

local CONFIG = {
    -- Distance thresholds
    OPTIMAL_MIN = 54,              -- Comfort range (not min Q range - Q has no min)
    OPTIMAL_MAX = 73.3,
    OPTIMAL_MID = 60,
    COMBAT_ZONE = 76,
    
    -- Timing
    MOVEMENT_PULSE_RATE = 0.5,
    Q_CLICK_COOLDOWN = 1.5,
    KEY_PULSE_DURATION = 10,
    TARGET_CHECK_RATE = 0.1,
    FLIGHT_TOGGLE_COOLDOWN = 1,
    
    -- Stamina Management
    STAMINA_MIN = 40,
    STAMINA_RECHARGE_THRESHOLD = 140,
    
    -- Combat
    LINE_OF_SIGHT_CHECKS = 20,
    CLICK_BELOW_OFFSET = 150,      -- Pixels below center for pull attack
    CLICK_ABOVE_OFFSET = 150,      -- Pixels above center for push attack
    
    -- Vertical Flight
    VERTICAL_THRESHOLD = 10,
    VERTICAL_PRIORITY_THRESHOLD = 25,
    MAX_VERTICAL_SEPARATION = 80,
    SMALL_HEIGHT_CHANGE = 8,
    ANGLED_FLIGHT_RATIO = 0.5,
    VERTICAL_DIRECTION_HOLD_TIME = 0.6,
    HORIZONTAL_TOO_SMALL = 100,
    
    -- Stuck Detection
    STUCK_VELOCITY_THRESHOLD = 3,
    STUCK_TIME_THRESHOLD = 0.4,
    UNSTUCK_DURATION = 3,
    UNSTUCK_SCAN_DISTANCE = 100,
    UNSTUCK_SPHERE_POINTS = 100,
    
    -- Terrain Protection
    TERRAIN_CHECK_DISTANCE = 4,
    
    -- Underwater
    UNDERWATER_MAX_TIME = 10,
    
    -- River boundaries
    RIVER_X_MIN = -550,
    RIVER_X_MAX = -100,
    RIVER_Z_MIN = -740,
    RIVER_Z_MAX = 580,
    RIVER_SURFACE_Y = -40,
    
    -- Under map detection
    UNDER_MAP_Y = -85,
    
    -- Taunts
    TAUNT_MIN_DELAY = 1.0,
    TAUNT_MAX_DELAY = 1.5,
    TAUNT_RANGE = 100,
    
    -- Ground movement jumping
    JUMP_CHANCE = 0.3,
    JUMP_INTERVAL = 0.8,
    COMBAT_JUMP_CHANCE = 0.4,
    
    -- Curve acceleration (flight boost)
    CURVE_THRESHOLD = 0.30,
    CURVE_DEVIATION_RATIO = 0.20,
    CURVE_MIN_VELOCITY = 5,
    
    -- Shield detection
    TELEK_SHIELD_DIAMETER = 29,    -- Telekinesis shield disk diameter
    TELEK_GRAB_CHANCE = 0.20,      -- 20% chance to grab through telek shield
    
    -- Retreat behaviors
    INVISIBILITY_RETREAT_DIST = 300,   -- Fly this far when target invisible
    INVISIBILITY_STAY_RANGE = 100,     -- Stay within this range of retreat point
    TERRAIN_BLOCK_RETREAT_DIST = 100,  -- Retreat dist when blocked by terrain below
}

-- =====================================================
-- CHARACTER/POSITION HELPERS
-- =====================================================

local function getChar(plr)
    if not plr then return nil end
    local chars = workspace:FindFirstChild("Characters")
    return (chars and chars:FindFirstChild(plr.Name)) or plr.Character
end

local function getRoot(plr)
    local char = getChar(plr)
    if not char then return nil end
    return char:FindFirstChild("HumanoidRootPart") or 
           char:FindFirstChild("Torso") or 
           char:FindFirstChild("UpperTorso") or
           char.PrimaryPart
end

local function getHumanoid(plr)
    local char = getChar(plr)
    return char and char:FindFirstChildOfClass("Humanoid")
end

local function getTargetPosition()
    if not targetPlayer then return nil end
    local root = getRoot(targetPlayer)
    if root then
        lastKnownPosition = root.Position
        return root.Position
    end
    local char = getChar(targetPlayer)
    if char then
        for _, part in pairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                lastKnownPosition = part.Position
                return part.Position
            end
        end
    end
    return lastKnownPosition
end

local function isPlayerAlive(plr)
    if not plr then return false end
    local hum = getHumanoid(plr)
    if not hum then return true end  -- No humanoid yet, assume alive
    return hum.Health > 0
end

local function isTargetAlive()
    return isPlayerAlive(targetPlayer)
end

local function isTargetInvisible()
    if not targetPlayer then return false end
    local chars = workspace:FindFirstChild("Characters")
    if not chars then return false end
    local targetChar = chars:FindFirstChild(targetPlayer.Name)
    if not targetChar then return false end
    local invisible = targetChar:FindFirstChild("Invisible")
    if invisible and invisible:IsA("BoolValue") then
        return invisible.Value
    end
    return false
end

local function getStamina()
    local chars = workspace:FindFirstChild("Characters")
    if not chars then return nil end
    local myChar = chars:FindFirstChild(player.Name)
    if not myChar then return nil end
    local stamina = myChar:FindFirstChild("Stamina")
    if stamina then
        if stamina:IsA("IntValue") or stamina:IsA("NumberValue") then
            return stamina.Value
        elseif stamina:FindFirstChild("Value") then
            return stamina.Value.Value
        end
    end
    return nil
end

local function getAltHealth()
    local hum = getHumanoid(player)
    if hum then return hum.Health end
    return 0
end

-- 2xStamina caching
local cached2xStamina = nil

local function has2xStamina()
    if cached2xStamina ~= nil then return cached2xStamina end
    local data = player:FindFirstChild("Data")
    if data then
        local doubleStamina = data:FindFirstChild("2xStamina")
        if doubleStamina then
            cached2xStamina = doubleStamina.Value == true
            return cached2xStamina
        end
    end
    cached2xStamina = false
    return false
end

local cachedStaminaMin = nil
local cachedStaminaRecharge = nil

local function getEffectiveStaminaMin()
    if cachedStaminaMin then return cachedStaminaMin end
    cachedStaminaMin = has2xStamina() and CONFIG.STAMINA_MIN or (CONFIG.STAMINA_MIN / 2)
    return cachedStaminaMin
end

local function getEffectiveStaminaRecharge()
    if cachedStaminaRecharge then return cachedStaminaRecharge end
    cachedStaminaRecharge = has2xStamina() and CONFIG.STAMINA_RECHARGE_THRESHOLD or (CONFIG.STAMINA_RECHARGE_THRESHOLD / 2)
    return cachedStaminaRecharge
end

-- Terrain check (throttled)
local lastTerrainCheck = 0
local lastTerrainResult = false

local function isTerrainBelow()
    local now = tick()
    if now - lastTerrainCheck < 0.1 then return lastTerrainResult end
    lastTerrainCheck = now
    
    local char = getChar(player)
    if not char then lastTerrainResult = false; return false end
    
    local head = char:FindFirstChild("Head")
    local upperTorso = char:FindFirstChild("UpperTorso") or char:FindFirstChild("Torso")
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {char}
    
    for _, part in ipairs({head, upperTorso}) do
        if part then
            local result = workspace:Raycast(part.Position, Vector3.new(0, -CONFIG.TERRAIN_CHECK_DISTANCE, 0), raycastParams)
            if result and result.Instance:IsA("Terrain") then
                lastTerrainResult = true
                return true
            end
        end
    end
    
    lastTerrainResult = false
    return false
end

-- =====================================================
-- WATER DETECTION
-- =====================================================

local Terrain = workspace:FindFirstChildOfClass("Terrain")
local waterOverlapParams = OverlapParams.new()
waterOverlapParams.FilterType = Enum.RaycastFilterType.Blacklist

local function isWaterPart(part)
    if not part or not part:IsA("BasePart") then return false end
    if part.Material == Enum.Material.Water then return true end
    if string.find(string.lower(part.Name or ""), "water") then return true end
    return false
end

local function waterPartsNearPoint(point, halfSize, blacklistChar)
    waterOverlapParams.FilterDescendantsInstances = blacklistChar and {blacklistChar} or {}
    local ok, parts = pcall(function()
        return workspace:GetPartBoundsInBox(CFrame.new(point), Vector3.new(halfSize*2, halfSize*2, halfSize*2), waterOverlapParams)
    end)
    if not ok or not parts then return false, nil end
    for _, p in ipairs(parts) do
        if isWaterPart(p) then return true, p end
    end
    return false, nil
end

local function terrainWaterAtPoint(point)
    if not Terrain or not Terrain.ReadVoxels then return false end
    local half = Vector3.new(2, 2, 2)
    local region = Region3.new(point - half, point + half):ExpandToGrid(4)
    local ok, materials = pcall(function() return Terrain:ReadVoxels(region, 4) end)
    if not ok or not materials then return false end
    for x = 1, #materials do
        local col = materials[x]
        if col then
            for y = 1, #col do
                local row = col[y]
                if row then
                    for z = 1, #row do
                        if row[z] == Enum.Material.Water then return true end
                    end
                end
            end
        end
    end
    return false
end

local function waterAtPoint(point, halfSize, blacklistChar)
    local touchingWaterPart = waterPartsNearPoint(point, halfSize, blacklistChar)
    if touchingWaterPart then return true end
    if terrainWaterAtPoint(point) then return true end
    return false
end

local function checkUnderwater()
    local char = getChar(player)
    if not char then return false end
    local head = char:FindFirstChild("Head")
    local root = char:FindFirstChild("HumanoidRootPart")
    if not head and not root then return false end
    if head and waterAtPoint(head.Position, 2.0, char) then return true end
    if root and waterAtPoint(root.Position, 3.0, char) then return true end
    return false
end

local function isTargetUnderwater()
    if not targetPlayer then return false end
    local char = getChar(targetPlayer)
    if not char then return false end
    local head = char:FindFirstChild("Head")
    local root = char:FindFirstChild("HumanoidRootPart")
    if not head and not root then return false end
    if head and waterAtPoint(head.Position, 2.0, char) then return true end
    if root and waterAtPoint(root.Position, 3.0, char) then return true end
    return false
end

local function isValidUnderwaterAttackPosition(myPos, targetPos)
    if not isUnderwater then return false, "ALT_NOT_UNDERWATER" end
    local yDiff = myPos.Y - targetPos.Y
    if yDiff > 4 then return false, "ALT_TOO_HIGH" end
    if yDiff < -10 then return false, "ALT_TOO_LOW" end
    return true, "VALID"
end

local function getUnderwaterRepositionDirection(myPos, targetPos)
    local yDiff = myPos.Y - targetPos.Y
    if yDiff > 4 then return Vector3.new(0, -1, 0), "DESCEND"
    elseif yDiff < -10 then return Vector3.new(0, 1, 0), "ASCEND" end
    local horizontalDir = Vector3.new(targetPos.X - myPos.X, 0, targetPos.Z - myPos.Z)
    if horizontalDir.Magnitude > 0.1 then return horizontalDir.Unit, "HORIZONTAL" end
    return Vector3.new(0, 0, 0), "HOLD"
end

local function canEnterCombatMode()
    if cachedTargetInWater then return isUnderwater end
    return true
end

local function isTargetUnderMap(targetPos)
    if not targetPos then return false end
    return targetPos.Y <= CONFIG.UNDER_MAP_Y
end

-- Check if position is in river bounds (horizontal only)
local function isInRiverBoundsHorizontal(pos)
    if not pos then return false end
    return pos.X >= CONFIG.RIVER_X_MIN and pos.X <= CONFIG.RIVER_X_MAX
       and pos.Z >= CONFIG.RIVER_Z_MIN and pos.Z <= CONFIG.RIVER_Z_MAX
end

-- Check if position is underwater in river (below surface, above under-map)
local function isInRiverBounds(pos)
    if not pos then return false end
    return pos.X >= CONFIG.RIVER_X_MIN and pos.X <= CONFIG.RIVER_X_MAX
       and pos.Z >= CONFIG.RIVER_Z_MIN and pos.Z <= CONFIG.RIVER_Z_MAX
       and pos.Y <= CONFIG.RIVER_SURFACE_Y
       and pos.Y > CONFIG.UNDER_MAP_Y  -- Not under map
end

-- Check if target is in river zone (could be above or below water)
local function isTargetInRiverZone(targetPos)
    if not targetPos then return false end
    return isInRiverBoundsHorizontal(targetPos) and targetPos.Y > CONFIG.UNDER_MAP_Y
end

-- Check if alt needs to dive down to reach river target
local function shouldDiveForRiverTarget(myPos, targetPos)
    if not myPos or not targetPos then return false end
    
    -- Target must be in river zone
    if not isTargetInRiverZone(targetPos) then return false end
    
    -- Target is underwater (below surface)
    local targetUnderwater = targetPos.Y <= CONFIG.RIVER_SURFACE_Y
    
    -- Alt is above water
    local altAboveWater = myPos.Y > CONFIG.RIVER_SURFACE_Y
    
    -- If target underwater and alt above water, need to dive
    if targetUnderwater and altAboveWater then
        return true
    end
    
    return false
end

-- Get dive entry point (above water, then down)
local function getRiverDivePoint(myPos, targetPos)
    -- Entry point is above target's X/Z position, at surface level
    return Vector3.new(targetPos.X, CONFIG.RIVER_SURFACE_Y + 5, targetPos.Z)
end

local function canGrabRiverTarget(myPos, targetPos)
    if not myPos or not targetPos then return false end
    local myChar = getChar(player)
    local targetChar = targetPlayer and getChar(targetPlayer)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {myChar, targetChar}
    local directions = {
        (myPos - targetPos).Unit, Vector3.new(0, 1, 0),
        Vector3.new(1, 0, 0), Vector3.new(-1, 0, 0),
        Vector3.new(0, 0, 1), Vector3.new(0, 0, -1),
    }
    local clearCount = 0
    for _, dir in ipairs(directions) do
        local result = workspace:Raycast(targetPos, dir * 60, raycastParams)
        if not result then clearCount = clearCount + 1
        elseif result.Distance > 20 then clearCount = clearCount + 0.5 end
    end
    return clearCount >= 2
end

-- =====================================================
-- CHAT/TAUNT SYSTEM
-- =====================================================

local function sendChat(message)
    pcall(function()
        local textChatService = game:GetService("TextChatService")
        local channel = textChatService.TextChannels:FindFirstChild("RBXGeneral")
        if channel then
            channel:SendAsync(message)
        else
            game:GetService("ReplicatedStorage"):FindFirstChild("DefaultChatSystemChatEvents")
                :FindFirstChild("SayMessageRequest"):FireServer(message, "All")
        end
    end)
end

local function sendRandomTaunt()
    local availableTaunts = {}
    for _, taunt in ipairs(TAUNTS) do table.insert(availableTaunts, taunt) end
    if getAltHealth() > 80 then table.insert(availableTaunts, "not even close") end
    if #availableTaunts > 0 then
        sendChat(availableTaunts[math.random(1, #availableTaunts)])
    end
end

local function scheduleTaunt(distanceWhenDied)
    if tauntScheduled then return end
    
    -- Only taunt if we were within range when target died
    if distanceWhenDied and distanceWhenDied > CONFIG.TAUNT_RANGE then
        return  -- Too far away, don't taunt
    end
    
    tauntScheduled = true
    local delay = CONFIG.TAUNT_MIN_DELAY + math.random() * (CONFIG.TAUNT_MAX_DELAY - CONFIG.TAUNT_MIN_DELAY)
    task.spawn(function()
        task.wait(delay)
        if targetWasDead and not hasSentTaunt then
            -- Pause movement while taunting (0.5-0.8s)
            tauntPauseActive = true
            stopAllMovementKeys()
            
            sendRandomTaunt()
            hasSentTaunt = true
            
            -- Random pause duration
            local pauseDuration = 0.5 + math.random() * 0.3  -- 0.5 to 0.8
            task.wait(pauseDuration)
            tauntPauseActive = false
        end
        tauntScheduled = false
    end)
end

-- =====================================================
-- FLIGHT CONTROL
-- =====================================================

local function hasFlight()
    local chars = workspace:FindFirstChild("Characters")
    if not chars then return false end
    local myChar = chars:FindFirstChild(player.Name)
    if not myChar then return false end
    local root = myChar:FindFirstChild("HumanoidRootPart")
    return root and root:FindFirstChild("TelekinesisFlight") ~= nil
end

local lastFlightToggle = 0

local function toggleFlight()
    local now = tick()
    if now - lastFlightToggle < CONFIG.FLIGHT_TOGGLE_COOLDOWN then return end
    lastFlightToggle = now
    task.spawn(function()
        pcall(function()
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game)
            task.wait(0.05)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, game)
        end)
    end)
end

local function manageFlightStamina()
    local stamina = getStamina()
    if not stamina then return end
    local effectiveMin = getEffectiveStaminaMin()
    local effectiveRecharge = getEffectiveStaminaRecharge()
    local currentlyFlying = hasFlight()
    if stamina <= effectiveMin and currentlyFlying then
        toggleFlight()
        flightDisabledForStamina = true
    elseif stamina >= effectiveRecharge and flightDisabledForStamina and not currentlyFlying then
        toggleFlight()
        flightDisabledForStamina = false
    end
end

local function ensureFlight()
    if flightDisabledForStamina then return false end
    local stamina = getStamina()
    if stamina and stamina <= getEffectiveStaminaMin() then return false end
    if not hasFlight() then toggleFlight() end
    return hasFlight()
end

-- =====================================================
-- MOVEMENT KEY PULSING
-- =====================================================

local activeKeyThreads = {}
local keyHeldState = {}

local function stopAllMovementKeys()
    for keyName, _ in pairs(activeKeyThreads) do
        activeKeyThreads[keyName] = nil
    end
    local movementKeys = {Enum.KeyCode.W, Enum.KeyCode.S, Enum.KeyCode.A, Enum.KeyCode.D, Enum.KeyCode.Space}
    for _, keyCode in ipairs(movementKeys) do
        if keyHeldState[keyCode] then
            pcall(function() VirtualInputManager:SendKeyEvent(false, keyCode, false, game) end)
            keyHeldState[keyCode] = false
        end
    end
end

local function pulseMovementKey(keyCode)
    local keyName = tostring(keyCode)
    if activeKeyThreads[keyName] then return end
    activeKeyThreads[keyName] = true
    task.spawn(function()
        pcall(function()
            VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
            keyHeldState[keyCode] = true
        end)
        local startTime = tick()
        while activeKeyThreads[keyName] and (tick() - startTime) < CONFIG.KEY_PULSE_DURATION do
            task.wait(0.1)
        end
        pcall(function()
            VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
            keyHeldState[keyCode] = false
        end)
        activeKeyThreads[keyName] = nil
    end)
end

local function stopMovementKey(keyCode)
    local keyName = tostring(keyCode)
    activeKeyThreads[keyName] = nil
    if keyHeldState[keyCode] then
        pcall(function() VirtualInputManager:SendKeyEvent(false, keyCode, false, game) end)
        keyHeldState[keyCode] = false
    end
end

local function holdKey(keyCode)
    pcall(function() VirtualInputManager:SendKeyEvent(true, keyCode, false, game) end)
end

local function releaseKey(keyCode)
    pcall(function() VirtualInputManager:SendKeyEvent(false, keyCode, false, game) end)
end

local function doRandomWalk()
    local currentTime = tick()
    if not randomWalkDirection or currentTime - lastRandomWalkTime > (1 + math.random()) then
        lastRandomWalkTime = currentTime
        local angle = math.random() * math.pi * 2
        randomWalkDirection = Vector3.new(math.cos(angle), 0, math.sin(angle))
        if math.random() > 0.5 then
            pcall(function()
                VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Space, false, game)
                task.wait(0.1)
                VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Space, false, game)
            end)
        end
    end
    if randomWalkDirection then
        local myRoot = getRoot(player)
        if myRoot then
            Camera.CFrame = CFrame.lookAt(myRoot.Position, myRoot.Position + randomWalkDirection * 20)
            pulseMovementKey(Enum.KeyCode.W)
        end
    end
end

-- Random jump while walking (to get over hills/obstacles)
local function tryRandomJump()
    local currentTime = tick()
    if currentTime - lastJumpTime < CONFIG.JUMP_INTERVAL then
        return false
    end
    
    -- Only jump if not flying
    if hasFlight() then
        return false
    end
    
    -- Random chance to jump
    if math.random() < CONFIG.JUMP_CHANCE then
        lastJumpTime = currentTime
        pcall(function()
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Space, false, game)
            task.wait(0.1)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Space, false, game)
        end)
        return true
    end
    
    return false
end

-- Combat jump (to throw off enemy aim)
local function tryCombatJump()
    local currentTime = tick()
    if currentTime - lastCombatJumpTime < CONFIG.JUMP_INTERVAL then
        return false
    end
    
    -- Only jump if not flying
    if hasFlight() then
        return false
    end
    
    -- Higher chance during combat
    if math.random() < CONFIG.COMBAT_JUMP_CHANCE then
        lastCombatJumpTime = currentTime
        pcall(function()
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Space, false, game)
            task.wait(0.1)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Space, false, game)
        end)
        return true
    end
    
    return false
end

-- =====================================================
-- CURVE ACCELERATION (Flight Speed Boost)
-- =====================================================
-- Instead of just pressing W, strafe into the curve to accelerate faster
-- Target RIGHT of velocity → W + D (curve right)
-- Target LEFT of velocity → W + A (curve left)

local function getCurveDirection(myPos, targetPos, velocity)
    -- Need minimum velocity to calculate curve
    if velocity.Magnitude < CONFIG.CURVE_MIN_VELOCITY then
        return "STRAIGHT", 0
    end
    
    -- Get direction to target (horizontal)
    local toTarget = targetPos - myPos
    toTarget = Vector3.new(toTarget.X, 0, toTarget.Z)
    
    if toTarget.Magnitude < 1 then
        return "STRAIGHT", 0
    end
    
    -- Get velocity direction (horizontal)
    local velDir = Vector3.new(velocity.X, 0, velocity.Z)
    if velDir.Magnitude < 1 then
        return "STRAIGHT", 0
    end
    
    -- Cross product: velocity × toTarget
    -- Positive Y = target is to the RIGHT of velocity
    -- Negative Y = target is to the LEFT of velocity
    local cross = velDir.Unit:Cross(toTarget.Unit)
    
    if cross.Y > CONFIG.CURVE_THRESHOLD then
        return "RIGHT", cross.Y  -- Target right of velocity → curve right → W + D
    elseif cross.Y < -CONFIG.CURVE_THRESHOLD then
        return "LEFT", cross.Y   -- Target left of velocity → curve left → W + A
    else
        return "STRAIGHT", cross.Y
    end
end

-- Calculate deviation from straight line path to target
local function getPathDeviation(myPos, targetPos, velocity)
    local toTarget = targetPos - myPos
    local distance = toTarget.Magnitude
    
    if distance < 10 then
        return 0, 0  -- Too close, no deviation calc needed
    end
    
    -- Project velocity onto toTarget to get "on-path" component
    local toTargetUnit = toTarget.Unit
    local velOnPath = velocity:Dot(toTargetUnit)
    
    -- Get perpendicular component (deviation)
    local velPerp = velocity - (toTargetUnit * velOnPath)
    local deviation = velPerp.Magnitude
    
    -- Max allowed deviation scales with distance
    local maxDeviation = distance * CONFIG.CURVE_DEVIATION_RATIO
    
    return deviation, maxDeviation
end

-- Pulse W + appropriate strafe for curve acceleration
-- Returns true if curve boost was applied, false if just W
local function pulseCurveAcceleration(myPos, targetPos)
    local myRoot = getRoot(player)
    if not myRoot then
        pulseMovementKey(Enum.KeyCode.W)
        return false
    end
    
    local velocity = myRoot.Velocity
    local curveDir, crossY = getCurveDirection(myPos, targetPos, velocity)
    local deviation, maxDeviation = getPathDeviation(myPos, targetPos, velocity)
    
    -- Always press W
    pulseMovementKey(Enum.KeyCode.W)
    
    -- Check if we're deviating too much
    if deviation > maxDeviation and maxDeviation > 0 then
        -- Drifting too far - strafe OPPOSITE to correct
        if crossY > 0 then
            -- We were curving right, now strafe left to correct
            pulseMovementKey(Enum.KeyCode.A)
            return true, "CORRECT_LEFT"
        elseif crossY < 0 then
            -- We were curving left, now strafe right to correct
            pulseMovementKey(Enum.KeyCode.D)
            return true, "CORRECT_RIGHT"
        end
    end
    
    -- Normal curve boost
    if curveDir == "RIGHT" then
        pulseMovementKey(Enum.KeyCode.D)
        return true, "CURVE_RIGHT"
    elseif curveDir == "LEFT" then
        pulseMovementKey(Enum.KeyCode.A)
        return true, "CURVE_LEFT"
    end
    
    return false, "STRAIGHT"
end

-- Vertical curve acceleration (for ascend/descend)
local function getCurveDirectionVertical(myPos, targetPos, velocity)
    -- Need minimum velocity
    if velocity.Magnitude < CONFIG.CURVE_MIN_VELOCITY then
        return "STRAIGHT", 0
    end
    
    -- For vertical movement, check if target is above/below our velocity direction
    -- Use XY or ZY plane depending on which has more movement
    local toTarget = targetPos - myPos
    
    -- Cross product in vertical plane
    local cross = velocity.Unit:Cross(toTarget.Unit)
    
    -- For vertical curves, we care about the horizontal component of cross
    -- which tells us if we're curving up or down relative to target
    local horizCross = math.sqrt(cross.X * cross.X + cross.Z * cross.Z)
    
    if cross.Y > CONFIG.CURVE_THRESHOLD then
        return "RIGHT", cross.Y
    elseif cross.Y < -CONFIG.CURVE_THRESHOLD then
        return "LEFT", cross.Y
    else
        return "STRAIGHT", cross.Y
    end
end

local function tryResurface()
    local myRoot = getRoot(player)
    if not myRoot then return end
    Camera.CameraType = Enum.CameraType.Scriptable
    Camera.CFrame = CFrame.lookAt(myRoot.Position, myRoot.Position + Vector3.new(0, 20, 0))
    local stamina = getStamina()
    local canFly = hasFlight() or (stamina and stamina >= getEffectiveStaminaMin())
    if canFly and not isUnderwater then
        ensureFlight()
        pulseMovementKey(Enum.KeyCode.W)
    else
        pulseMovementKey(Enum.KeyCode.W)
        pulseMovementKey(Enum.KeyCode.Space)
    end
end

-- =====================================================
-- MOUSE HELPERS
-- =====================================================

local function getScreenCenter()
    local viewportSize = Camera.ViewportSize
    return viewportSize.X / 2, viewportSize.Y / 2
end

local function moveMouseToCenter()
    pcall(function()
        local centerX, centerY = getScreenCenter()
        VirtualInputManager:SendMouseMoveEvent(centerX, centerY, game)
    end)
end

local function sendMouseClick()
    spawn(function()
        pcall(function()
            local centerX, centerY = getScreenCenter()
            VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, true, game, 0)
            wait(0.05)
            VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, false, game, 0)
        end)
    end)
end

-- Click above center = push target FORWARD (away from alt)
local function sendClickAboveCenter()
    local viewportSize = Camera.ViewportSize
    local centerX = viewportSize.X / 2
    local centerY = viewportSize.Y / 2
    local clickY = centerY - CONFIG.CLICK_ABOVE_OFFSET  -- - means UP
    if clickY < 10 then clickY = 10 end
    
    pcall(function()
        VirtualInputManager:SendMouseButtonEvent(centerX, clickY, 0, true, game, 0)
    end)
    task.wait(0.05)
    pcall(function()
        VirtualInputManager:SendMouseButtonEvent(centerX, clickY, 0, false, game, 0)
    end)
end

-- Click below center = pull target BACKWARD (toward alt)
local function sendClickBelowCenter()
    local viewportSize = Camera.ViewportSize
    local centerX = viewportSize.X / 2
    local centerY = viewportSize.Y / 2
    local clickY = centerY + CONFIG.CLICK_BELOW_OFFSET  -- + means DOWN
    if clickY > viewportSize.Y - 10 then clickY = viewportSize.Y - 10 end
    
    pcall(function()
        VirtualInputManager:SendMouseButtonEvent(centerX, clickY, 0, true, game, 0)
    end)
    task.wait(0.05)
    pcall(function()
        VirtualInputManager:SendMouseButtonEvent(centerX, clickY, 0, false, game, 0)
    end)
end

-- =====================================================
-- STUCK DETECTION
-- =====================================================

local function isVelocityStuck(velocity)
    -- Only check horizontal velocity (X and Z)
    -- Jumping changes Y velocity but doesn't mean we're unstuck horizontally
    return math.abs(velocity.X) < CONFIG.STUCK_VELOCITY_THRESHOLD 
       and math.abs(velocity.Z) < CONFIG.STUCK_VELOCITY_THRESHOLD
end

local function scanForAlternativePath(myPos, targetPos)
    local toTarget = (targetPos - myPos).Unit
    local numPoints = CONFIG.UNSTUCK_SPHERE_POINTS
    local goldenRatio = (1 + math.sqrt(5)) / 2
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {
        workspace:FindFirstChild("Characters"),
        player.Character,
        targetPlayer and targetPlayer.Character
    }
    
    local bestDirection = nil
    local bestScore = -math.huge
    
    for i = 0, numPoints - 1 do
        local theta = 2 * math.pi * i / goldenRatio
        local phi = math.acos(1 - 2 * (i + 0.5) / numPoints)
        local x = math.sin(phi) * math.cos(theta)
        local y = math.cos(phi)
        local z = math.sin(phi) * math.sin(theta)
        local dir = Vector3.new(x, y, z)
        
        local result = workspace:Raycast(myPos, dir * CONFIG.UNSTUCK_SCAN_DISTANCE, raycastParams)
        local clearDistance = result and (result.Position - myPos).Magnitude or CONFIG.UNSTUCK_SCAN_DISTANCE
        local dotToTarget = dir:Dot(toTarget)
        local score = clearDistance + (dotToTarget * 15)
        if dir.Y > 0.3 then score = score + 20 end
        if dotToTarget < -0.8 then score = score - 10 end
        if clearDistance > 15 and score > bestScore then
            bestScore = score
            bestDirection = dir
        end
    end
    
    return bestDirection or Vector3.new(0, 1, 0)
end

local function startUnsticking(myPos, targetPos)
    isUnsticking = true
    unstickDirection = scanForAlternativePath(myPos, targetPos)
    unstickEndTime = tick() + CONFIG.UNSTUCK_DURATION
    stopAllMovementKeys()
end

local function updateStuckDetection(myPos, deltaTime)
    local currentTime = tick()
    if lastPosition and lastPositionTime > 0 then
        local timeDelta = currentTime - lastPositionTime
        if timeDelta > 1 then
            stuckTimer = 0
            lastPosition = myPos
            lastPositionTime = currentTime
            return 0
        end
        if timeDelta > 0 then
            local velocity = (myPos - lastPosition) / timeDelta
            if isVelocityStuck(velocity) then
                stuckTimer = stuckTimer + deltaTime
            else
                stuckTimer = 0
            end
        end
    end
    lastPosition = myPos
    lastPositionTime = currentTime
    return stuckTimer
end

local function resetStuckDetection()
    stuckTimer = 0
    lastPosition = nil
    lastPositionTime = 0
    isUnsticking = false
    unstickDirection = nil
    unstickEndTime = 0
end

-- =====================================================
-- LINE OF SIGHT
-- =====================================================

-- Get raycast filter list (characters + trees + earth)
local function getRaycastFilter()
    local filterList = {
        workspace:FindFirstChild("Characters"),
        player.Character,
        targetPlayer and targetPlayer.Character
    }
    
    -- Add trees to ignore
    local trunks = workspace:FindFirstChild("World") and workspace.World:FindFirstChild("Trunks")
    if trunks then
        for _, tree in ipairs(trunks:GetChildren()) do
            table.insert(filterList, tree)
        end
    end
    
    -- Add earth objects to ignore
    local earth = workspace:FindFirstChild("World") and workspace.World:FindFirstChild("Earth")
    if earth then
        for _, earthPart in ipairs(earth:GetChildren()) do
            table.insert(filterList, earthPart)
        end
    end
    
    return filterList
end

-- Check if target is inside a Flyro Shield (dome)
local function isInFlyroShield(targetPos)
    -- Raycast upward from target to check for dome shield
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Whitelist
    
    local shieldParts = workspace:FindFirstChild("World") and workspace.World:FindFirstChild("ShieldParts")
    if not shieldParts then return false end
    
    raycastParams.FilterDescendantsInstances = {shieldParts}
    
    local result = workspace:Raycast(targetPos, Vector3.new(0, 50, 0), raycastParams)
    if result and result.Instance then
        local parent = result.Instance.Parent
        if parent and parent:FindFirstChild("Forceshield") then
            return true  -- Inside flyro dome shield
        end
    end
    
    return false
end

-- Check if blocked by Telek Shield (disk)
-- Returns: "FLYRO" (don't grab), "TELEK" (20% chance), or nil (no shield)
local function checkShieldBlocking(fromPos, toPos)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Whitelist
    
    local shieldParts = workspace:FindFirstChild("World") and workspace.World:FindFirstChild("ShieldParts")
    if not shieldParts then return nil end
    
    raycastParams.FilterDescendantsInstances = {shieldParts}
    
    local result = workspace:Raycast(fromPos, toPos - fromPos, raycastParams)
    if result and result.Instance then
        local parent = result.Instance.Parent
        if parent then
            if parent:FindFirstChild("Forceshield") then
                return "FLYRO"  -- Dome shield - never grab
            elseif parent:FindFirstChild("Telekinesis") then
                return "TELEK"  -- Disk shield - 20% chance
            end
        end
    end
    
    return nil
end

-- Check if can grab target (shield logic)
local function canGrabTarget(myPos, targetPos)
    -- First check if target is in flyro dome
    if isInFlyroShield(targetPos) then
        telekBlockStartTime = 0  -- Reset telek tracking
        return false, "FLYRO_DOME"
    end
    
    -- Check if shield is blocking
    local shieldType = checkShieldBlocking(myPos, targetPos)
    if shieldType == "FLYRO" then
        telekBlockStartTime = 0  -- Reset telek tracking
        return false, "FLYRO_BLOCKED"
    elseif shieldType == "TELEK" then
        local currentTime = tick()
        
        -- Start tracking if not already
        if telekBlockStartTime == 0 then
            telekBlockStartTime = currentTime
            lastTelekRollTime = currentTime
        end
        
        -- Roll 20% chance each second while blocked
        if currentTime - lastTelekRollTime >= 1.0 then
            lastTelekRollTime = currentTime
            if math.random() < CONFIG.TELEK_GRAB_CHANCE then
                telekBlockStartTime = 0  -- Reset on success
                return true, "TELEK_THROUGH"
            end
        end
        
        return false, "TELEK_BLOCKED"
    end
    
    -- Not blocked - reset telek tracking
    telekBlockStartTime = 0
    return true, "CLEAR"
end

local function hasLineOfSight(fromPos, toPos)
    if not fromPos or not toPos then return false end
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = getRaycastFilter()
    local result = workspace:Raycast(fromPos, toPos - fromPos, raycastParams)
    if not result then return true end
    return (result.Position - toPos).Magnitude < 5
end

local function hasCompleteLineOfSight(myRoot, targetRoot)
    if not myRoot or not targetRoot then return false end
    local myPos = myRoot.Position
    local targetPos = targetRoot.Position
    local direction = (targetPos - myPos).Unit
    local distance = (targetPos - myPos).Magnitude
    
    local upVector = Vector3.new(0, 1, 0)
    local rightVector = direction:Cross(upVector)
    if rightVector.Magnitude < 0.1 then rightVector = direction:Cross(Vector3.new(1, 0, 0)) end
    rightVector = rightVector.Unit
    local upPerpVector = rightVector:Cross(direction).Unit
    
    local spreadRadius = 3
    local coneRays = {targetPos}
    local numRingRays = CONFIG.LINE_OF_SIGHT_CHECKS - 1
    for i = 1, numRingRays do
        local angle = (i / numRingRays) * math.pi * 2
        local offset = rightVector * math.cos(angle) * spreadRadius + upPerpVector * math.sin(angle) * spreadRadius
        table.insert(coneRays, targetPos + offset)
    end
    
    local visibleRays = 0
    for _, endPoint in ipairs(coneRays) do
        if hasLineOfSight(myPos, endPoint) then visibleRays = visibleRays + 1 end
    end
    return visibleRays >= math.ceil(#coneRays * 0.5)
end

-- Check if target is blocked by terrain below alt (for retreat logic)
local function isTargetBlockedByTerrainBelow(myPos, targetPos)
    -- Only check if target is below us
    if targetPos.Y >= myPos.Y then return false end
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = getRaycastFilter()
    
    local result = workspace:Raycast(myPos, targetPos - myPos, raycastParams)
    if result then
        -- Check if it's terrain blocking
        local hitPart = result.Instance
        if hitPart and (hitPart:IsDescendantOf(workspace.Terrain) or hitPart.Name == "Terrain" or hitPart.Anchored) then
            return true
        end
    end
    
    return false
end

-- =====================================================
-- VISUAL INDICATORS
-- =====================================================

local function createTargetIndicator()
    if targetIndicator then targetIndicator:Destroy(); targetIndicator = nil end
    if targetBillboard then targetBillboard:Destroy(); targetBillboard = nil end
    if not targetPlayer then return end
    
    local targetChar = getChar(targetPlayer)
    local targetRoot = getRoot(targetPlayer)
    if not targetChar or not targetRoot then return end
    
    local selectionBox = Instance.new("SelectionBox")
    selectionBox.Name = "TargetIndicator"
    selectionBox.Adornee = targetChar
    selectionBox.Color3 = Color3.fromRGB(255, 0, 0)
    selectionBox.LineThickness = 0.1
    selectionBox.Transparency = 0.3
    selectionBox.Parent = targetChar
    targetIndicator = selectionBox
    
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "TargetBillboard"
    billboard.Adornee = targetRoot
    billboard.Size = UDim2.new(0, 200, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 5, 0)
    billboard.AlwaysOnTop = true
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 1, 0)
    frame.BackgroundTransparency = 0.5
    frame.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    frame.BorderSizePixel = 0
    frame.Parent = billboard
    
    local text = Instance.new("TextLabel")
    text.Size = UDim2.new(1, 0, 1, 0)
    text.BackgroundTransparency = 1
    text.Text = "🎯 TARGET"
    text.TextColor3 = Color3.fromRGB(255, 255, 255)
    text.TextScaled = true
    text.Font = Enum.Font.SourceSansBold
    text.Parent = frame
    
    billboard.Parent = targetRoot
    targetBillboard = billboard
end

local function updateTargetIndicator(status)
    if not targetBillboard then return end
    local frame = targetBillboard:FindFirstChild("Frame")
    if not frame then return end
    local text = frame:FindFirstChild("TextLabel")
    if not text then return end
    
    local statusConfig = {
        attacking = {Color3.fromRGB(0, 255, 0), "⚔️ ATTACKING"},
        invisible = {Color3.fromRGB(128, 0, 255), "👻 INVISIBLE"},
        dead = {Color3.fromRGB(128, 128, 128), "💀 DEAD"},
        blocked = {Color3.fromRGB(255, 128, 0), "🚫 BLOCKED"},
        normal = {Color3.fromRGB(255, 0, 0), "🎯 TARGET"}
    }
    local config = statusConfig[status] or statusConfig.normal
    frame.BackgroundColor3 = config[1]
    text.Text = config[2]
    if targetIndicator then targetIndicator.Color3 = config[1] end
end

local function removeTargetIndicator()
    if targetIndicator then targetIndicator:Destroy(); targetIndicator = nil end
    if targetBillboard then targetBillboard:Destroy(); targetBillboard = nil end
end

-- =====================================================
-- DEBUG GUI
-- =====================================================

local function createDebugGui()
    local playerGui = player:WaitForChild("PlayerGui")
    if debugGui then debugGui:Destroy() end
    
    debugGui = Instance.new("ScreenGui")
    debugGui.Name = "AltFollowDebug"
    debugGui.ResetOnSpawn = false
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 400, 0, 320)
    frame.Position = UDim2.new(0, 10, 0, 10)
    frame.BackgroundColor3 = Color3.new(0, 0, 0)
    frame.BackgroundTransparency = 0.3
    frame.BorderSizePixel = 2
    frame.BorderColor3 = Color3.new(0, 1, 1)
    frame.Parent = debugGui
    
    local textLabel = Instance.new("TextLabel")
    textLabel.Name = "DebugText"
    textLabel.Size = UDim2.new(1, -10, 1, -10)
    textLabel.Position = UDim2.new(0, 5, 0, 5)
    textLabel.BackgroundTransparency = 1
    textLabel.TextColor3 = Color3.new(1, 1, 1)
    textLabel.TextXAlignment = Enum.TextXAlignment.Left
    textLabel.TextYAlignment = Enum.TextYAlignment.Top
    textLabel.TextSize = 12
    textLabel.Font = Enum.Font.Code
    textLabel.Text = "Debug Info"
    textLabel.Parent = frame
    
    debugGui.Parent = playerGui
end

local function updateDebug(info)
    if debugGui then
        local textLabel = debugGui:FindFirstChild("DebugText", true)
        if textLabel then textLabel.Text = info end
    end
end

-- =====================================================
-- SPECTATE CONTROL
-- =====================================================

local function startSpectating()
    if spectating then return end
    if not canEnterCombatMode() then return end
    spectating = true
    Camera.CameraType = Enum.CameraType.Scriptable
    UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
end

local function stopSpectating()
    if not spectating then return end
    spectating = false
    Camera.CameraType = Enum.CameraType.Custom
    local hum = getHumanoid(player)
    if hum then Camera.CameraSubject = hum end
    UserInputService.MouseBehavior = Enum.MouseBehavior.Default
end

local function updateSpectateCamera()
    if not spectating or not targetPlayer then return end
    local targetRoot = getRoot(targetPlayer)
    if targetRoot then
        local targetPos = targetRoot.Position
        Camera.CFrame = CFrame.lookAt(targetPos + Vector3.new(0, 5, 10), targetPos)
    end
end

local function moveWhileSpectating(moveToward)
    local myRoot = getRoot(player)
    local targetRoot = getRoot(targetPlayer)
    if not myRoot or not targetRoot then return end
    
    local myPos = myRoot.Position
    local targetPos = targetRoot.Position
    local camCFrame = Camera.CFrame
    
    local altInCamSpace = camCFrame:PointToObjectSpace(myPos)
    local targetInCamSpace = camCFrame:PointToObjectSpace(targetPos)
    local dirInCamSpace = (targetInCamSpace - altInCamSpace).Unit
    if not moveToward then dirInCamSpace = -dirInCamSpace end
    
    stopAllMovementKeys()
    if dirInCamSpace.Z < -0.2 then pulseMovementKey(Enum.KeyCode.W) end
    if dirInCamSpace.Z > 0.2 then pulseMovementKey(Enum.KeyCode.S) end
    if dirInCamSpace.X < -0.2 then pulseMovementKey(Enum.KeyCode.A) end
    if dirInCamSpace.X > 0.2 then pulseMovementKey(Enum.KeyCode.D) end
end

local cameraUpdateConnection = nil

local function startCameraUpdate()
    if cameraUpdateConnection then return end
    cameraUpdateConnection = RunService.RenderStepped:Connect(function()
        if spectating and targetPlayer and not altIsDead then
            updateSpectateCamera()
        end
    end)
end

local function stopCameraUpdate()
    if cameraUpdateConnection then
        cameraUpdateConnection:Disconnect()
        cameraUpdateConnection = nil
    end
end

-- =====================================================
-- SMOOTH VERTICAL FLIGHT LOGIC (NEW)
-- =====================================================

-- Determine if we should continue current vertical direction (ignore small changes)
local function shouldContinueVerticalDirection(currentYDiff)
    local now = tick()
    
    -- If height difference is very small, likely jumping/maneuvering - continue current direction
    if math.abs(currentYDiff) < CONFIG.SMALL_HEIGHT_CHANGE then
        if now - verticalDirectionStartTime < CONFIG.VERTICAL_DIRECTION_HOLD_TIME then
            return lastVerticalDirection
        end
    end
    
    -- Determine new direction
    local newDirection = 0
    if currentYDiff > CONFIG.SMALL_HEIGHT_CHANGE then
        newDirection = 1  -- Need to go UP
    elseif currentYDiff < -CONFIG.SMALL_HEIGHT_CHANGE then
        newDirection = -1  -- Need to go DOWN
    end
    
    -- If direction changed, reset timer
    if newDirection ~= lastVerticalDirection then
        lastVerticalDirection = newDirection
        verticalDirectionStartTime = now
    end
    
    return newDirection
end

-- Calculate angled flight direction (not pure horizontal, slight vertical angle)
local function getAngledFlightDirection(myPos, targetPos)
    local fullVector = targetPos - myPos
    local horizontalDir = Vector3.new(fullVector.X, 0, fullVector.Z)
    local horizontalDist = horizontalDir.Magnitude
    local verticalDiff = targetPos.Y - myPos.Y  -- Positive = target above
    local absVerticalDiff = math.abs(verticalDiff)
    
    -- Ensure we have a valid horizontal direction (fallback if directly above/below)
    if horizontalDist < 1 then
        horizontalDir = Vector3.new(1, 0, 0)
        horizontalDist = 1
    end
    local horizontalUnit = horizontalDir.Unit
    
    -- Use vertical direction persistence (ignore target jumping)
    local persistedDirection = shouldContinueVerticalDirection(verticalDiff)
    
    -- If target is jumping/small movement AND we have a persisted direction, use it
    if absVerticalDiff < CONFIG.SMALL_HEIGHT_CHANGE and persistedDirection ~= 0 then
        -- Continue previous vertical direction with angled flight
        local verticalRatio = persistedDirection * CONFIG.ANGLED_FLIGHT_RATIO
        if persistedDirection < 0 and isTerrainBelow() then
            verticalRatio = 0
        end
        local angledDirection = (horizontalUnit + Vector3.new(0, verticalRatio, 0)).Unit
        return angledDirection, "ANGLED_PERSIST"
    end
    
    -- If vertical diff is small and no persisted direction, fly horizontal
    if absVerticalDiff < CONFIG.SMALL_HEIGHT_CHANGE then
        return horizontalUnit, "HORIZONTAL"
    end
    
    -- If vertical separation exceeds max (80 studs), prioritize vertical movement
    if absVerticalDiff > CONFIG.MAX_VERTICAL_SEPARATION then
        if verticalDiff > 0 then
            return (horizontalUnit * 0.4 + Vector3.new(0, 0.9, 0)).Unit, "STEEP_UP"
        else
            if isTerrainBelow() then
                return horizontalUnit, "TERRAIN_BLOCK"
            end
            return (horizontalUnit * 0.4 + Vector3.new(0, -0.9, 0)).Unit, "STEEP_DOWN"
        end
    end
    
    -- If horizontal distance is small (< 100 studs) but vertical > 10, go steep
    if horizontalDist < CONFIG.HORIZONTAL_TOO_SMALL and absVerticalDiff > 10 then
        if verticalDiff > 0 then
            return (horizontalUnit * 0.3 + Vector3.new(0, 0.95, 0)).Unit, "VERTICAL_UP"
        else
            if isTerrainBelow() then
                return horizontalUnit, "TERRAIN_BLOCK"
            end
            return (horizontalUnit * 0.3 + Vector3.new(0, -0.95, 0)).Unit, "VERTICAL_DOWN"
        end
    end
    
    -- Normal case: fly with angle toward target (horizontal >= 100 studs, vertical > 8 studs)
    -- ANGLED_FLIGHT_RATIO of 0.5 means for every 1 unit horizontal, add 0.5 vertical
    -- This creates roughly a 26 degree angle
    local verticalRatio = CONFIG.ANGLED_FLIGHT_RATIO
    if verticalDiff < 0 then
        -- Going down - check terrain
        if isTerrainBelow() then
            verticalRatio = 0
        else
            verticalRatio = -CONFIG.ANGLED_FLIGHT_RATIO
        end
    end
    
    -- Create angled direction: horizontal unit + vertical component
    local angledDirection = (horizontalUnit + Vector3.new(0, verticalRatio, 0)).Unit
    return angledDirection, "ANGLED"
end

-- Smart camera positioning using angled flight
local function pointCameraForMovement(myPos, targetPos)
    local direction, flightType = getAngledFlightDirection(myPos, targetPos)
    local lookTarget = myPos + direction * 50
    
    -- Use CFrame.lookAt with explicit up vector to prevent flipping
    -- When looking down, the default up vector can cause issues
    local upVector = Vector3.new(0, 1, 0)
    
    -- If looking nearly straight down or up, adjust up vector
    if math.abs(direction.Y) > 0.9 then
        upVector = Vector3.new(0, 0, -1)  -- Use Z as up when looking vertically
    end
    
    Camera.CFrame = CFrame.lookAt(myPos, lookTarget, upVector)
    return flightType
end

local function pointCameraAway(myPos, targetPos)
    local yDiff = targetPos.Y - myPos.Y
    local horizontalAway = (myPos - targetPos)
    horizontalAway = Vector3.new(horizontalAway.X, 0, horizontalAway.Z)
    
    -- Ensure valid horizontal direction
    if horizontalAway.Magnitude < 1 then
        horizontalAway = Vector3.new(1, 0, 0)
    end
    local horizontalUnit = horizontalAway.Unit
    
    if math.abs(yDiff) > CONFIG.VERTICAL_THRESHOLD then
        if yDiff > 0 then
            -- Target above, back away by going down (but with horizontal component)
            if isTerrainBelow() then
                Camera.CFrame = CFrame.lookAt(myPos, myPos + horizontalUnit * 50)
                return "TERRAIN_BLOCK_AWAY"
            end
            -- Go down and away - keep horizontal component to prevent flip
            local downAway = (horizontalUnit * 0.3 + Vector3.new(0, -0.95, 0)).Unit
            Camera.CFrame = CFrame.lookAt(myPos, myPos + downAway * 50, Vector3.new(0, 0, -1))
        else
            -- Target below, back away by going up (with horizontal component)
            local upAway = (horizontalUnit * 0.3 + Vector3.new(0, 0.95, 0)).Unit
            Camera.CFrame = CFrame.lookAt(myPos, myPos + upAway * 50, Vector3.new(0, 0, -1))
        end
        return "VERTICAL_AWAY"
    end
    
    -- Horizontal backing away
    Camera.CFrame = CFrame.lookAt(myPos, myPos + horizontalUnit * 50)
    return "HORIZONTAL_AWAY"
end

-- =====================================================
-- COMBAT SYSTEM
-- =====================================================

local lastCanAttackCheck = 0
local lastCanAttackResult = false

local function canAttackNow()
    local now = tick()
    if now - lastCanAttackCheck < 0.2 then return lastCanAttackResult end
    lastCanAttackCheck = now
    
    if now - lastQClickTime < CONFIG.Q_CLICK_COOLDOWN then lastCanAttackResult = false; return false end
    if isAttacking then lastCanAttackResult = false; return false end
    
    local targetPos = getTargetPosition()
    if targetPos and isTargetUnderMap(targetPos) then lastCanAttackResult = false; return false end
    
    -- Sustained attack mode bypasses stamina check (we're being attacked, fight back!)
    if not sustainedAttackMode then
        local stamina = getStamina()
        if not stamina or stamina < getEffectiveStaminaMin() then lastCanAttackResult = false; return false end
    end
    
    -- Removed spectating requirement - can attack from any camera mode
    if targetWasDead or targetWasInvisible then lastCanAttackResult = false; return false end
    
    lastCanAttackResult = true
    return true
end

-- Q has NO minimum range - can attack at any distance up to max
local function isInAttackRange(totalDist)
    return totalDist <= CONFIG.OPTIMAL_MAX
end

-- Comfort range is where we WANT to be, not where we CAN attack
local function isInComfortRange(totalDist)
    return totalDist >= CONFIG.OPTIMAL_MIN and totalDist <= CONFIG.OPTIMAL_MAX
end

-- Sustained attack mode tracking
local sustainedAttackMode = false
local sustainedDamageAccumulated = 0
local lastDamageTime = 0
local SUSTAINED_DAMAGE_MIN = 20        -- Min damage to trigger sustained mode
local SUSTAINED_DAMAGE_MAX = 30        -- Max damage (filters out other sources)
local SUSTAINED_DAMAGE_TIMEOUT = 0.5   -- Exit after 0.5s of no damage

local function checkDamageTaken()
    local currentHealth = getAltHealth()
    local damageTaken = lastKnownHealth - currentHealth
    if currentHealth < lastKnownHealth then
        lastKnownHealth = currentHealth
    elseif currentHealth > lastKnownHealth then
        lastKnownHealth = currentHealth
        return 0
    end
    return damageTaken
end

local function updateSustainedAttackMode()
    local damageTaken = checkDamageTaken()
    local currentTime = tick()
    
    if damageTaken > 0 then
        sustainedDamageAccumulated = sustainedDamageAccumulated + damageTaken
        lastDamageTime = currentTime
        
        -- Enter sustained attack mode if damage is in range (20-30 HP)
        -- This filters out other damage sources (fall damage, etc)
        if sustainedDamageAccumulated >= SUSTAINED_DAMAGE_MIN and sustainedDamageAccumulated <= SUSTAINED_DAMAGE_MAX then
            sustainedAttackMode = true
        end
    end
    
    -- Exit sustained mode after 0.5s of no damage
    if sustainedAttackMode and (currentTime - lastDamageTime) > SUSTAINED_DAMAGE_TIMEOUT then
        sustainedAttackMode = false
        sustainedDamageAccumulated = 0
    end
    
    return sustainedAttackMode
end

local function resetDamageTracking()
    lastKnownHealth = getAltHealth()
    sustainedAttackMode = false
    sustainedDamageAccumulated = 0
    lastDamageTime = 0
end

local function checkEmergencyDefense(myPos, targetPos)
    if not targetPlayer or targetWasDead or targetWasInvisible then return false end
    local damageTaken = checkDamageTaken()
    if damageTaken < damageThreshold then return false end
    local totalDist = (targetPos - myPos).Magnitude
    if not isInAttackRange(totalDist) then return false end
    if tick() - lastQClickTime < CONFIG.Q_CLICK_COOLDOWN then return false end
    if isAttacking then return false end
    local stamina = getStamina()
    if not stamina or stamina < getEffectiveStaminaMin() then return false end
    local myRoot = getRoot(player)
    local targetRoot = getRoot(targetPlayer)
    if not myRoot or not targetRoot then return false end
    if not hasCompleteLineOfSight(myRoot, targetRoot) then return false end
    return true
end

local function performEmergencyDefense(myPos, targetPos, interruptedTask)
    emergencyDefenseActive = true
    preEmergencyTask = interruptedTask
    if not spectating then startSpectating() end
    isAttacking = true
    updateTargetIndicator("attacking")
    
    spawn(function()
        moveMouseToCenter()
        wait(0.03)
        holdKey(Enum.KeyCode.Q)
        wait(0.15)
        sendMouseClick()
        wait(0.2)
        releaseKey(Enum.KeyCode.Q)
        isAttacking = false
        lastQClickTime = tick()
        emergencyDefenseActive = false
        preEmergencyTask = nil
        if currentMode == "ATTACK" and not targetWasInvisible then
            updateTargetIndicator("normal")
        end
    end)
    return true
end

local function performQClickAttack()
    local currentTime = tick()
    if currentTime - lastQClickTime < CONFIG.Q_CLICK_COOLDOWN then return false end
    if isAttacking then return false end
    
    local myRoot = getRoot(player)
    local targetRoot = getRoot(targetPlayer)
    if not myRoot or not targetRoot then return false end
    
    local myPos = myRoot.Position
    local targetPos = targetRoot.Position
    local fullVector = targetPos - myPos
    local horizontalDistance = Vector3.new(fullVector.X, 0, fullVector.Z).Magnitude
    
    if isTargetUnderMap(targetPos) then updateTargetIndicator("blocked"); return false end
    
    -- Shield check
    local canGrab, shieldStatus = canGrabTarget(myPos, targetPos)
    if not canGrab then
        updateTargetIndicator("blocked")
        return false
    end
    
    if cachedTargetInWater then
        local validPos = isValidUnderwaterAttackPosition(myPos, targetPos)
        if not validPos then return false end
    end
    
    local hasLOS = hasCompleteLineOfSight(myRoot, targetRoot)
    if not hasLOS and isInRiverBounds(targetPos) then
        if canGrabRiverTarget(myPos, targetPos) then hasLOS = true end
    end
    if not hasLOS then updateTargetIndicator("blocked"); return false end
    
    -- Determine toss direction based on HORIZONTAL distance
    -- Close to OPTIMAL_MAX → pull back (click below)
    -- Otherwise → push forward (click above) or center
    local pullThreshold = CONFIG.OPTIMAL_MAX - 5  -- Start pulling when within 5 studs of max
    local shouldPull = horizontalDistance >= pullThreshold
    
    isAttacking = true
    updateTargetIndicator("attacking")
    
    spawn(function()
        -- Point camera at target for accurate toss
        Camera.CameraType = Enum.CameraType.Scriptable
        Camera.CFrame = CFrame.lookAt(myPos, targetPos)
        
        wait(0.05)
        holdKey(Enum.KeyCode.Q)
        wait(0.2)
        
        -- Use directional click based on distance
        if shouldPull then
            sendClickBelowCenter()  -- Pull toward us
        else
            sendClickAboveCenter()  -- Push away (keeps in range)
        end
        
        wait(0.3)
        releaseKey(Enum.KeyCode.Q)
        isAttacking = false
        justAttacked = true
        lastQClickTime = tick()
        if currentMode == "ATTACK" and not targetWasInvisible then
            updateTargetIndicator("normal")
        end
    end)
    return true
end

-- =====================================================
-- MAIN MOVEMENT CALCULATION
-- =====================================================

local function calculateMovementAndMode(myPos, targetPos)
    local fullVector = targetPos - myPos
    local horizontalVector = Vector3.new(fullVector.X, 0, fullVector.Z)
    local horizontalDistance = horizontalVector.Magnitude
    local verticalDiff = fullVector.Y
    local totalDistance = fullVector.Magnitude
    
    local newMode = currentMode
    if flightDisabledForStamina then
        newMode = "STAMINA_REGEN"
    elseif totalDistance > CONFIG.COMBAT_ZONE then
        newMode = "TRAVEL"
    elseif totalDistance > CONFIG.OPTIMAL_MAX then
        newMode = "APPROACH"
    elseif isInComfortRange(totalDistance) then
        newMode = "ATTACK"
    else
        -- Too close but can still attack (Q has no min range)
        newMode = "TOO_CLOSE"
    end
    
    return newMode, horizontalDistance, verticalDiff, horizontalVector, totalDistance
end

-- =====================================================
-- MAIN FOLLOW LOOP
-- =====================================================

local movementLoop = nil

local function startMovementLoop()
    movementLoop = RunService.Heartbeat:Connect(function(deltaTime)
        if not following or not targetPlayer then return end
        if altIsDead then return end
        
        local myRoot = getRoot(player)
        local targetPos = getTargetPosition()
        if not myRoot or not targetPos then return end
        local myPos = myRoot.Position
        
        -- Tab-out detection
        local currentFrameTime = tick()
        if lastFrameTime > 0 then
            local frameGap = currentFrameTime - lastFrameTime
            if frameGap > 0.5 then
                for keyName in pairs(activeKeyThreads) do activeKeyThreads[keyName] = nil end
                movementPulseTimer = CONFIG.MOVEMENT_PULSE_RATE
            end
        end
        lastFrameTime = currentFrameTime
        
        manageFlightStamina()
        
        -- Update sustained attack mode (20+ HP damage triggers it)
        updateSustainedAttackMode()
        
        -- Underwater detection
        local currentTime = tick()
        if currentTime - lastUnderwaterCheck > 0.25 then
            lastUnderwaterCheck = currentTime
            local wasUnderwater = isUnderwater
            isUnderwater = checkUnderwater()
            cachedTargetInWater = isTargetUnderwater()
            if not isUnderwater and wasUnderwater then
                airRemaining = CONFIG.UNDERWATER_MAX_TIME
                resurfaceStarted = false
            end
        end
        
        if isUnderwater then
            airRemaining = airRemaining - deltaTime
        else
            airRemaining = CONFIG.UNDERWATER_MAX_TIME
            resurfaceStarted = false
        end
        
        if spectating and not canEnterCombatMode() then stopSpectating() end
        
        -- Forced resurface
        if isUnderwater and airRemaining <= 0 then
            if not resurfaceStarted then
                resurfaceStarted = true
                resetDamageTracking()
            end
            if checkEmergencyDefense(myPos, targetPos) then
                performEmergencyDefense(myPos, targetPos, "RESURFACE")
            else
                if spectating then stopSpectating() end
            end
            if not isAttacking then tryResurface() end
            movementPulseTimer = movementPulseTimer + deltaTime
            return
        end
        
        -- Target underwater handling (river)
        if cachedTargetInWater and not targetWasDead then
            -- Check if target is in river zone and needs dive approach
            if shouldDiveForRiverTarget(myPos, targetPos) then
                -- Alt is above water, target is below - need to dive down first
                if spectating then stopSpectating() end
                ensureFlight()
                Camera.CameraType = Enum.CameraType.Scriptable
                
                -- Get dive entry point (above target's position at surface level)
                local divePoint = getRiverDivePoint(myPos, targetPos)
                local horizDistToDive = (Vector3.new(divePoint.X, myPos.Y, divePoint.Z) - myPos).Magnitude
                
                if horizDistToDive > 20 then
                    -- Fly horizontally toward dive point first
                    Camera.CFrame = CFrame.lookAt(myPos, divePoint)
                    if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                        movementPulseTimer = 0
                        pulseCurveAcceleration(myPos, divePoint)
                    end
                else
                    -- Close enough horizontally - dive straight down
                    Camera.CFrame = CFrame.lookAt(myPos, myPos + Vector3.new(0, -20, 0), Vector3.new(0, 0, -1))
                    if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                        movementPulseTimer = 0
                        pulseMovementKey(Enum.KeyCode.W)
                    end
                end
                movementPulseTimer = movementPulseTimer + deltaTime
                return
            elseif not isUnderwater then
                -- Target in water but alt not yet underwater (generic case)
                if spectating then stopSpectating() end
                ensureFlight()
                Camera.CameraType = Enum.CameraType.Scriptable
                Camera.CFrame = CFrame.lookAt(myPos, targetPos)
                if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                    movementPulseTimer = 0
                    pulseCurveAcceleration(myPos, targetPos)
                end
                movementPulseTimer = movementPulseTimer + deltaTime
                return
            else
                -- Alt is underwater - reposition if needed, then attack
                -- For river targets, alt must stay underwater to grab
                if isTargetInRiverZone(targetPos) and targetPos.Y <= CONFIG.RIVER_SURFACE_Y then
                    -- Target is underwater in river - alt must be too
                    local validPos = isValidUnderwaterAttackPosition(myPos, targetPos)
                    if not validPos then
                        if spectating then stopSpectating() end
                        local repoDir = getUnderwaterRepositionDirection(myPos, targetPos)
                        Camera.CameraType = Enum.CameraType.Scriptable
                        Camera.CFrame = CFrame.lookAt(myPos, myPos + repoDir * 20)
                        if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                            movementPulseTimer = 0
                            pulseMovementKey(Enum.KeyCode.W)
                        end
                        movementPulseTimer = movementPulseTimer + deltaTime
                    end
                else
                    -- Generic underwater positioning
                    local validPos = isValidUnderwaterAttackPosition(myPos, targetPos)
                    if not validPos then
                        if spectating then stopSpectating() end
                        local repoDir = getUnderwaterRepositionDirection(myPos, targetPos)
                        Camera.CameraType = Enum.CameraType.Scriptable
                        Camera.CFrame = CFrame.lookAt(myPos, myPos + repoDir * 20)
                        if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                            movementPulseTimer = 0
                            pulseMovementKey(Enum.KeyCode.W)
                        end
                        movementPulseTimer = movementPulseTimer + deltaTime
                    end
                end
            end
        end
        
        -- Target status check
        if currentTime - lastTargetCheck > CONFIG.TARGET_CHECK_RATE then
            lastTargetCheck = currentTime
            local alive = isTargetAlive()
            local invisible = isTargetInvisible()
            
            if not alive and not targetWasDead then
                targetWasDead = true
                stopSpectating()
                updateTargetIndicator("dead")
                hasSentTaunt = false
                tauntPauseActive = false
                -- Save body position for walking away
                lastBodyPosition = targetPos
                -- Pass current distance to scheduleTaunt
                local deathDistance = targetPos and (targetPos - myPos).Magnitude or 999
                scheduleTaunt(deathDistance)
            elseif alive and targetWasDead then
                targetWasDead = false
                stoppedFlightForDeath = false
                hasSentTaunt = false
                tauntScheduled = false
                tauntPauseActive = false
                lastBodyPosition = nil
                createTargetIndicator()
            end
            
            if invisible and not targetWasInvisible then
                targetWasInvisible = true
                updateTargetIndicator("invisible")
            elseif not invisible and targetWasInvisible then
                targetWasInvisible = false
                updateTargetIndicator("normal")
            end
        end
        
        -- Under map
        if isTargetUnderMap(targetPos) then
            currentMode = "WAITING"
            if spectating then stopSpectating() end
            doRandomWalk()
            return
        end
        
        -- Dead - walk away from body, then switch to next target
        if targetWasDead then
            currentMode = "WAITING"
            if not stoppedFlightForDeath and hasFlight() then
                toggleFlight()
                stoppedFlightForDeath = true
            end
            
            -- Pause movement while taunting
            if tauntPauseActive then
                movementPulseTimer = movementPulseTimer + deltaTime
                return
            end
            
            -- Calculate distance from body
            local distFromBody = lastBodyPosition and (myPos - lastBodyPosition).Magnitude or 0
            local walkedAwayEnough = distFromBody > 30
            
            -- After taunt sent (or no taunt scheduled), try switching to next target
            if walkedAwayEnough and (hasSentTaunt or not tauntScheduled) then
                if switchToNextTarget() then
                    -- Successfully switched to next target
                    ensureFlight()
                    return
                end
                -- No alive targets - fall through to random walk
            end
            
            if isUnderwater and airRemaining <= 0 then
                tryResurface()
            elseif not walkedAwayEnough and lastBodyPosition then
                -- Still need to walk away from body
                local awayFromBody = myPos - lastBodyPosition
                if awayFromBody.Magnitude > 0.1 then
                    awayFromBody = Vector3.new(awayFromBody.X, 0, awayFromBody.Z).Unit
                else
                    awayFromBody = Vector3.new(1, 0, 0)
                end
                
                Camera.CameraType = Enum.CameraType.Scriptable
                Camera.CFrame = CFrame.lookAt(myPos, myPos + awayFromBody * 20)
                
                if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                    movementPulseTimer = 0
                    pulseMovementKey(Enum.KeyCode.W)
                end
            else
                -- Walked away and no alive targets - random walk while waiting
                doRandomWalk()
            end
            movementPulseTimer = movementPulseTimer + deltaTime
            return
        end
        
        -- Invisible - retreat to 300 studs, stay within 100 stud range
        if targetWasInvisible then
            currentMode = "RETREAT"
            if spectating then stopSpectating() end
            ensureFlight()
            Camera.CameraType = Enum.CameraType.Scriptable
            
            local distToTarget = (targetPos - myPos).Magnitude
            local awayDir = (myPos - targetPos)
            if awayDir.Magnitude > 0.1 then awayDir = awayDir.Unit else awayDir = Vector3.new(1, 0, 0) end
            
            -- Calculate retreat zone (300 studs away, +/- 100)
            local minRetreat = CONFIG.INVISIBILITY_RETREAT_DIST - CONFIG.INVISIBILITY_STAY_RANGE  -- 200
            local maxRetreat = CONFIG.INVISIBILITY_RETREAT_DIST + CONFIG.INVISIBILITY_STAY_RANGE  -- 400
            
            if distToTarget < minRetreat then
                -- Too close - fly away
                Camera.CFrame = CFrame.lookAt(myPos, myPos + awayDir * 50)
                if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                    movementPulseTimer = 0
                    pulseMovementKey(Enum.KeyCode.W)
                end
            elseif distToTarget > maxRetreat then
                -- Too far - fly toward (but not too close)
                Camera.CFrame = CFrame.lookAt(myPos, targetPos)
                if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                    movementPulseTimer = 0
                    pulseMovementKey(Enum.KeyCode.W)
                end
            else
                -- In range - hover/orbit
                local orbitDir = awayDir:Cross(Vector3.new(0, 1, 0)).Unit
                Camera.CFrame = CFrame.lookAt(myPos, myPos + orbitDir * 50)
            end
            
            movementPulseTimer = movementPulseTimer + deltaTime
            return
        end
        
        -- Check if target is blocked by terrain below (retreat similar to invisible)
        if isTargetBlockedByTerrainBelow(myPos, targetPos) then
            currentMode = "RETREAT"
            if spectating then stopSpectating() end
            ensureFlight()
            Camera.CameraType = Enum.CameraType.Scriptable
            
            local distToTarget = (targetPos - myPos).Magnitude
            local awayDir = (myPos - targetPos)
            if awayDir.Magnitude > 0.1 then awayDir = awayDir.Unit else awayDir = Vector3.new(1, 0, 0) end
            
            -- Retreat 100 studs, stay within 100 stud range
            local minRetreat = CONFIG.TERRAIN_BLOCK_RETREAT_DIST
            local maxRetreat = CONFIG.TERRAIN_BLOCK_RETREAT_DIST * 2
            
            if distToTarget < minRetreat then
                Camera.CFrame = CFrame.lookAt(myPos, myPos + awayDir * 50)
                if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                    movementPulseTimer = 0
                    pulseMovementKey(Enum.KeyCode.W)
                end
            elseif distToTarget > maxRetreat then
                Camera.CFrame = CFrame.lookAt(myPos, targetPos)
                if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                    movementPulseTimer = 0
                    pulseMovementKey(Enum.KeyCode.W)
                end
            end
            
            movementPulseTimer = movementPulseTimer + deltaTime
            return
        end
        
        local newMode, hDist, vDiff, hVector, totalDist = calculateMovementAndMode(myPos, targetPos)
        
        -- Stuck detection
        local currentStuckTime = updateStuckDetection(myPos, deltaTime)
        if not isUnsticking and currentStuckTime >= CONFIG.STUCK_TIME_THRESHOLD then
            startUnsticking(myPos, targetPos)
        end
        if isUnsticking and tick() >= unstickEndTime then
            isUnsticking = false
            unstickDirection = nil
            stuckTimer = 0
        end
        
        -- Attack priority (always attack in range, or if sustained attack mode active)
        local attackPriorityTriggered = false
        local shouldAttack = isInAttackRange(totalDist) and canAttackNow()
        
        -- Sustained attack mode - attack even more aggressively
        if sustainedAttackMode and canAttackNow() and totalDist <= CONFIG.COMBAT_ZONE then
            shouldAttack = true
        end
        
        if shouldAttack then
            attackPriorityTriggered = true
            performQClickAttack()
        end
        
        -- Unstick mode
        if isUnsticking and unstickDirection and not attackPriorityTriggered then
            if spectating then stopSpectating() end
            ensureFlight()
            Camera.CameraType = Enum.CameraType.Scriptable
            Camera.CFrame = CFrame.lookAt(myPos, myPos + unstickDirection * 50)
            if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                movementPulseTimer = 0
                pulseMovementKey(Enum.KeyCode.W)
            end
            movementPulseTimer = movementPulseTimer + deltaTime
            return
        end
        
        -- Mode transitions
        if newMode ~= currentMode then
            stopAllMovementKeys()
            movementPulseTimer = CONFIG.MOVEMENT_PULSE_RATE
            currentMode = newMode
        end
        
        -- Force spectate in combat zone
        if totalDist <= CONFIG.COMBAT_ZONE and not spectating then
            startSpectating()
        elseif totalDist > CONFIG.COMBAT_ZONE and spectating then
            stopSpectating()
        end
        
        movementPulseTimer = movementPulseTimer + deltaTime
        local flightMode = "HORIZONTAL"
        
        -- Execute mode behavior
        if currentMode == "STAMINA_REGEN" then
            local stamina = getStamina() or 0
            local effectiveMin = getEffectiveStaminaMin()
            
            -- Stamina too low to attack - back away from target
            if stamina < effectiveMin then
                -- Exit spectating for camera control
                if spectating then stopSpectating() end
                
                Camera.CameraType = Enum.CameraType.Scriptable
                -- Point camera away from target
                local awayDir = (myPos - targetPos)
                awayDir = Vector3.new(awayDir.X, 0, awayDir.Z)  -- Horizontal only
                if awayDir.Magnitude < 1 then awayDir = Vector3.new(1, 0, 0) end
                Camera.CFrame = CFrame.lookAt(myPos, myPos + awayDir.Unit * 50)
                
                if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                    movementPulseTimer = 0
                    pulseMovementKey(Enum.KeyCode.W)  -- Walk away
                    tryRandomJump()  -- Jump to get over obstacles
                end
                flightMode = "RETREAT_LOW_STAM"
            else
                -- Stamina enough to attack - maintain optimal range
                -- Enter spectating when in combat zone for aiming
                if totalDist <= CONFIG.COMBAT_ZONE and not spectating then
                    startSpectating()
                elseif totalDist > CONFIG.COMBAT_ZONE and spectating then
                    stopSpectating()
                end
                
                if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                    movementPulseTimer = 0
                    
                    if totalDist > CONFIG.OPTIMAL_MAX then
                        -- Too far - walk toward target
                        if spectating then
                            moveWhileSpectating(true)
                        else
                            Camera.CameraType = Enum.CameraType.Scriptable
                            local towardDir = Vector3.new(hVector.X, 0, hVector.Z).Unit
                            Camera.CFrame = CFrame.lookAt(myPos, myPos + towardDir * 50)
                            pulseMovementKey(Enum.KeyCode.W)
                        end
                        tryRandomJump()  -- Jump to get over hills
                        flightMode = "APPROACH_WALK"
                    elseif totalDist < CONFIG.OPTIMAL_MIN then
                        -- Too close - back away to optimal mid
                        if spectating then
                            moveWhileSpectating(false)
                        else
                            Camera.CameraType = Enum.CameraType.Scriptable
                            local awayDir = Vector3.new(-hVector.X, 0, -hVector.Z).Unit
                            Camera.CFrame = CFrame.lookAt(myPos, myPos + awayDir * 50)
                            pulseMovementKey(Enum.KeyCode.W)
                        end
                        tryCombatJump()  -- Combat jump to throw off aim
                        flightMode = "BACKUP_WALK"
                    elseif totalDist < CONFIG.OPTIMAL_MID then
                        -- In range but below mid - back up a bit
                        if spectating then
                            moveWhileSpectating(false)
                        end
                        tryCombatJump()  -- Combat jump to throw off aim
                        flightMode = "ADJUST_WALK"
                    else
                        -- In optimal range - attack!
                        tryCombatJump()  -- Combat jump to throw off aim
                        if not targetWasInvisible and not isAttacking then
                            performQClickAttack()
                        end
                        flightMode = "ATTACK_WALK"
                    end
                end
            end
            
        elseif currentMode == "TOO_CLOSE" then
            ensureFlight()
            
            -- Still attack while backing away (Q has no min range)
            if canAttackNow() and not targetWasInvisible and not isAttacking then
                performQClickAttack()
            end
            
            -- Back away to comfort range
            if spectating then
                if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                    movementPulseTimer = 0
                    moveWhileSpectating(false)
                end
            else
                Camera.CameraType = Enum.CameraType.Scriptable
                flightMode = pointCameraAway(myPos, targetPos)
                if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                    movementPulseTimer = 0
                    pulseMovementKey(Enum.KeyCode.W)
                end
            end
            
        elseif currentMode == "ATTACK" then
            ensureFlight()
            if justAttacked then
                if totalDist < CONFIG.OPTIMAL_MID then
                    if spectating then
                        if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                            movementPulseTimer = 0
                            moveWhileSpectating(false)
                        end
                    else
                        Camera.CameraType = Enum.CameraType.Scriptable
                        flightMode = pointCameraAway(myPos, targetPos)
                        if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                            movementPulseTimer = 0
                            pulseMovementKey(Enum.KeyCode.W)
                        end
                    end
                else
                    justAttacked = false
                end
            else
                if not targetWasInvisible and not isAttacking then
                    performQClickAttack()
                end
            end
            
        elseif currentMode == "APPROACH" then
            ensureFlight()
            if spectating then
                if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                    movementPulseTimer = 0
                    moveWhileSpectating(true)
                end
            else
                Camera.CameraType = Enum.CameraType.Scriptable
                flightMode = pointCameraForMovement(myPos, targetPos)
                if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                    movementPulseTimer = 0
                    local curved, curveType = pulseCurveAcceleration(myPos, targetPos)
                    if curved then flightMode = flightMode .. "+" .. curveType end
                end
            end
            
        elseif currentMode == "TRAVEL" then
            ensureFlight()
            Camera.CameraType = Enum.CameraType.Scriptable
            
            -- Use new angled flight logic
            flightMode = pointCameraForMovement(myPos, targetPos)
            
            if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                movementPulseTimer = 0
                local curved, curveType = pulseCurveAcceleration(myPos, targetPos)
                if curved then flightMode = flightMode .. "+" .. curveType end
            end
        end
        
        -- Debug (protected to avoid spam errors)
        pcall(function()
            local stamina = getStamina() or 0
            local attackCooldown = math.max(0, CONFIG.Q_CLICK_COOLDOWN - (tick() - lastQClickTime))
            local queueNames = getSecondaryTargetNames()
            local queueStr = #queueNames > 0 and table.concat(queueNames, "→") or "none"
            updateDebug(string.format(
                [[Target: %s
Mode: %s | Spectating: %s
Distance: H=%.1f V=%.1f Total=%.1f
Optimal: %d-%d studs
Status: %s | Queue: %s
Stamina: %d | Air: %.1fs
Attack CD: %.1fs | Sustained: %s
Flight: %s (%s)]],
                targetPlayer and targetPlayer.Name or "None",
                currentMode or "IDLE",
                tostring(spectating),
                hDist or 0, vDiff or 0, totalDist or 0,
                CONFIG.OPTIMAL_MIN, CONFIG.OPTIMAL_MAX,
                targetWasDead and "DEAD" or (targetWasInvisible and "INVISIBLE" or "ALIVE"),
                queueStr,
                stamina,
                airRemaining or 0,
                attackCooldown,
                tostring(sustainedAttackMode),
                tostring(hasFlight()),
                flightMode or "NONE"
            ))
        end)
    end)
end

local function stopMovementLoop()
    if movementLoop then movementLoop:Disconnect(); movementLoop = nil end
    releaseKey(Enum.KeyCode.Q)
    isAttacking = false
end

-- =====================================================
-- TARGET SELECTION
-- =====================================================

local function getClosestPlayerToCursor()
    local closest = nil
    local minDist = math.huge
    local mousePos = UserInputService:GetMouseLocation()
    
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= player then
            local root = getRoot(plr)
            if root then
                local success, pos, onScreen = pcall(function()
                    return Camera:WorldToViewportPoint(root.Position)
                end)
                if success and onScreen then
                    local screenDist = (Vector2.new(pos.X, pos.Y) - mousePos).Magnitude
                    if screenDist < minDist then
                        minDist = screenDist
                        closest = plr
                    end
                end
            end
        end
    end
    return closest
end

-- =====================================================
-- MULTI-TARGET SYSTEM (M key)
-- =====================================================

local function isSecondaryTargetById(userId)
    for i, uid in ipairs(secondaryTargetUserIds) do
        if uid == userId then
            return true, i
        end
    end
    return false, 0
end

local function isSecondaryTarget(plr)
    if not plr then return false, 0 end
    return isSecondaryTargetById(plr.UserId)
end

local function getPlayerByUserId(userId)
    for _, plr in pairs(Players:GetPlayers()) do
        if plr.UserId == userId then
            return plr
        end
    end
    return nil
end

local function addSecondaryTarget(plr)
    if not plr then return false end
    if targetPlayer and plr.UserId == targetPlayer.UserId then return false end  -- Can't add primary as secondary
    
    -- Check if already in list
    local exists, _ = isSecondaryTargetById(plr.UserId)
    if exists then return false end
    
    -- Check if we have room
    if #secondaryTargetUserIds >= MAX_SECONDARY_TARGETS then
        return false
    end
    
    table.insert(secondaryTargetUserIds, plr.UserId)
    print("Added secondary target #" .. #secondaryTargetUserIds .. ": " .. plr.Name)
    return true
end

local function removeSecondaryTarget(plr)
    if not plr then return false end
    
    local exists, index = isSecondaryTargetById(plr.UserId)
    if exists then
        table.remove(secondaryTargetUserIds, index)
        print("Removed secondary target: " .. plr.Name)
        return true
    end
    return false
end

local function removeSecondaryTargetById(userId)
    local exists, index = isSecondaryTargetById(userId)
    if exists then
        table.remove(secondaryTargetUserIds, index)
        return true
    end
    return false
end

local function toggleSecondaryTarget(plr)
    if not plr then return end
    
    local exists, _ = isSecondaryTarget(plr)
    if exists then
        removeSecondaryTarget(plr)
    else
        if not addSecondaryTarget(plr) then
            if #secondaryTargetUserIds >= MAX_SECONDARY_TARGETS then
                print("Max secondary targets reached (" .. MAX_SECONDARY_TARGETS .. ")")
            end
        end
    end
end

local function getNextTarget()
    -- Get next available secondary target (by UserId, persists across rejoin)
    -- Only returns ALIVE players
    local checkedCount = 0
    local totalTargets = #secondaryTargetUserIds
    
    while #secondaryTargetUserIds > 0 and checkedCount < totalTargets do
        local nextUserId = secondaryTargetUserIds[1]
        local nextPlayer = getPlayerByUserId(nextUserId)
        
        -- Must be in game, have root, AND be alive
        if nextPlayer and nextPlayer.Parent and getRoot(nextPlayer) and isPlayerAlive(nextPlayer) then
            -- Valid alive player found - remove from queue and return
            table.remove(secondaryTargetUserIds, 1)
            return nextPlayer
        else
            -- Player dead, offline, or not loaded - move to back of queue
            table.remove(secondaryTargetUserIds, 1)
            table.insert(secondaryTargetUserIds, nextUserId)
            checkedCount = checkedCount + 1
        end
    end
    return nil  -- No valid alive targets currently available
end

local function switchToNextTarget()
    -- Try secondary targets first (only returns alive players)
    local nextTarget = getNextTarget()
    
    -- If no secondaries available, try original primary (must also be alive)
    if not nextTarget and originalPrimaryUserId then
        local originalPrimary = getPlayerByUserId(originalPrimaryUserId)
        if originalPrimary and originalPrimary.Parent and getRoot(originalPrimary) and isPlayerAlive(originalPrimary) then
            nextTarget = originalPrimary
            print("Falling back to original primary: " .. originalPrimary.Name)
        end
    end
    
    if nextTarget then
        targetPlayer = nextTarget
        targetWasDead = false
        targetWasInvisible = false
        stoppedFlightForDeath = false
        tauntPauseActive = false
        lastBodyPosition = nil
        rememberedTargetUserId = nextTarget.UserId
        createTargetIndicator()
        print("Switched to next target: " .. nextTarget.Name)
        return true
    end
    return false  -- No alive targets, will keep checking
end

local function clearSecondaryTargets()
    secondaryTargetUserIds = {}
end

local function getSecondaryTargetNames()
    local names = {}
    for _, userId in ipairs(secondaryTargetUserIds) do
        local plr = getPlayerByUserId(userId)
        if plr and plr.Name then
            if isPlayerAlive(plr) then
                table.insert(names, plr.Name)
            else
                table.insert(names, plr.Name .. "(dead)")
            end
        else
            table.insert(names, "[offline]")
        end
    end
    return names
end

-- =====================================================
-- MAIN CONTROL
-- =====================================================

local function startFollowing()
    flightDisabledForStamina = false
    spectating = false
    altIsDead = false
    justAttacked = false
    ensureFlight()
    createDebugGui()
    createTargetIndicator()
    
    movementPulseTimer = CONFIG.MOVEMENT_PULSE_RATE
    lastTargetCheck = 0
    targetWasDead = false
    targetWasInvisible = false
    currentMode = "IDLE"
    isAttacking = false
    lastFrameTime = 0
    
    isUnderwater = false
    airRemaining = CONFIG.UNDERWATER_MAX_TIME
    lastUnderwaterCheck = 0
    cachedTargetInWater = false
    stoppedFlightForDeath = false
    hasSentTaunt = false
    tauntScheduled = false
    tauntPauseActive = false
    lastBodyPosition = nil
    lastRandomWalkTime = 0
    randomWalkDirection = nil
    lastJumpTime = 0
    lastCombatJumpTime = 0
    lastCanAttackCheck = 0
    lastCanAttackResult = false
    emergencyDefenseActive = false
    preEmergencyTask = nil
    lastKnownHealth = getAltHealth()
    resurfaceStarted = false
    
    -- Reset sustained attack mode
    sustainedAttackMode = false
    sustainedDamageAccumulated = 0
    lastDamageTime = 0
    
    -- Reset retreat state
    retreatActive = false
    retreatPosition = nil
    retreatReason = nil
    
    -- Reset telek shield tracking
    telekBlockStartTime = 0
    lastTelekRollTime = 0
    
    -- Remember target for rejoin tracking
    if targetPlayer then
        rememberedTargetUserId = targetPlayer.UserId
    end
    
    -- Reset vertical tracking
    lastVerticalDirection = 0
    verticalDirectionStartTime = 0
    
    cached2xStamina = nil
    cachedStaminaMin = nil
    cachedStaminaRecharge = nil
    
    resetStuckDetection()
    startCameraUpdate()
    startMovementLoop()
    
    print("Started following", targetPlayer.Name)
end

local function stopFollowing()
    following = false
    targetPlayer = nil
    currentMode = "IDLE"
    flightDisabledForStamina = false
    isAttacking = false
    spectating = false
    altIsDead = false
    isUnderwater = false
    airRemaining = CONFIG.UNDERWATER_MAX_TIME
    cachedTargetInWater = false
    stoppedFlightForDeath = false
    hasSentTaunt = false
    tauntScheduled = false
    tauntPauseActive = false
    lastBodyPosition = nil
    lastRandomWalkTime = 0
    randomWalkDirection = nil
    lastJumpTime = 0
    lastCombatJumpTime = 0
    emergencyDefenseActive = false
    preEmergencyTask = nil
    lastKnownHealth = 100
    resurfaceStarted = false
    
    -- Reset sustained attack mode
    sustainedAttackMode = false
    sustainedDamageAccumulated = 0
    lastDamageTime = 0
    
    -- Reset target memory
    rememberedTargetUserId = nil
    originalPrimaryUserId = nil
    manuallySwitchedTarget = false
    retreatActive = false
    retreatPosition = nil
    retreatReason = nil
    
    -- Reset telek shield tracking
    telekBlockStartTime = 0
    lastTelekRollTime = 0
    
    -- Note: Secondary targets persist across stop/start (only cleared on N key switch)
    
    resetStuckDetection()
    stopMovementLoop()
    stopCameraUpdate()
    stopAllMovementKeys()
    releaseKey(Enum.KeyCode.Q)
    releaseKey(Enum.KeyCode.Space)
    
    Camera.CameraType = Enum.CameraType.Custom
    local hum = getHumanoid(player)
    if hum then Camera.CameraSubject = hum end
    UserInputService.MouseBehavior = Enum.MouseBehavior.Default
    
    removeTargetIndicator()
    if debugGui then debugGui:Destroy(); debugGui = nil end
    
    print("Stopped following")
end

-- =====================================================
-- INPUT HANDLER
-- =====================================================

UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    
    if input.KeyCode == Enum.KeyCode.N then
        if not following then
            local target = getClosestPlayerToCursor()
            if target then
                targetPlayer = target
                following = true
                lastKnownPosition = nil
                manuallySwitchedTarget = false  -- Fresh target, not a switch
                originalPrimaryUserId = target.UserId  -- Remember original primary
                -- Remove from secondary queue if it was there
                removeSecondaryTargetById(target.UserId)
                startFollowing()
            else
                warn("No player found near cursor")
            end
        else
            -- Check if pressing N to switch to different target while following
            local newTarget = getClosestPlayerToCursor()
            if newTarget and newTarget ~= targetPlayer then
                -- Switching to new target manually - this becomes new primary
                targetPlayer = newTarget
                manuallySwitchedTarget = true  -- Mark as manual switch
                rememberedTargetUserId = newTarget.UserId
                originalPrimaryUserId = newTarget.UserId  -- New primary
                targetWasDead = false
                targetWasInvisible = false
                -- Remove new primary from secondary queue if it was there
                removeSecondaryTargetById(newTarget.UserId)
                createTargetIndicator()
                print("Switched target to", newTarget.Name)
            else
                -- No new target or same target - stop following
                stopFollowing()
            end
        end
    
    elseif input.KeyCode == Enum.KeyCode.M then
        -- M key: Add/remove secondary targets (works before or during following)
        local target = getClosestPlayerToCursor()
        if target then
            if target == targetPlayer then
                print("Cannot add primary target as secondary")
            else
                toggleSecondaryTarget(target)
                -- Print current queue
                local names = getSecondaryTargetNames()
                if #names > 0 then
                    print("Target queue: " .. table.concat(names, " → "))
                else
                    print("No secondary targets")
                end
            end
        else
            warn("No player found near cursor")
        end
    end
end)

-- PlayerAdded listener for target rejoin
Players.PlayerAdded:Connect(function(newPlayer)
    -- Check if this is our remembered primary target rejoining
    if following and rememberedTargetUserId and not manuallySwitchedTarget then
        if newPlayer.UserId == rememberedTargetUserId then
            -- Our target rejoined! Re-target them
            task.wait(1)  -- Wait for character to load
            if following and targetPlayer ~= newPlayer then
                targetPlayer = newPlayer
                targetWasDead = false
                targetWasInvisible = false
                stoppedFlightForDeath = false
                createTargetIndicator()
                print("Target rejoined - re-acquiring:", newPlayer.Name)
            end
        end
    end
    
    -- Check if this is a secondary target rejoining
    if following then
        local isSecondary, _ = isSecondaryTargetById(newPlayer.UserId)
        if isSecondary then
            print("Secondary target rejoined: " .. newPlayer.Name)
        end
    end
end)

-- =====================================================
-- CLEANUP
-- =====================================================

player.CharacterAdded:Connect(function()
    altIsDead = false
    task.wait(1)
    if targetPlayer and following then
        flightDisabledForStamina = false
        spectating = false
        isAttacking = false
        movementPulseTimer = CONFIG.MOVEMENT_PULSE_RATE
        ensureFlight()
        createTargetIndicator()
        createDebugGui()
    end
end)

player.CharacterRemoving:Connect(function()
    altIsDead = true
    stopSpectating()
    releaseKey(Enum.KeyCode.Q)
    isAttacking = false
end)

Players.PlayerRemoving:Connect(function(leavingPlayer)
    if leavingPlayer == targetPlayer then
        -- Target left - remember them for rejoin (unless manually switched)
        if not manuallySwitchedTarget then
            rememberedTargetUserId = leavingPlayer.UserId
        end
        
        -- Clear current target but keep following state
        targetPlayer = nil
        targetWasDead = true  -- Treat as "dead" for behavior
        stoppedFlightForDeath = false
        
        -- Stop spectating and attacking
        if spectating then stopSpectating() end
        isAttacking = false
        
        print("Target left game - waiting for rejoin:", leavingPlayer.Name)
    end
end)

-- =====================================================
-- STARTUP
-- =====================================================

print("=" .. string.rep("=", 50))
print("ALT FOLLOW SCRIPT V5.4.3 - PRE-TARGETING")
print("=" .. string.rep("=", 50))
print("Controls:")
print("  N - Toggle/Switch primary target")
print("  M - Add/Remove secondary (works BEFORE N!)")
print("")
print("MULTI-TARGET:")
print("• M before N: Pre-set secondary targets")
print("• Queue persists across stop/start")
print("• Auto-switches when primary dies")
print("")
print("PUSH/PULL: Based on HORIZONTAL distance")
print("• H-dist >= " .. (CONFIG.OPTIMAL_MAX - 5) .. " → Pull back")
print("• H-dist < " .. (CONFIG.OPTIMAL_MAX - 5) .. " → Push away")
print("")
print("Comfort: " .. CONFIG.OPTIMAL_MIN .. "-" .. CONFIG.OPTIMAL_MAX .. " studs")
print("=" .. string.rep("=", 50))
