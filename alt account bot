

loadstring(game:HttpGet("https://raw.githubusercontent.com/SultrySlut/tka-lock2/refs/heads/main/the%20stuff"))()
-- =====================================================
-- AltFollow Script v6.0 - Full Specification Implementation
-- Water, River, LOS, Shield, Availability, State Machine
-- =====================================================
-- This script implements the comprehensive specification document
-- for reliable river combat, opportunistic secondary targets,
-- and physics-safe movement without NaN/deletion bugs.
-- =====================================================

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Camera = workspace.CurrentCamera
local Terrain = workspace:FindFirstChildOfClass("Terrain")

local player = Players.LocalPlayer

-- =====================================================
-- SECTION 1: CONFIGURATION (per spec sections 5, 7, 17, 18, 19)
-- =====================================================

local CONFIG = {
    -- Distance thresholds
    OPTIMAL_MIN = 54,
    OPTIMAL_MAX = 73,
    OPTIMAL_MID = 60,
    COMBAT_ZONE = 76,
    SECONDARY_TARGET_RANGE = 200,
    
    -- Timing
    Q_CLICK_COOLDOWN = 1.45,
    
    -- Q Attack Timing (in seconds)
    Q_AIM_DELAY = 0.1,       -- Wait after moving mouse to target
    Q_HOLD_BEFORE_CLICK = 0.2,  -- How long to hold Q before clicking
    Q_HOLD_AFTER_CLICK = 0.2,   -- How long to hold Q after clicking before release
    TARGET_CHECK_RATE = 0.01,
    FLIGHT_TOGGLE_COOLDOWN = 1,
    WATER_STATE_UPDATE_RATE = 0.1,  -- Check water state every 0.1s for reliable air tracking
    LOS_CACHE_WINDOW = 0.25,
    
    -- Pulse Profiles (Section 17)
    -- HOLD_DURATION = how long key stays down
    -- REFRESH_INTERVAL = how often to re-send KeyDown while held
    PULSE_W = { HOLD_DURATION = 3.0, REFRESH_INTERVAL = 0.5 },
    PULSE_S = { HOLD_DURATION = 1.0, REFRESH_INTERVAL = 0.3 },
    PULSE_A = { HOLD_DURATION = 1.5, REFRESH_INTERVAL = 0.4 },
    PULSE_D = { HOLD_DURATION = 1.5, REFRESH_INTERVAL = 0.4 },
    PULSE_SPACE_RESURFACE = { HOLD_DURATION = 1.5, REFRESH_INTERVAL = 0.08 },  -- Long hold for proper resurface
    PULSE_SPACE_NORMAL = { HOLD_DURATION = 0.3, REFRESH_INTERVAL = 0.15 },
    
    -- Idle/Wander pulse profiles (longer for smooth movement)
    PULSE_IDLE_WALK = { HOLD_DURATION = 2.0, REFRESH_INTERVAL = 0.4 },
    PULSE_RETREAT = { HOLD_DURATION = 2.5, REFRESH_INTERVAL = 0.5 },
    
    -- Stamina Management
    STAMINA_MIN = 40,
    STAMINA_RECHARGE_THRESHOLD = 140,
    
    -- Combat
    LINE_OF_SIGHT_RAYS = 20,
    CYLINDER_RADIUS = 3,
    CLICK_BELOW_OFFSET = 150,
    CLICK_ABOVE_OFFSET = 150,
    
    -- River System (Section 5)
    RIVER_X_MIN = -550,
    RIVER_X_MAX = -100,
    RIVER_Z_MIN = -735,
    RIVER_Z_MAX = 577,
    RIVER_SURFACE_Y = -40,
    RIVER_EXIT_HEIGHT = 20,
    RIVER_COMMIT_TIME = 1.0,
    UNDER_MAP_Y = -85,
    
    -- Air Management (Section 7)
    UNDERWATER_MAX_TIME = 10,
    AIR_RESURFACE_THRESHOLD = 2,
    DOLPHIN_MAX_HEIGHT = 25,  -- Max studs above water surface for dolphin arc peak
    RESURFACE_TIMEOUT = 5,  -- If resurfacing takes longer than this, try harder
    
    -- Flight Steering (Section 18)
    ARC_DISTANCE_THRESHOLD = 140,
    ARC_ENTER_DISTANCE = 150,
    SLOPE_ENTER_DISTANCE = 130,
    CURVE_THRESHOLD = 0.30,
    CURVE_DEVIATION_RATIO = 0.20,
    CURVE_MIN_VELOCITY = 5,
    CLEARANCE_RAY_DIST = 20,
    CLEARANCE_MIN = 10,
    CLEARANCE_SOFT = 18,
    
    -- Vertical Flight
    VERTICAL_THRESHOLD = 10,
    MAX_VERTICAL_SEPARATION = 80,
    SMALL_HEIGHT_CHANGE = 8,
    ANGLED_FLIGHT_RATIO = 0.5,
    VERTICAL_DIRECTION_HOLD_TIME = 0.6,
    
    -- Stuck Detection (Section 19.3)
    STUCK_VELOCITY_THRESHOLD = 3,
    STUCK_TIME_THRESHOLD = 0.4,
    UNSTUCK_DURATION = 3,
    UNSTUCK_SCAN_POINTS = 40,
    UNSTUCK_SCAN_DISTANCE = 100,
    
    -- Map Boundary (Section 19)
    MAP_X_MIN = -999,
    MAP_X_MAX = 614,
    MAP_Z_MIN = -735,
    MAP_Z_MAX = 577,
    MAP_BOUNDARY_BUFFER = 50,
    
    -- No-Chase Zones (Section 20.0)
    HOUSE_CENTER = Vector3.new(-59.50, 71.67, -431.95),
    HOUSE_RADIUS = 40,
    HOUSE_Y_MAX = 47,
    TOWER_RADIUS = 14,
    TOWER_TARGET_Y_IN = 85,
    TOWER_CENTERS = {
        Vector3.new(14.79, 48.10, -382.65),
        Vector3.new(-1.37, 48.00, -217.07),
        Vector3.new(-194.55, 47.65, -271.86),
        Vector3.new(-128.60, 47.38, -417.08),
    },
    
    -- Unavailable Behavior (Section 12)
    UNAVAILABLE_RETREAT_DIST = 100,
    UNAVAILABLE_STAY_RANGE = 50,
    INVISIBILITY_GRACE_WINDOW = 0.5,
    PERSISTENT_NO_LOS_THRESHOLD = 1.5,
    STRUCTURE_CHECK_RATE = 0.25,  -- Only check structure/availability 4 times per second
    LOS_CACHE_RATE = 0.1,  -- Cache LOS results for 0.1s
    INSIDE_BOULDER_THRESHOLD = 25,  -- Max distance for inside-boulder detection
    
    -- Taunts
    TAUNT_MIN_DELAY = 1.0,
    TAUNT_MAX_DELAY = 1.5,
    TAUNT_RANGE = 100,
    
    -- Shield (Section 10)
    TELEK_GRAB_CHANCE = 0.20,
    
    -- Secondary target stickiness (Section 13.5)
    SECONDARY_DWELL_TIME = 1.5,
    
    -- Combat Camera Lock
    COMBAT_CAM_SMOOTHNESS = 0.15,  -- Lower = snappier, higher = smoother (0-1)
    COMBAT_CAM_OFFSET = Vector3.new(0, 0, 0),  -- Aim offset from target head
}

local TAUNTS = {
    "GG", "ez", "rip", "too easy", "get good", "lol",
    "nice try", "gg ez", "free", "sit", "back to menu", "yawn",
}

-- =====================================================
-- SECTION 2: STATE (per spec Section 22 state graph)
-- =====================================================

local S = {
    -- Core state
    following = false,
    currentState = "STARTUP", -- STARTUP, IDLE, COMBAT_FLOW, RIVER_APPROACH, DIVING, RIVER_COMBAT, RESURFACE, BOUNDARY_WALK, RETURNING_TO_MAP, UNAVAILABLE_BAND
    
    -- Target tracking
    targetPlayer = nil,
    primaryUserId = nil,
    secondaryTargetUserIds = {},
    MAX_SECONDARY_TARGETS = 2,
    activeSecondaryUserId = nil,
    secondaryStartTime = 0,
    onSecondaryTarget = false,
    
    -- Target state
    targetWasDead = false,
    targetWasInvisible = false,
    targetInvisibleStartTime = 0,
    lastKnownPosition = nil,
    
    -- Water state (Section 4)
    waterState = "DRY", -- DRY, SURFACE, UNDERWATER
    headInWater = false,
    rootInWater = false,
    lastWaterStateUpdate = 0,
    
    -- River method (Section 6)
    targetTouchedWater = false,
    targetWaterStartTime = 0,
    riverMethodActive = false,
    
    -- Air management (Section 7)
    airRemaining = CONFIG.UNDERWATER_MAX_TIME,
    isUnderwater = false,
    resurfaceMode = false,
    emergencyResurface = false,
    dolphinStartY = nil,  -- Y position when dolphin dive started
    dolphinPhase = "RISING",  -- RISING or FALLING
    resurfaceStartTime = 0,  -- When resurface mode started (for timeout)
    
    -- Availability (Section 11)
    targetAvailable = true,
    unavailableReason = nil,
    structureTrappedTimer = 0,
    lastLOSFailTime = 0,
    lastStructureCheck = 0,  -- Throttle for updateStructureTrapped
    lastLOSCheckTime = 0,    -- Cache for LOS checks
    lastLOSResult = false,   -- Cached LOS result
    
    -- Flight steering (Section 18)
    steeringMode = "SLOPE", -- ARC or SLOPE
    flightDisabledForStamina = false,
    lastFlightToggle = 0,
    
    -- Combat
    lastQClickTime = 0,
    isAttacking = false,
    throwPhase = "PULL", -- PULL or PUSH
    
    -- Shield (Section 10)
    telekBlockStartTime = 0,
    lastTelekRollTime = 0,
    
    -- Stuck detection (Section 19.3)
    lastPosition = nil,
    lastPositionTime = 0,
    stuckTimer = 0,
    isUnsticking = false,
    unstickDirection = nil,
    unstickEndTime = 0,
    
    -- Boundary (Section 19)
    nearBoundary = false,
    outsideBoundary = false,
    
    -- Idle/Taunt (Section 12)
    hasSentTaunt = false,
    tauntScheduled = false,
    tauntPauseActive = false,
    idleFacingDirection = nil,
    lastBodyPosition = nil,
    
    -- Pulse system (Section 17)
    keyStates = {}, -- { [keyCode] = { isDown, holdEndTime, nextRefreshTime } }
    
    -- Camera
    defaultFOV = nil,
    
    -- Frame timing
    lastFrameTime = 0,
    
    -- GUI
    debugGui = nil,
    targetIndicator = nil,
    targetBillboard = nil,
    secondaryIndicators = {},
    
    -- Movement loop
    movementConnection = nil,
    
    -- Alt state
    altIsDead = false,
}

-- =====================================================
-- SECTION 3: UTILITY FUNCTIONS
-- =====================================================

local function safeUnit(v, fallback)
    if not v then return fallback or Vector3.new(0, 0, -1) end
    local mag = v.Magnitude
    if mag > 1e-6 then return v / mag end
    return fallback or Vector3.new(0, 0, -1)
end

local function isValidVector(v)
    if not v then return false end
    return v.X == v.X and v.Y == v.Y and v.Z == v.Z -- NaN check
end

local function isValidNumber(n)
    return n and n == n and math.abs(n) < 1e10
end

local function clampPosition(pos)
    if not isValidVector(pos) then return Vector3.new(0, 50, 0) end
    local x = math.clamp(pos.X, -10000, 10000)
    local y = math.clamp(pos.Y, -10000, 10000)
    local z = math.clamp(pos.Z, -10000, 10000)
    return Vector3.new(x, y, z)
end

-- =====================================================
-- CHARACTER/POSITION HELPERS
-- =====================================================

local function getChar(plr)
    if not plr then return nil end
    local chars = workspace:FindFirstChild("Characters")
    return (chars and chars:FindFirstChild(plr.Name)) or plr.Character
end

local function getRoot(plr)
    local char = getChar(plr)
    if not char then return nil end
    return char:FindFirstChild("HumanoidRootPart") or 
           char:FindFirstChild("Torso") or 
           char:FindFirstChild("UpperTorso") or
           char.PrimaryPart
end

local function getHead(plr)
    local char = getChar(plr)
    return char and char:FindFirstChild("Head")
end

local function getHumanoid(plr)
    local char = getChar(plr)
    return char and char:FindFirstChildOfClass("Humanoid")
end

local function getPlayerPosition(plr)
    if not plr then return nil end
    local root = getRoot(plr)
    if root and isValidVector(root.Position) then
        return root.Position
    end
    local char = getChar(plr)
    if char then
        for _, part in pairs(char:GetDescendants()) do
            if part:IsA("BasePart") and isValidVector(part.Position) then
                return part.Position
            end
        end
    end
    return nil
end

-- Legacy function for backward compat (uses primary only)
-- In movement loop, use getPlayerPosition(target) instead
local function getTargetPosition()
    if not S.targetPlayer then return S.lastKnownPosition end
    local pos = getPlayerPosition(S.targetPlayer)
    if pos then
        S.lastKnownPosition = pos
        return pos
    end
    return S.lastKnownPosition
end

local function getMyPosition()
    local root = getRoot(player)
    if root and isValidVector(root.Position) then
        return root.Position
    end
    return nil
end

local function isPlayerAlive(plr)
    if not plr then return false end
    local char = getChar(plr)
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    if hum then
        if hum.Health <= 0 then return false end
        local ok, state = pcall(function() return hum:GetState() end)
        if ok and state == Enum.HumanoidStateType.Dead then return false end
        return true
    end
    return false
end

local function isTargetAlive()
    return isPlayerAlive(S.targetPlayer)
end

local function getAltHealth()
    local hum = getHumanoid(player)
    return hum and hum.Health or 0
end

local function getStamina()
    local chars = workspace:FindFirstChild("Characters")
    if not chars then return nil end
    local myChar = chars:FindFirstChild(player.Name)
    if not myChar then return nil end
    local stamina = myChar:FindFirstChild("Stamina")
    if stamina then
        if stamina:IsA("IntValue") or stamina:IsA("NumberValue") then
            return stamina.Value
        elseif stamina:FindFirstChild("Value") then
            return stamina.Value.Value
        end
    end
    return nil
end

-- 2x Stamina check (cached)
local cached2xStamina = nil
local function has2xStamina()
    if cached2xStamina ~= nil then return cached2xStamina end
    local data = player:FindFirstChild("Data")
    if data then
        local doubleStamina = data:FindFirstChild("2xStamina")
        if doubleStamina then
            cached2xStamina = doubleStamina.Value == true
            return cached2xStamina
        end
    end
    cached2xStamina = false
    return false
end

local function getEffectiveStaminaMin()
    return has2xStamina() and CONFIG.STAMINA_MIN or (CONFIG.STAMINA_MIN / 2)
end

local function getEffectiveStaminaRecharge()
    return has2xStamina() and CONFIG.STAMINA_RECHARGE_THRESHOLD or (CONFIG.STAMINA_RECHARGE_THRESHOLD / 2)
end

-- =====================================================
-- SECTION 3: WATER DETECTION PRIMITIVES (Spec Section 3)
-- =====================================================

local waterOverlapParams = OverlapParams.new()
waterOverlapParams.FilterType = Enum.RaycastFilterType.Blacklist

-- 3.1 Terrain Water Detection
local function terrainWaterAtPoint(point)
    if not Terrain or not Terrain.ReadVoxels then return false end
    if not point or not isValidVector(point) then return false end
    if math.abs(point.X) > 10000 or math.abs(point.Y) > 10000 or math.abs(point.Z) > 10000 then
        return false
    end
    
    -- Snap to 4-stud voxel grid
    local snapped = Vector3.new(
        math.floor(point.X / 4) * 4 + 2,
        math.floor(point.Y / 4) * 4 + 2,
        math.floor(point.Z / 4) * 4 + 2
    )
    
    local half = Vector3.new(2, 2, 2)
    local region = Region3.new(snapped - half, snapped + half):ExpandToGrid(4)
    
    local ok, materials = pcall(function()
        return Terrain:ReadVoxels(region, 4)
    end)
    
    if not ok or not materials then return false end
    
    for x = 1, #materials do
        local col = materials[x]
        if col then
            for y = 1, #col do
                local row = col[y]
                if row then
                    for z = 1, #row do
                        if row[z] == Enum.Material.Water then
                            return true
                        end
                    end
                end
            end
        end
    end
    return false
end

-- Water part detection helper
local function isWaterPart(part)
    if not part or not part:IsA("BasePart") then return false end
    if part.Material == Enum.Material.Water then return true end
    if string.find(string.lower(part.Name or ""), "water") then return true end
    return false
end

-- 3.2 Unified Water Check
local function waterAtPoint(point, charToIgnore)
    if not point or not isValidVector(point) then return false end
    
    -- Check terrain water first
    if terrainWaterAtPoint(point) then return true end
    
    -- Check water parts via GetPartBoundsInBox
    waterOverlapParams.FilterDescendantsInstances = charToIgnore and {charToIgnore} or {}
    
    local ok, parts = pcall(function()
        return workspace:GetPartBoundsInBox(
            CFrame.new(point),
            Vector3.new(4, 4, 4),
            waterOverlapParams
        )
    end)
    
    if not ok or not parts then return false end
    
    for _, p in ipairs(parts) do
        if isWaterPart(p) then return true end
    end
    
    return false
end

-- =====================================================
-- SECTION 4: ENTITY WATER STATE (Spec Section 4)
-- =====================================================

-- 4.1 Underwater Check
local function checkUnderwater(char)
    if not char then return false end
    local head = char:FindFirstChild("Head")
    local root = char:FindFirstChild("HumanoidRootPart")
    
    -- Head first (breathing)
    if head and waterAtPoint(head.Position, char) then
        return true
    end
    -- Root second (body)
    if root and waterAtPoint(root.Position, char) then
        return true
    end
    return false
end

-- 4.2 Water State Classification
local function getWaterState(char)
    if not char then return "DRY", false, false end
    
    local head = char:FindFirstChild("Head")
    local root = char:FindFirstChild("HumanoidRootPart")
    
    local headInWater = head and waterAtPoint(head.Position, char) or false
    local rootInWater = root and waterAtPoint(root.Position, char) or false
    
    local state = "DRY"
    if headInWater then
        state = "UNDERWATER"
    elseif rootInWater then
        state = "SURFACE"
    end
    
    return state, headInWater, rootInWater
end

-- Update water state (cached, runs every 0.25s)
local function updateWaterState()
    local now = tick()
    if now - S.lastWaterStateUpdate < CONFIG.WATER_STATE_UPDATE_RATE then
        return
    end
    S.lastWaterStateUpdate = now
    
    local char = getChar(player)
    S.waterState, S.headInWater, S.rootInWater = getWaterState(char)
    S.isUnderwater = (S.waterState == "UNDERWATER")
end

-- =====================================================
-- SECTION 5: RIVER ZONE SYSTEM (Spec Section 5)
-- =====================================================

local function isInRiverBounds(pos)
    if not pos then return false end
    return pos.X >= CONFIG.RIVER_X_MIN and pos.X <= CONFIG.RIVER_X_MAX
       and pos.Z >= CONFIG.RIVER_Z_MIN and pos.Z <= CONFIG.RIVER_Z_MAX
end

local function isInRiverZone(pos)
    if not pos then return false end
    return isInRiverBounds(pos) and pos.Y > CONFIG.UNDER_MAP_Y
end

local function isTargetInRiverMethodRange(tp)
    if not tp then return false end
    return isInRiverBounds(tp) and tp.Y <= CONFIG.RIVER_SURFACE_Y + 10 and tp.Y > CONFIG.UNDER_MAP_Y
end

-- =====================================================
-- SECTION 6: RIVER METHOD STATE MACHINE (Spec Section 6)
-- =====================================================

local function updateRiverMethodState(tp, now)
    if not tp then
        S.riverMethodActive = false
        S.targetTouchedWater = false
        S.targetWaterStartTime = 0
        return
    end
    
    -- Exit conditions (highest priority)
    if not isTargetInRiverMethodRange(tp) then
        S.riverMethodActive = false
        S.targetTouchedWater = false
        S.targetWaterStartTime = 0
        return
    end
    
    if not isTargetAlive() then
        S.riverMethodActive = false
        S.targetTouchedWater = false
        S.targetWaterStartTime = 0
        return
    end
    
    -- Check if target root is in water
    local targetChar = getChar(S.targetPlayer)
    local targetRoot = targetChar and targetChar:FindFirstChild("HumanoidRootPart")
    local targetInWater = targetRoot and waterAtPoint(targetRoot.Position, targetChar)
    
    -- Entry tracking
    if targetInWater and not S.targetTouchedWater then
        S.targetTouchedWater = true
        S.targetWaterStartTime = now
    end
    
    -- Commit after RIVER_COMMIT_TIME
    if S.targetTouchedWater and (now - S.targetWaterStartTime) >= CONFIG.RIVER_COMMIT_TIME then
        S.riverMethodActive = true
    end
end

-- =====================================================
-- SECTION 7: AIR MANAGEMENT SYSTEM (Spec Section 7)
-- =====================================================

local function updateAirManagement(dt)
    -- Air drains when head is in water (more reliable than waterState)
    if S.headInWater then
        S.airRemaining = S.airRemaining - dt
    else
        S.airRemaining = CONFIG.UNDERWATER_MAX_TIME -- instant recharge when head is out
    end
    
    -- Clamp air to prevent negative values
    if S.airRemaining < 0 then
        S.airRemaining = 0
    end
    
    local now = tick()
    
    -- Check resurface triggers
    -- EMERGENCY: Air completely depleted - MUST resurface
    if S.airRemaining <= 0 and S.headInWater then
        if not S.resurfaceMode then
            S.resurfaceStartTime = now
        end
        S.emergencyResurface = true
        S.resurfaceMode = true
    -- NORMAL: Air getting low while head in water - should resurface soon
    elseif S.headInWater and S.airRemaining <= CONFIG.AIR_RESURFACE_THRESHOLD then
        -- Always trigger resurface when air is low and head is underwater
        -- Don't require riverMethodActive - we need air regardless of combat mode
        if not S.resurfaceMode then
            S.resurfaceMode = true
            S.emergencyResurface = false
            S.resurfaceStartTime = now
        end
    end
    
    -- Check for resurface timeout - if stuck trying to resurface for too long
    if S.resurfaceMode and S.headInWater then
        local resurfaceTime = now - S.resurfaceStartTime
        if resurfaceTime > CONFIG.RESURFACE_TIMEOUT then
            -- Stuck underwater - force emergency mode for more aggressive resurface
            S.emergencyResurface = true
            -- Reset dolphin state to try fresh approach
            S.dolphinStartY = nil
            S.dolphinPhase = "RISING"
        end
    end
    
    -- Clear resurface mode when head exits water (air refills above)
    if S.resurfaceMode and not S.headInWater then
        S.resurfaceMode = false
        S.emergencyResurface = false
        S.resurfaceStartTime = 0
        -- Reset dolphin dive state for next time
        S.dolphinStartY = nil
        S.dolphinPhase = "RISING"
    end
end

-- =====================================================
-- SECTION 17: PULSE SYSTEM (Spec Section 17)
-- =====================================================

local function initKeyState(keyCode)
    if not S.keyStates[keyCode] then
        S.keyStates[keyCode] = {
            isDown = false,
            holdEndTime = 0,
            nextRefreshTime = 0
        }
    end
end

local function pressKey(keyCode)
    pcall(function()
        VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
    end)
end

local function releaseKey(keyCode)
    pcall(function()
        VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
    end)
end

local function pulseKey(keyCode, profile)
    initKeyState(keyCode)
    local state = S.keyStates[keyCode]
    local now = tick()
    
    if not state.isDown then
        -- Start pulse
        pressKey(keyCode)
        state.isDown = true
        state.holdEndTime = now + profile.HOLD_DURATION
        state.nextRefreshTime = now + profile.REFRESH_INTERVAL
    else
        -- Refresh if needed
        if now >= state.nextRefreshTime then
            pressKey(keyCode)
            state.nextRefreshTime = now + profile.REFRESH_INTERVAL
        end
        -- Extend hold time
        state.holdEndTime = now + profile.HOLD_DURATION
    end
end

local function clearKey(keyCode)
    initKeyState(keyCode)
    local state = S.keyStates[keyCode]
    if state.isDown then
        releaseKey(keyCode)
        state.isDown = false
        state.holdEndTime = 0
        state.nextRefreshTime = 0
    end
end

local function updateKeyStates()
    local now = tick()
    for keyCode, state in pairs(S.keyStates) do
        if state.isDown and now >= state.holdEndTime then
            -- Key held past its duration, release
            releaseKey(keyCode)
            state.isDown = false
        end
    end
end

local function stopAllMovementKeys()
    local movementKeys = {
        Enum.KeyCode.W, Enum.KeyCode.S,
        Enum.KeyCode.A, Enum.KeyCode.D,
        Enum.KeyCode.Space
    }
    for _, keyCode in ipairs(movementKeys) do
        clearKey(keyCode)
    end
end

-- =====================================================
-- SECTION 9: LINE OF SIGHT SYSTEM (Spec Section 9)
-- =====================================================

local cachedRaycastFilter = nil
local lastFilterBuild = 0

local function getRaycastFilter()
    local now = tick()
    if cachedRaycastFilter and (now - lastFilterBuild) < 0.25 then
        return cachedRaycastFilter
    end
    
    local filterList = {
        workspace:FindFirstChild("Characters"),
        player.Character,
        S.targetPlayer and getChar(S.targetPlayer)
    }
    
    -- Add trees
    local world = workspace:FindFirstChild("World")
    if world then
        local trunks = world:FindFirstChild("Trunks")
        if trunks then
            for _, tree in ipairs(trunks:GetChildren()) do
                table.insert(filterList, tree)
            end
        end
    end
    
    lastFilterBuild = now
    cachedRaycastFilter = filterList
    return filterList
end

-- 9.2 Single Ray LOS
local function hasLineOfSight(from, to)
    if not from or not to or not isValidVector(from) or not isValidVector(to) then
        return false
    end
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = getRaycastFilter()
    
    local result = workspace:Raycast(from, to - from, raycastParams)
    if not result then return true end
    
    -- Still clear if hit within 5 studs of target
    return (result.Position - to).Magnitude < 5
end

-- River-aware LOS offsets (lift rays above waterline clutter)
local RIVER_LOS_FROM_OFFSET = 4  -- Lift alt origin by this much
local RIVER_LOS_TO_OFFSET = 2    -- Lift target by this much

local function shouldApplyRiverLOSOffset()
    -- Apply offset when in river context OR when either character is in water
    if S.riverMethodActive then return true end
    if S.waterState == "SURFACE" or S.waterState == "UNDERWATER" then return true end
    return false
end

local function getRiverAdjustedPositions(myPos, targetPos)
    if not shouldApplyRiverLOSOffset() then
        return myPos, targetPos
    end
    
    local adjustedFrom = myPos + Vector3.new(0, RIVER_LOS_FROM_OFFSET, 0)
    local adjustedTo = targetPos + Vector3.new(0, RIVER_LOS_TO_OFFSET, 0)
    return adjustedFrom, adjustedTo
end

-- 9.3 Cylindrical LOS (River-Aware)
local function hasCompleteLineOfSight(myRoot, tgtRoot)
    if not myRoot or not tgtRoot then return false end
    
    local myPos = myRoot.Position
    local targetPos = tgtRoot.Position
    
    if not isValidVector(myPos) or not isValidVector(targetPos) then
        return false
    end
    
    -- Apply river-aware offset to avoid waterline/bank false positives
    myPos, targetPos = getRiverAdjustedPositions(myPos, targetPos)
    
    local direction = targetPos - myPos
    local distance = direction.Magnitude
    
    if distance < 5 then return true end
    if distance < 1e-6 then return true end -- Guard against zero vector
    
    local unitDir = safeUnit(direction)
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = getRaycastFilter()
    
    -- Get perpendicular vectors for cylinder
    local upVector = Vector3.new(0, 1, 0)
    local rightVector = unitDir:Cross(upVector)
    if rightVector.Magnitude < 0.1 then
        rightVector = unitDir:Cross(Vector3.new(1, 0, 0))
    end
    rightVector = safeUnit(rightVector)
    local upPerp = rightVector:Cross(unitDir)
    upPerp = safeUnit(upPerp)
    
    -- Cast 20 rays in a cylinder pattern
    local rayCount = CONFIG.LINE_OF_SIGHT_RAYS
    local radius = CONFIG.CYLINDER_RADIUS
    local passedRays = 0
    
    for i = 0, rayCount - 1 do
        local angle = (i / rayCount) * math.pi * 2
        local offset = (rightVector * math.cos(angle) + upPerp * math.sin(angle)) * radius
        local startPos = myPos + offset
        local endPos = targetPos + offset
        
        local result = workspace:Raycast(startPos, endPos - startPos, raycastParams)
        if not result then
            passedRays = passedRays + 1
        elseif (result.Position - endPos).Magnitude < 5 then
            passedRays = passedRays + 1
        end
    end
    
    -- Pass if at least ONE ray reaches target
    return passedRays >= 1
end

-- =====================================================
-- SECTION 10: SHIELD SYSTEM (Spec Section 10)
-- =====================================================

local function hasMarkerChild(hitPart, markerName)
    if not hitPart then return false end
    if hitPart:FindFirstChild(markerName) then
        return true
    end
    local parent = hitPart.Parent
    if parent and parent:FindFirstChild(markerName) then
        return true
    end
    return false
end

local function getShieldParts()
    local world = workspace:FindFirstChild("World")
    return world and world:FindFirstChild("ShieldParts")
end

-- 10.2 Flyro Shield Detection (Dual-Signal)
-- Signal A: Ray from alt to target hits shield
-- Signal B: Ray above target hits shield (Forceshield)
local function isInFlyroShield(targetPos)
    if not targetPos or not isValidVector(targetPos) then return false end
    
    local myPos = getMyPosition()
    if not myPos then return false end
    
    local shieldParts = getShieldParts()
    if not shieldParts then return false end
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Whitelist
    raycastParams.FilterDescendantsInstances = {shieldParts}
    
    -- Signal A: Does ray from alt to target hit a Flyro shield?
    local dirToTarget = targetPos - myPos
    local resultA = workspace:Raycast(myPos, dirToTarget, raycastParams)
    local signalA = resultA and hasMarkerChild(resultA.Instance, "Forceshield")
    
    -- Signal B: Is there a Forceshield above the target?
    local resultB = workspace:Raycast(targetPos, Vector3.new(0, 50, 0), raycastParams)
    local signalB = resultB and hasMarkerChild(resultB.Instance, "Forceshield")
    
    -- Both signals must detect Flyro shield
    return signalA and signalB
end

local function checkShieldBlocking(fromPos, toPos)
    if not fromPos or not toPos then return nil end
    if not isValidVector(fromPos) or not isValidVector(toPos) then return nil end
    
    local shieldParts = getShieldParts()
    if not shieldParts then return nil end
    
    local dir = toPos - fromPos
    if dir.Magnitude < 1e-6 then return nil end
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Whitelist
    raycastParams.FilterDescendantsInstances = {shieldParts}
    
    local result = workspace:Raycast(fromPos, dir, raycastParams)
    if result and result.Instance then
        if hasMarkerChild(result.Instance, "Forceshield") then
            return "FLYRO"
        elseif hasMarkerChild(result.Instance, "Telekinesis") then
            return "TELEK"
        end
    end
    return nil
end

-- 10.3 Attack Permission
local function canGrabTarget(myPos, targetPos)
    -- Check Flyro dome
    if isInFlyroShield(targetPos) then
        S.telekBlockStartTime = 0
        return false, "FLYRO_DOME"
    end
    
    -- Check path blocking
    local shieldType = checkShieldBlocking(myPos, targetPos)
    if shieldType == "FLYRO" then
        S.telekBlockStartTime = 0
        return false, "FLYRO_BLOCKED"
    elseif shieldType == "TELEK" then
        local now = tick()
        
        if S.telekBlockStartTime == 0 then
            S.telekBlockStartTime = now
            S.lastTelekRollTime = now
        end
        
        -- 20% chance per second
        if now - S.lastTelekRollTime >= 1.0 then
            S.lastTelekRollTime = now
            if math.random() < CONFIG.TELEK_GRAB_CHANCE then
                S.telekBlockStartTime = 0
                return true, "TELEK_THROUGH"
            end
        end
        
        return false, "TELEK_BLOCKED"
    end
    
    -- Clear
    S.telekBlockStartTime = 0
    return true, "CLEAR"
end

-- =====================================================
-- SECTION 11: TARGET AVAILABILITY (Spec Section 11)
-- =====================================================

-- Hit Classification Types: TERRAIN | BOULDER | SHIELD | TREE | STRUCTURE | NONE
-- TERRAIN = actual terrain voxels
-- BOULDER = rocks/boulders that can trap players
-- SHIELD = force shields
-- TREE = trees (ignored for availability)
-- STRUCTURE = bridges, roofs, buildings (ignored for availability)
-- NONE = no hit

local function classifyRaycastHit(result)
    if not result then
        return {
            hitClass = "NONE",
            hitInstance = nil,
            hitPosition = nil,
            hitDistance = 0
        }
    end
    
    local instance = result.Instance
    local hitInfo = {
        hitInstance = instance,
        hitPosition = result.Position,
        hitDistance = 0  -- Will be calculated by caller with proper origin
    }
    
    -- Classify the hit
    if instance:IsA("Terrain") then
        hitInfo.hitClass = "TERRAIN"
    else
        local parent = instance.Parent
        local grandparent = parent and parent.Parent
        local nameLower = instance.Name:lower()
        local parentNameLower = parent and parent.Name:lower() or ""
        
        -- Check if it's a tree (in World/Trunks or has tree-like name)
        local isInTrunks = (parent and parent.Name == "Trunks") or 
                          (grandparent and grandparent.Name == "Trunks")
        local hasTreeName = nameLower:find("tree") or 
                           nameLower:find("trunk") or
                           nameLower:find("leaf") or
                           nameLower:find("branch")
        
        if isInTrunks or hasTreeName then
            hitInfo.hitClass = "TREE"
        
        -- Check if it's a shield
        elseif (parent and parent.Name == "ShieldParts") or 
               (grandparent and grandparent.Name == "ShieldParts") or
               nameLower:find("shield") or
               nameLower:find("forceshield") then
            hitInfo.hitClass = "SHIELD"
        
        -- Check if it's a boulder (rocks that can trap players)
        elseif nameLower:find("boulder") or 
               nameLower:find("rock") or
               nameLower:find("stone") or
               parentNameLower:find("boulder") or
               parentNameLower:find("rock") then
            hitInfo.hitClass = "BOULDER"
        
        else
            -- Everything else is a structure (bridges, roofs, buildings) - ignored
            hitInfo.hitClass = "STRUCTURE"
        end
    end
    
    return hitInfo
end

-- Perform classified raycast
local function classifiedRaycast(origin, direction, filterList)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = filterList or {}
    
    local result = workspace:Raycast(origin, direction, raycastParams)
    local hitInfo = classifyRaycastHit(result)
    
    -- Calculate proper distance (use RaycastResult.Distance if available)
    if result then
        hitInfo.hitDistance = result.Distance or (result.Position - origin).Magnitude
    end
    
    return hitInfo
end

local function isTargetAvailable(plr)
    local targetPlayer = plr or S.targetPlayer
    if not targetPlayer then return false, "NO_TARGET" end
    
    local targetChar = getChar(targetPlayer)
    local targetHead = targetChar and targetChar:FindFirstChild("Head")
    if not targetHead then return false, "NO_HEAD" end
    
    local targetPos = targetHead.Position
    if not isValidVector(targetPos) then return false, "INVALID_POSITION" end
    
    -- Build filter (characters only - we want to detect everything else)
    local filterList = {
        workspace:FindFirstChild("Characters")
    }
    
    -- Raycast straight up from target head with classification
    local upHit = classifiedRaycast(targetPos, Vector3.new(0, 140, 0), filterList)
    
    -- Check if Flyro dome (dual-signal check)
    if isInFlyroShield(targetPos) then
        return false, "FLYRO_SHIELD"
    end
    
    -- Analyze hit classification
    -- Most classes pass through - dual-signal functions handle real blocking
    if upHit.hitClass == "NONE" then
        return true, "CLEAR"
    elseif upHit.hitClass == "TERRAIN" then
        return true, "CLEAR"  -- Let isTargetUnderMap() handle with two-signal rule
    elseif upHit.hitClass == "SHIELD" then
        return true, "CLEAR"  -- Let isInFlyroShield() handle with dual-signal
    elseif upHit.hitClass == "TREE" then
        return true, "CLEAR"  -- Trees are ignored
    elseif upHit.hitClass == "STRUCTURE" then
        return true, "CLEAR"  -- Bridges/roofs are ignored
    elseif upHit.hitClass == "BOULDER" then
        return true, "CLEAR"  -- Let isTargetInsideBoulder() handle with dual-signal
    end
    
    return true, "CLEAR"
end

-- 11.5 Under-Map Detection (Two-Signal Rule with Proper Classification)
-- BOTH signals must hit TERRAIN specifically (not bridges/trees/roofs)
-- Signal B must also pass near-ceiling guard (within 25-40 studs)
local CONFIG_UNDERMAP_CEILING_MAX = 40  -- Signal B must hit within this distance
local CONFIG_UNDERMAP_SAME_AREA_MAX = 60  -- Optional: hits must be near target

local function isTargetUnderMap()
    local myPos = getMyPosition()
    local target = S.targetPlayer  -- Use S.targetPlayer directly (getCurrentTarget not defined yet)
    local targetHead = target and getHead(target)
    if not myPos or not targetHead then return false end
    
    local targetPos = targetHead.Position
    if not isValidVector(targetPos) then return false end
    
    -- Build filter (characters and shields - we're looking for terrain)
    local filterList = { workspace:FindFirstChild("Characters") }
    local shieldParts = getShieldParts()
    if shieldParts then table.insert(filterList, shieldParts) end
    
    -- Apply river-aware offset to Signal A ONLY (not Signal B vertical ray)
    local signalAFrom, signalATo = myPos, targetPos
    if shouldApplyRiverLOSOffset() then
        signalAFrom = myPos + Vector3.new(0, RIVER_LOS_FROM_OFFSET, 0)
        signalATo = targetPos + Vector3.new(0, RIVER_LOS_TO_OFFSET, 0)
    end
    
    -- Signal A: Check what blocks line between alt and target (river-adjusted)
    local signalA = classifiedRaycast(signalAFrom, signalATo - signalAFrom, filterList)
    
    -- Signal A must hit TERRAIN specifically
    if signalA.hitClass ~= "TERRAIN" then
        return false
    end
    
    -- Signal B: Check what's directly above target (NOT adjusted - stay true to geometry)
    local signalB = classifiedRaycast(targetPos, Vector3.new(0, 140, 0), filterList)
    
    -- Signal B must hit TERRAIN specifically
    if signalB.hitClass ~= "TERRAIN" then
        return false
    end
    
    -- Near-ceiling guard: Signal B must be close (not distant terrain)
    if signalB.hitDistance > CONFIG_UNDERMAP_CEILING_MAX then
        return false
    end
    
    -- Optional: Same-area sanity check
    -- Both hits should be spatially consistent with target area
    if signalA.hitPosition and signalB.hitPosition then
        local distA = (signalA.hitPosition - targetPos).Magnitude
        local distB = (signalB.hitPosition - targetPos).Magnitude
        
        -- If either hit is very far from target, might be unrelated obstruction
        if distA > CONFIG_UNDERMAP_SAME_AREA_MAX and distB > CONFIG_UNDERMAP_SAME_AREA_MAX then
            return false
        end
    end
    
    -- Both signals hit TERRAIN, Signal B is close = under-map confirmed
    return true
end

-- 11.5.2 Inside-Boulder Detection (Dual-Signal)
-- Signal A: Ray from alt to target hits BOULDER
-- Signal B: Ray above target hits BOULDER within threshold
local function isTargetInsideBoulder()
    local target = S.targetPlayer
    local targetHead = target and getHead(target)
    if not targetHead then return false end
    
    local myPos = getMyPosition()
    if not myPos then return false end
    
    local targetPos = targetHead.Position
    
    -- Build filter (characters only - detect everything else)
    local filterList = { workspace:FindFirstChild("Characters") }
    
    -- Signal A: Does ray from alt to target hit a BOULDER?
    local signalA = classifiedRaycast(myPos, targetPos - myPos, filterList)
    if signalA.hitClass ~= "BOULDER" then
        return false
    end
    
    -- Signal B: Is there a BOULDER above the target within threshold?
    local signalB = classifiedRaycast(targetPos, Vector3.new(0, CONFIG.INSIDE_BOULDER_THRESHOLD, 0), filterList)
    if signalB.hitClass ~= "BOULDER" then
        return false
    end
    
    -- Near-ceiling guard: Signal B must be close
    if signalB.hitDistance > CONFIG.INSIDE_BOULDER_THRESHOLD then
        return false
    end
    
    -- Both signals hit BOULDER = inside boulder confirmed
    return true
end

-- =====================================================
-- SECTION 11.1: INVISIBILITY HANDLING (Spec Section 12.1)
-- =====================================================

local function isTargetInvisible(plr)
    if not plr then return false end
    
    -- Check workspace Characters flag
    local chars = workspace:FindFirstChild("Characters")
    if chars then
        local targetChar = chars:FindFirstChild(plr.Name)
        if targetChar then
            local invisible = targetChar:FindFirstChild("Invisible")
            if invisible and invisible:IsA("BoolValue") and invisible.Value then
                return true
            end
        end
    end
    
    -- Check for missing parts
    local targetChar = getChar(plr)
    if not targetChar then return true end
    if not targetChar:FindFirstChild("Head") then return true end
    if not getRoot(plr) then return true end
    
    return false
end

local function updateInvisibilityState(plr)
    local invisible = isTargetInvisible(plr or S.targetPlayer)
    local now = tick()
    
    if invisible then
        if not S.targetWasInvisible then
            S.targetInvisibleStartTime = now
        end
        S.targetWasInvisible = true
        
        -- Check grace window
        if (now - S.targetInvisibleStartTime) > CONFIG.INVISIBILITY_GRACE_WINDOW then
            return true -- Truly invisible
        end
    else
        S.targetWasInvisible = false
        S.targetInvisibleStartTime = 0
    end
    
    return false
end

-- =====================================================
-- SECTION 20: NO-CHASE ZONES (Spec Section 20.0)
-- =====================================================

local function isInHouseNoChase(pos)
    if not pos then return false end
    local hDist = math.sqrt((pos.X - CONFIG.HOUSE_CENTER.X)^2 + (pos.Z - CONFIG.HOUSE_CENTER.Z)^2)
    return hDist <= CONFIG.HOUSE_RADIUS and pos.Y <= CONFIG.HOUSE_Y_MAX
end

local function isInTowerNoChase(pos)
    if not pos then return false end
    if pos.Y < CONFIG.TOWER_TARGET_Y_IN then return false end
    
    for _, center in ipairs(CONFIG.TOWER_CENTERS) do
        local hDist = math.sqrt((pos.X - center.X)^2 + (pos.Z - center.Z)^2)
        if hDist <= CONFIG.TOWER_RADIUS then
            return true
        end
    end
    return false
end

local function isInNoChaseZone(pos)
    return isInHouseNoChase(pos) or isInTowerNoChase(pos)
end

-- =====================================================
-- SECTION 20.1: STRUCTURE-TRAPPED CLASSIFIER
-- =====================================================

local function updateStructureTrapped()
    local targetPos = getTargetPosition()
    local myPos = getMyPosition()
    
    -- Check no-chase zones
    if isInNoChaseZone(targetPos) then
        S.targetAvailable = false
        S.unavailableReason = "NO_CHASE_ZONE"
        return true
    end
    
    -- Check availability
    local available, reason = isTargetAvailable()
    if not available then
        S.targetAvailable = false
        S.unavailableReason = reason
        return true
    end
    
    -- Check under-map
    if isTargetUnderMap() then
        S.targetAvailable = false
        S.unavailableReason = "UNDER_MAP"
        return true
    end
    
    -- Check inside boulder
    if isTargetInsideBoulder() then
        S.targetAvailable = false
        S.unavailableReason = "INSIDE_BOULDER"
        return true
    end
    
    -- Check invisibility
    if updateInvisibilityState() then
        S.targetAvailable = false
        S.unavailableReason = "INVISIBLE"
        return true
    end
    
    -- Check persistent LOS failure (STRUCTURE_TRAPPED - Dual Signal)
    -- Signal A: LOS blocked for 1.5+ seconds
    -- Signal B: Something ABOVE target (STRUCTURE class, not terrain/tree)
    -- This prevents false positives when target is on a different hill
    local myRoot = getRoot(player)
    local targetRoot = getRoot(S.targetPlayer)
    if myRoot and targetRoot then
        if not hasCompleteLineOfSight(myRoot, targetRoot) then
            local now = tick()
            if S.lastLOSFailTime == 0 then
                S.lastLOSFailTime = now
            elseif (now - S.lastLOSFailTime) > CONFIG.PERSISTENT_NO_LOS_THRESHOLD then
                -- Check if target position changed little
                if S.lastKnownPosition then
                    local posDiff = (targetPos - S.lastKnownPosition).Magnitude
                    if posDiff < 12 then
                        -- Signal A passed (LOS blocked, target stationary)
                        -- Now check Signal B: Is there a STRUCTURE above target?
                        local filterList = { workspace:FindFirstChild("Characters") }
                        local aboveHit = classifiedRaycast(targetPos, Vector3.new(0, 50, 0), filterList)
                        
                        -- Only trigger STRUCTURE_TRAPPED if there's actually a structure above
                        -- NOT terrain (that's just hills), NOT trees (ignored)
                        if aboveHit.hitClass == "STRUCTURE" or aboveHit.hitClass == "BOULDER" then
                            S.targetAvailable = false
                            S.unavailableReason = "STRUCTURE_TRAPPED"
                            return true
                        end
                        -- If it's terrain or nothing above, don't mark as trapped
                        -- (Target is probably just on a different hill)
                    end
                end
            end
        else
            S.lastLOSFailTime = 0
        end
    end
    
    S.targetAvailable = true
    S.unavailableReason = nil
    return false
end

-- =====================================================
-- SECTION 19: MAP BOUNDARY SYSTEM (Spec Section 19)
-- =====================================================

local function updateBoundaryState(myPos)
    if not myPos then return end
    
    local buffer = CONFIG.MAP_BOUNDARY_BUFFER
    
    S.nearBoundary = myPos.X < CONFIG.MAP_X_MIN + buffer or
                     myPos.X > CONFIG.MAP_X_MAX - buffer or
                     myPos.Z < CONFIG.MAP_Z_MIN + buffer or
                     myPos.Z > CONFIG.MAP_Z_MAX - buffer
    
    S.outsideBoundary = myPos.X < CONFIG.MAP_X_MIN or
                        myPos.X > CONFIG.MAP_X_MAX or
                        myPos.Z < CONFIG.MAP_Z_MIN or
                        myPos.Z > CONFIG.MAP_Z_MAX
end

local function getBoundaryReturnDirection(myPos)
    local centerX = (CONFIG.MAP_X_MIN + CONFIG.MAP_X_MAX) / 2
    local centerZ = (CONFIG.MAP_Z_MIN + CONFIG.MAP_Z_MAX) / 2
    local toCenter = Vector3.new(centerX - myPos.X, 0, centerZ - myPos.Z)
    return safeUnit(toCenter)
end

-- =====================================================
-- FLIGHT CONTROL
-- =====================================================

local function hasFlight()
    local chars = workspace:FindFirstChild("Characters")
    if not chars then return false end
    local myChar = chars:FindFirstChild(player.Name)
    if not myChar then return false end
    local root = myChar:FindFirstChild("HumanoidRootPart")
    return root and root:FindFirstChild("TelekinesisFlight") ~= nil
end

local function toggleFlight()
    local now = tick()
    if now - S.lastFlightToggle < CONFIG.FLIGHT_TOGGLE_COOLDOWN then return end
    S.lastFlightToggle = now
    
    task.spawn(function()
        pcall(function()
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game)
            task.wait(0.05)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, game)
        end)
    end)
end

local function manageFlightStamina()
    local stamina = getStamina()
    if not stamina then return end
    
    local effectiveMin = getEffectiveStaminaMin()
    local effectiveRecharge = getEffectiveStaminaRecharge()
    local currentlyFlying = hasFlight()
    
    if stamina <= effectiveMin and currentlyFlying then
        toggleFlight()
        S.flightDisabledForStamina = true
    elseif stamina >= effectiveRecharge and S.flightDisabledForStamina and not currentlyFlying then
        toggleFlight()
        S.flightDisabledForStamina = false
    end
end

local function ensureFlight()
    if S.flightDisabledForStamina then return false end
    local stamina = getStamina()
    if stamina and stamina <= getEffectiveStaminaMin() then return false end
    if not hasFlight() then toggleFlight() end
    return hasFlight()
end

local function disableFlight()
    if hasFlight() then toggleFlight() end
end

-- =====================================================
-- SECTION 18.1.1: GROUND CLEARANCE CHECK
-- =====================================================

local function getGroundClearance(myPos)
    if not myPos then return 999 end
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local filterList = { workspace:FindFirstChild("Characters") }
    local world = workspace:FindFirstChild("World")
    if world then
        local trunks = world:FindFirstChild("Trunks")
        if trunks then table.insert(filterList, trunks) end
    end
    raycastParams.FilterDescendantsInstances = filterList
    
    local origin = myPos + Vector3.new(0, 2, 0)
    local result = workspace:Raycast(origin, Vector3.new(0, -CONFIG.CLEARANCE_RAY_DIST, 0), raycastParams)
    
    if result then
        return result.Distance
    end
    return CONFIG.CLEARANCE_RAY_DIST
end

-- =====================================================
-- SECTION 18: FLIGHT MOVEMENT (Arc vs Slope)
-- =====================================================

local function updateSteeringMode(hDist)
    -- Hysteresis to prevent flicker
    if S.steeringMode == "SLOPE" and hDist >= CONFIG.ARC_ENTER_DISTANCE then
        S.steeringMode = "ARC"
    elseif S.steeringMode == "ARC" and hDist <= CONFIG.SLOPE_ENTER_DISTANCE then
        S.steeringMode = "SLOPE"
    end
end

local function getAngledFlightDirection(myPos, targetPos)
    -- Guard against nil
    if not myPos or not targetPos then
        return Vector3.new(0, 0, 1), "FALLBACK"
    end
    
    local fullVector = targetPos - myPos
    local horizontalDir = Vector3.new(fullVector.X, 0, fullVector.Z)
    local horizontalDist = horizontalDir.Magnitude
    local verticalDiff = targetPos.Y - myPos.Y
    local absVerticalDiff = math.abs(verticalDiff)
    
    if horizontalDist < 1 then
        horizontalDir = Vector3.new(1, 0, 0)
        horizontalDist = 1
    end
    local horizontalUnit = safeUnit(horizontalDir)
    
    -- Check ground clearance before allowing descent
    local clearance = getGroundClearance(myPos)
    local canDescend = clearance > CONFIG.CLEARANCE_MIN
    local softDescend = clearance > CONFIG.CLEARANCE_SOFT
    
    if absVerticalDiff < CONFIG.SMALL_HEIGHT_CHANGE then
        return horizontalUnit, "HORIZONTAL"
    end
    
    if absVerticalDiff > CONFIG.MAX_VERTICAL_SEPARATION then
        if verticalDiff > 0 then
            return safeUnit(horizontalUnit * 0.4 + Vector3.new(0, 0.9, 0)), "STEEP_UP"
        else
            if not canDescend then
                return horizontalUnit, "CLEARANCE_BLOCK"
            end
            return safeUnit(horizontalUnit * 0.4 + Vector3.new(0, -0.9, 0)), "STEEP_DOWN"
        end
    end
    
    local verticalRatio = CONFIG.ANGLED_FLIGHT_RATIO
    if verticalDiff < 0 then
        if not canDescend then
            verticalRatio = 0
        elseif not softDescend then
            verticalRatio = -0.2 -- Reduced descent
        else
            verticalRatio = -CONFIG.ANGLED_FLIGHT_RATIO
        end
    end
    
    local angledDirection = safeUnit(horizontalUnit + Vector3.new(0, verticalRatio, 0))
    return angledDirection, "ANGLED"
end

local function getCurveDirection(myPos, targetPos, velocity)
    -- Guard against nil
    if not myPos or not targetPos or not velocity then
        return "STRAIGHT", 0
    end
    
    if velocity.Magnitude < CONFIG.CURVE_MIN_VELOCITY then
        return "STRAIGHT", 0
    end
    
    local toTarget = Vector3.new((targetPos - myPos).X, 0, (targetPos - myPos).Z)
    if toTarget.Magnitude < 1 then return "STRAIGHT", 0 end
    
    local velDir = Vector3.new(velocity.X, 0, velocity.Z)
    if velDir.Magnitude < 1 then return "STRAIGHT", 0 end
    
    local velU = safeUnit(velDir)
    local tgtU = safeUnit(toTarget)
    local cross = velU:Cross(tgtU)
    
    if cross.Y > CONFIG.CURVE_THRESHOLD then
        return "RIGHT", cross.Y
    elseif cross.Y < -CONFIG.CURVE_THRESHOLD then
        return "LEFT", cross.Y
    end
    return "STRAIGHT", cross.Y
end

-- =====================================================
-- SECTION 19.3: STUCK DETECTION
-- =====================================================

local function isVelocityStuck(velocity)
    return math.abs(velocity.X) <= CONFIG.STUCK_VELOCITY_THRESHOLD
       and math.abs(velocity.Y) <= CONFIG.STUCK_VELOCITY_THRESHOLD
       and math.abs(velocity.Z) <= CONFIG.STUCK_VELOCITY_THRESHOLD
end

local function updateStuckDetection(myPos, dt)
    local now = tick()
    
    if S.lastPosition and S.lastPositionTime > 0 then
        local timeDelta = now - S.lastPositionTime
        if timeDelta > 1 then
            S.stuckTimer = 0
            S.lastPosition = myPos
            S.lastPositionTime = now
            return 0
        end
        if timeDelta > 0 then
            local velocity = (myPos - S.lastPosition) / timeDelta
            if isVelocityStuck(velocity) then
                S.stuckTimer = S.stuckTimer + dt
            else
                S.stuckTimer = 0
            end
        end
    end
    
    S.lastPosition = myPos
    S.lastPositionTime = now
    return S.stuckTimer
end

local function scanForAlternativePath(myPos, targetPos)
    local toTarget = safeUnit(targetPos - myPos, Vector3.new(0, 1, 0))
    local numPoints = CONFIG.UNSTUCK_SCAN_POINTS
    local goldenRatio = (1 + math.sqrt(5)) / 2
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {
        workspace:FindFirstChild("Characters"),
        player.Character,
        S.targetPlayer and getChar(S.targetPlayer)
    }
    
    local bestDirection = nil
    local bestScore = -math.huge
    
    -- DISK SCAN (XZ only) per Section 21.1
    for i = 0, numPoints - 1 do
        local theta = 2 * math.pi * i / numPoints
        local x = math.cos(theta)
        local z = math.sin(theta)
        local dir = Vector3.new(x, 0, z) -- No vertical component
        
        local result = workspace:Raycast(myPos, dir * CONFIG.UNSTUCK_SCAN_DISTANCE, raycastParams)
        local clearDistance = result and (result.Position - myPos).Magnitude or CONFIG.UNSTUCK_SCAN_DISTANCE
        local dotToTarget = dir:Dot(Vector3.new(toTarget.X, 0, toTarget.Z))
        local score = clearDistance + (dotToTarget * 15)
        
        if clearDistance > 15 and score > bestScore then
            bestScore = score
            bestDirection = dir
        end
    end
    
    -- If flying and clearance is good, allow small upward bias
    if hasFlight() and not S.resurfaceMode then
        local clearance = getGroundClearance(myPos)
        if clearance > CONFIG.CLEARANCE_SOFT and bestDirection then
            bestDirection = safeUnit(bestDirection + Vector3.new(0, 0.3, 0))
        end
    end
    
    return bestDirection or Vector3.new(0, 0, 1)
end

local function startUnsticking(myPos, targetPos)
    S.isUnsticking = true
    S.unstickDirection = scanForAlternativePath(myPos, targetPos)
    S.unstickEndTime = tick() + CONFIG.UNSTUCK_DURATION
    stopAllMovementKeys()
end

local function resetStuckDetection()
    S.stuckTimer = 0
    S.lastPosition = nil
    S.lastPositionTime = 0
    S.isUnsticking = false
    S.unstickDirection = nil
    S.unstickEndTime = 0
end

-- =====================================================
-- MOUSE HELPERS
-- =====================================================

local function getScreenCenter()
    local viewportSize = Camera.ViewportSize
    return viewportSize.X / 2, viewportSize.Y / 2
end

local function moveMouseToCenter()
    pcall(function()
        local cx, cy = getScreenCenter()
        VirtualInputManager:SendMouseMoveEvent(cx, cy, game)
    end)
end

local function sendClickAt(x, y)
    pcall(function()
        VirtualInputManager:SendMouseButtonEvent(x, y, 0, true, game, 0)
    end)
    task.wait(0.05)
    pcall(function()
        VirtualInputManager:SendMouseButtonEvent(x, y, 0, false, game, 0)
    end)
end

local function sendClickAboveCenter()
    local vp = Camera.ViewportSize
    local cx, cy = vp.X / 2, vp.Y / 2
    local clickY = math.max(10, cy - CONFIG.CLICK_ABOVE_OFFSET)
    sendClickAt(cx, clickY)
end

local function sendClickBelowCenter()
    local vp = Camera.ViewportSize
    local cx, cy = vp.X / 2, vp.Y / 2
    local clickY = math.min(vp.Y - 10, cy + CONFIG.CLICK_BELOW_OFFSET)
    sendClickAt(cx, clickY)
end

-- =====================================================
-- SECTION 8: SAFE RESURFACE (Spec Section 8)
-- =====================================================

-- Dolphin Dive: Flight-based parabolic arc out of water
-- When we have stamina, fly UP and OUT in an arc, get air while airborne,
-- gravity brings us back down into water. Looks like upside-down parabola.
--
-- Arc pattern:
--                Peak (max ~25 studs above water)
--               /    \
--              /      \   gravity pulls back
--             /        \
-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  water surface
--           /            \
--      Start              Re-enter
--
local function performDolphinDive()
    local myRoot = getRoot(player)
    if not myRoot then return end
    
    local myPos = myRoot.Position
    local targetPos = getTargetPosition()
    
    -- Initialize dolphin start Y on first frame
    if not S.dolphinStartY then
        S.dolphinStartY = myPos.Y
        S.dolphinPhase = "RISING"
    end
    
    local heightAboveStart = myPos.Y - S.dolphinStartY
    
    -- Direction toward target (horizontal)
    local toTarget = Vector3.new(0, 0, 1)  -- Default forward
    if targetPos then
        local horizDir = Vector3.new(targetPos.X - myPos.X, 0, targetPos.Z - myPos.Z)
        if horizDir.Magnitude > 1 then
            toTarget = safeUnit(horizDir)
        end
    end
    
    local flyDir
    
    if S.dolphinPhase == "RISING" then
        -- RISING: Fly up and forward until we reach max height or head exits water
        if heightAboveStart >= CONFIG.DOLPHIN_MAX_HEIGHT then
            -- Reached peak - transition to falling
            S.dolphinPhase = "FALLING"
        elseif not S.headInWater and heightAboveStart >= 5 then
            -- Head is out and we've risen at least 5 studs - good enough, start falling
            S.dolphinPhase = "FALLING"
        end
        
        if S.dolphinPhase == "RISING" then
            -- Still rising: strong upward + forward
            if S.emergencyResurface then
                -- Emergency: Go nearly straight up!
                flyDir = safeUnit(toTarget * 0.2 + Vector3.new(0, 0.95, 0))
            else
                -- Normal: Steeper angle when deeper, shallower near peak
                local upRatio = math.max(0.5, 0.9 - (heightAboveStart / CONFIG.DOLPHIN_MAX_HEIGHT) * 0.4)
                flyDir = safeUnit(toTarget * (1 - upRatio) + Vector3.new(0, upRatio, 0))
            end
        end
    end
    
    if S.dolphinPhase == "FALLING" then
        -- FALLING: Aim toward target (slightly downward), let gravity complete arc
        -- The natural fall + forward momentum creates the parabola
        if targetPos then
            local fullDir = safeUnit(targetPos - myPos)
            -- Bias slightly downward to encourage re-entry
            flyDir = safeUnit(fullDir * 0.8 + Vector3.new(0, -0.3, 0))
        else
            flyDir = safeUnit(toTarget * 0.7 + Vector3.new(0, -0.5, 0))
        end
    end
    
    if flyDir then
        Camera.CFrame = CFrame.lookAt(myPos, myPos + flyDir * 50)
    end
    
    -- Flight is what creates the arc momentum
    ensureFlight()
    pulseKey(Enum.KeyCode.W, CONFIG.PULSE_W)
    
    -- In emergency, also pulse Space for extra vertical lift
    if S.emergencyResurface and S.dolphinPhase == "RISING" then
        pulseKey(Enum.KeyCode.Space, { HOLD_DURATION = 0.3, REFRESH_INTERVAL = 0.1 })
    end
end

-- Reset dolphin state when resurface ends
local function resetDolphinState()
    S.dolphinStartY = nil
    S.dolphinPhase = "RISING"
end

-- Simple Resurface: No-flight swim to surface (when out of stamina)
-- Just hold Space to float up
local function performSimpleResurface()
    local myRoot = getRoot(player)
    if not myRoot then return end
    
    local myPos = myRoot.Position
    
    -- Hold Space to swim upward
    pulseKey(Enum.KeyCode.Space, CONFIG.PULSE_SPACE_RESURFACE)
    
    -- In emergency, aim straight up; otherwise aim toward target
    if S.emergencyResurface then
        -- Emergency: Look UP to maximize vertical movement
        Camera.CFrame = CFrame.lookAt(myPos, myPos + Vector3.new(0, 50, 0))
    else
        -- Normal: Maintain some forward momentum toward target
        local targetPos = getTargetPosition()
        if targetPos then
            local toTarget = safeUnit(Vector3.new(targetPos.X - myPos.X, 0, targetPos.Z - myPos.Z))
            -- Aim mostly up with slight forward
            Camera.CFrame = CFrame.lookAt(myPos, myPos + safeUnit(toTarget * 0.3 + Vector3.new(0, 0.9, 0)) * 50)
        else
            Camera.CFrame = CFrame.lookAt(myPos, myPos + Vector3.new(0, 50, 0))
        end
    end
    
    pulseKey(Enum.KeyCode.W, { HOLD_DURATION = 0.5, REFRESH_INTERVAL = 0.1 })
end

-- Main resurface dispatcher - chooses dolphin dive or simple based on stamina
local function performSafeResurface()
    local stamina = getStamina()
    local canFly = stamina and stamina > getEffectiveStaminaMin()
    
    if canFly and not S.flightDisabledForStamina then
        -- Have stamina  dolphin dive (flight arc)
        performDolphinDive()
    else
        -- No stamina  simple swim resurface
        resetDolphinState()  -- Clear any partial dolphin state
        performSimpleResurface()
    end
end

-- =====================================================
-- SECTION 13: SECONDARY TARGET SYSTEM (Spec Section 13)
-- =====================================================

local function isSecondaryTargetById(userId)
    for i, uid in ipairs(S.secondaryTargetUserIds) do
        if uid == userId then return true, i end
    end
    return false, 0
end

local function getPlayerByUserId(userId)
    for _, plr in pairs(Players:GetPlayers()) do
        if plr.UserId == userId then return plr end
    end
    return nil
end

local function addSecondaryTarget(plr)
    if not plr then return false end
    if S.targetPlayer and plr.UserId == S.targetPlayer.UserId then return false end
    if isSecondaryTargetById(plr.UserId) then return false end
    if #S.secondaryTargetUserIds >= S.MAX_SECONDARY_TARGETS then
        print("Max secondary targets reached")
        return false
    end
    table.insert(S.secondaryTargetUserIds, plr.UserId)
    print("Added secondary target: " .. plr.Name)
    return true
end

local function removeSecondaryTarget(plr)
    if not plr then return false end
    local exists, index = isSecondaryTargetById(plr.UserId)
    if exists then
        table.remove(S.secondaryTargetUserIds, index)
        print("Removed secondary target: " .. plr.Name)
        return true
    end
    return false
end

local function toggleSecondaryTarget(plr)
    if not plr then return end
    if isSecondaryTargetById(plr.UserId) then
        removeSecondaryTarget(plr)
    else
        addSecondaryTarget(plr)
    end
end

local function clearSecondaryTargets()
    S.secondaryTargetUserIds = {}
    S.activeSecondaryUserId = nil
    S.onSecondaryTarget = false
end

local function getEligibleSecondary(myPos)
    -- Section 13.4 eligibility rules
    for _, userId in ipairs(S.secondaryTargetUserIds) do
        local plr = getPlayerByUserId(userId)
        if plr and plr.Parent then
            local root = getRoot(plr)
            if root and isValidVector(root.Position) then
                local dist = (root.Position - myPos).Magnitude
                if dist <= CONFIG.SECONDARY_TARGET_RANGE then
                    if isPlayerAlive(plr) then
                        -- Check not in no-chase zone
                        if not isInNoChaseZone(root.Position) then
                            return plr
                        end
                    end
                end
            end
        end
    end
    return nil
end

local function updateSecondaryTargetLogic(myPos)
    -- Section 13.3: Only run if primary not fightable
    local primaryFightable = S.targetPlayer and isTargetAlive() and S.targetAvailable
    
    if primaryFightable then
        -- Drop secondary immediately
        if S.onSecondaryTarget then
            stopAllMovementKeys()
            S.onSecondaryTarget = false
            S.activeSecondaryUserId = nil
            print("Primary available - returning from secondary")
        end
        return
    end
    
    -- Section 13.3: Don't run during special modes
    if S.resurfaceMode or S.emergencyResurface then return end
    if S.currentState == "BOUNDARY_WALK" or S.currentState == "RETURNING_TO_MAP" then return end
    
    -- Find eligible secondary
    local secondary = getEligibleSecondary(myPos)
    
    if secondary then
        local now = tick()
        
        -- Section 13.5: Stickiness
        if S.onSecondaryTarget and S.activeSecondaryUserId then
            local currentSecondary = getPlayerByUserId(S.activeSecondaryUserId)
            if currentSecondary and isPlayerAlive(currentSecondary) then
                local root = getRoot(currentSecondary)
                if root then
                    local dist = (root.Position - myPos).Magnitude
                    if dist <= CONFIG.SECONDARY_TARGET_RANGE then
                        -- Keep current secondary (stickiness)
                        if (now - S.secondaryStartTime) < CONFIG.SECONDARY_DWELL_TIME then
                            return
                        end
                    end
                end
            end
        end
        
        -- Switch to secondary
        if not S.onSecondaryTarget or S.activeSecondaryUserId ~= secondary.UserId then
            stopAllMovementKeys()
            S.activeSecondaryUserId = secondary.UserId
            S.onSecondaryTarget = true
            S.secondaryStartTime = now
            print("Engaging secondary: " .. secondary.Name)
        end
    else
        if S.onSecondaryTarget then
            stopAllMovementKeys()
            S.onSecondaryTarget = false
            S.activeSecondaryUserId = nil
        end
    end
end

local function getCurrentTarget()
    if S.onSecondaryTarget and S.activeSecondaryUserId then
        return getPlayerByUserId(S.activeSecondaryUserId)
    end
    return S.targetPlayer
end

-- =====================================================
-- COMBAT EXECUTION (Section 14)
-- =====================================================

local function canAttackNow(myPos, targetPos)
    -- Prevent overlapping attacks (race condition with task.wait in executeAttack)
    if S.isAttacking then return false, "ATTACKING" end
    
    local target = getCurrentTarget()
    if not target then return false, "NO_TARGET" end
    if not isPlayerAlive(target) then return false, "TARGET_DEAD" end
    if updateInvisibilityState(target) then return false, "TARGET_INVISIBLE" end

    -- Distance check - must be in combat range
    local distance = (myPos - targetPos).Magnitude
    if distance > CONFIG.COMBAT_ZONE then
        return false, "OUT_OF_RANGE"
    end
    
    -- Availability check
    local available, reason = isTargetAvailable(target)
    if not available then return false, reason end
    
    -- Shield permission
    local canGrab, shieldReason = canGrabTarget(myPos, targetPos)
    if not canGrab then return false, shieldReason end
    
    -- LOS check (cached to reduce raycast spam)
    local now = tick()
    if now - S.lastLOSCheckTime > CONFIG.LOS_CACHE_RATE then
        S.lastLOSCheckTime = now
        local myRoot = getRoot(player)
        local targetRoot = getRoot(target)
        S.lastLOSResult = hasCompleteLineOfSight(myRoot, targetRoot)
    end
    if not S.lastLOSResult then
        return false, "NO_LOS"
    end
    
    -- On-screen check
    local screenPos, onScreen = Camera:WorldToViewportPoint(targetPos)
    if not onScreen then return false, "OFF_SCREEN" end
    
    -- Cooldown check
    local now = tick()
    if now - S.lastQClickTime < CONFIG.Q_CLICK_COOLDOWN then
        return false, "COOLDOWN"
    end
    
    return true, "CLEAR"
end

local function executeAttack(myPos, targetPos, distance)
    local canAttack, reason = canAttackNow(myPos, targetPos)
    if not canAttack then return false end
    
    local target = getCurrentTarget()
    if not target then return false end
    
    S.isAttacking = true
    S.lastQClickTime = tick()
    
    -- 1. Choose stable aim point (target head)
    local targetHead = getHead(target)
    local aimPoint = targetHead and targetHead.Position or targetPos
    if not aimPoint or not isValidVector(aimPoint) then
        S.isAttacking = false
        return false
    end
    
    -- 2. Convert to screen space
    local screenPos, onScreen = Camera:WorldToViewportPoint(aimPoint)
    if not onScreen then
        S.isAttacking = false
        return false
    end
    
    -- 3. Move mouse to aim point on screen
    pcall(function()
        VirtualInputManager:SendMouseMoveEvent(screenPos.X, screenPos.Y, game)
    end)
    task.wait(CONFIG.Q_AIM_DELAY)
    
    -- 4. Hold Q (begin grab)
    pressKey(Enum.KeyCode.Q)
    task.wait(CONFIG.Q_HOLD_BEFORE_CLICK)
    
    -- 5. Click with offset for throw direction control (Section 15)
    local vp = Camera.ViewportSize
    local clickX = screenPos.X
    local clickY = screenPos.Y
    
    if distance < CONFIG.OPTIMAL_MIN then
        -- Too close: push away (click above target)
        clickY = math.max(10, screenPos.Y - CONFIG.CLICK_ABOVE_OFFSET)
        S.throwPhase = "PUSH"
    elseif distance > CONFIG.OPTIMAL_MAX then
        -- Too far: pull toward (click below target)
        clickY = math.min(vp.Y - 10, screenPos.Y + CONFIG.CLICK_BELOW_OFFSET)
        S.throwPhase = "PULL"
    else
        -- In optimal range: alternate
        if S.throwPhase == "PULL" then
            clickY = math.max(10, screenPos.Y - CONFIG.CLICK_ABOVE_OFFSET)
            S.throwPhase = "PUSH"
        else
            clickY = math.min(vp.Y - 10, screenPos.Y + CONFIG.CLICK_BELOW_OFFSET)
            S.throwPhase = "PULL"
        end
    end
    
    -- Click at calculated position
    sendClickAt(clickX, clickY)
    
    task.wait(CONFIG.Q_HOLD_AFTER_CLICK)
    releaseKey(Enum.KeyCode.Q)
    
    S.isAttacking = false
    return true
end

-- =====================================================
-- CHAT/TAUNT SYSTEM
-- =====================================================

local function sendChat(message)
    pcall(function()
        local textChatService = game:GetService("TextChatService")
        local channel = textChatService.TextChannels:FindFirstChild("RBXGeneral")
        if channel then
            channel:SendAsync(message)
        end
    end)
end

local function sendRandomTaunt()
    local taunt = TAUNTS[math.random(1, #TAUNTS)]
    if getAltHealth() > 80 then
        if math.random() > 0.5 then
            taunt = "not even close"
        end
    end
    sendChat(taunt)
end

local function scheduleTaunt(distance)
    if S.tauntScheduled or S.hasSentTaunt then return end
    if distance and distance > CONFIG.TAUNT_RANGE then
        S.hasSentTaunt = true
        return
    end
    
    S.tauntScheduled = true
    local delay = CONFIG.TAUNT_MIN_DELAY + math.random() * (CONFIG.TAUNT_MAX_DELAY - CONFIG.TAUNT_MIN_DELAY)
    
    task.spawn(function()
        task.wait(delay)
        if S.targetWasDead and not S.hasSentTaunt then
            S.tauntPauseActive = true
            stopAllMovementKeys()
            sendRandomTaunt()
            S.hasSentTaunt = true
            task.wait(0.5 + math.random() * 0.3)
            S.tauntPauseActive = false
        end
        S.tauntScheduled = false
    end)
end

-- =====================================================
-- GUI HELPERS
-- =====================================================

local function getClosestPlayerToCursor()
    local mousePos = UserInputService:GetMouseLocation()
    local closest = nil
    local closestDist = math.huge
    
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= player then
            local root = getRoot(plr)
            if root then
                local screenPos, onScreen = Camera:WorldToViewportPoint(root.Position)
                if onScreen then
                    local dist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                    if dist < closestDist then
                        closestDist = dist
                        closest = plr
                    end
                end
            end
        end
    end
    
    return closest
end

local function createTargetIndicator()
    -- Remove existing
    if S.targetIndicator then S.targetIndicator:Destroy() end
    if S.targetBillboard then S.targetBillboard:Destroy() end
    
    local target = getCurrentTarget()
    if not target then return end
    
    local targetChar = getChar(target)
    local targetRoot = getRoot(target)
    if not targetChar or not targetRoot then return end
    
    local box = Instance.new("SelectionBox")
    box.Name = "TargetIndicator"
    box.Adornee = targetChar
    box.Color3 = Color3.fromRGB(255, 0, 0)
    box.LineThickness = 0.1
    box.Transparency = 0.3
    box.Parent = targetChar
    S.targetIndicator = box
    
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "TargetBillboard"
    billboard.Adornee = targetRoot
    billboard.Size = UDim2.new(0, 200, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 5, 0)
    billboard.AlwaysOnTop = true
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 1, 0)
    frame.BackgroundTransparency = 0.5
    frame.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    frame.BorderSizePixel = 0
    frame.Parent = billboard
    
    local text = Instance.new("TextLabel")
    text.Size = UDim2.new(1, 0, 1, 0)
    text.BackgroundTransparency = 1
    text.Text = "TARGET"
    text.TextColor3 = Color3.fromRGB(255, 255, 255)
    text.TextScaled = true
    text.Font = Enum.Font.SourceSansBold
    text.Parent = frame
    
    billboard.Parent = targetRoot
    S.targetBillboard = billboard
end

local function removeTargetIndicator()
    if S.targetIndicator then S.targetIndicator:Destroy(); S.targetIndicator = nil end
    if S.targetBillboard then S.targetBillboard:Destroy(); S.targetBillboard = nil end
end

local function createDebugGui()
    local playerGui = player:WaitForChild("PlayerGui")
    if S.debugGui then S.debugGui:Destroy() end
    
    local gui = Instance.new("ScreenGui")
    gui.Name = "AltFollowDebug"
    gui.ResetOnSpawn = false
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 400, 0, 350)
    frame.Position = UDim2.new(0, 10, 0, 10)
    frame.BackgroundColor3 = Color3.new(0, 0, 0)
    frame.BackgroundTransparency = 0.3
    frame.BorderSizePixel = 2
    frame.BorderColor3 = Color3.new(0, 1, 1)
    frame.Parent = gui
    
    local text = Instance.new("TextLabel")
    text.Name = "DebugText"
    text.Size = UDim2.new(1, -10, 1, -10)
    text.Position = UDim2.new(0, 5, 0, 5)
    text.BackgroundTransparency = 1
    text.TextColor3 = Color3.new(0, 1, 1)
    text.TextSize = 14
    text.Font = Enum.Font.RobotoMono
    text.TextXAlignment = Enum.TextXAlignment.Left
    text.TextYAlignment = Enum.TextYAlignment.Top
    text.Text = "Initializing..."
    text.Parent = frame
    
    gui.Parent = playerGui
    S.debugGui = gui
end

local function updateDebugGui(info)
    if not S.debugGui then return end
    local textLabel = S.debugGui:FindFirstChild("Frame") and S.debugGui.Frame:FindFirstChild("DebugText")
    if textLabel then
        textLabel.Text = info
    end
end

-- =====================================================
-- COMBAT CAMERA LOCK (Lerp CFrame toward target)
-- =====================================================

local function updateCombatCameraLock(myPos, targetPos, smoothness)
    if not myPos or not targetPos then return end
    if not isValidVector(myPos) or not isValidVector(targetPos) then return end
    
    local camPos = Camera.CFrame.Position
    local targetCFrame = CFrame.lookAt(camPos, targetPos)
    
    -- Smooth interpolation
    Camera.CFrame = Camera.CFrame:Lerp(targetCFrame, smoothness or CONFIG.COMBAT_CAM_SMOOTHNESS)
end

local function restoreFOV()
    -- No-op now, camera lock doesn't change FOV
end

-- =====================================================
-- MAIN MOVEMENT LOOP (Section 22 State Machine)
-- =====================================================

local function processMovementFrame(dt)
    if not S.following or S.altIsDead then return end
    if S.tauntPauseActive then return end
    
    local myPos = getMyPosition()
    local target = getCurrentTarget()
    local targetPos = target and getPlayerPosition(target)  -- Change #4: Use getPlayerPosition
    
    if not myPos then return end
    
    -- Update key states
    updateKeyStates()
    
    -- Update water state
    updateWaterState()
    
    -- Update air management
    updateAirManagement(dt)
    
    -- Update boundary state
    updateBoundaryState(myPos)
    
    -- Update river method
    if targetPos then
        updateRiverMethodState(targetPos, tick())
    end
    
    -- Update target availability (throttled to reduce raycast spam)
    local now = tick()
    if now - S.lastStructureCheck >= CONFIG.STRUCTURE_CHECK_RATE then
        S.lastStructureCheck = now
        updateStructureTrapped()
    end
    
    -- Update secondary target logic
    updateSecondaryTargetLogic(myPos)
    
    -- Refresh current target
    target = getCurrentTarget()
    targetPos = target and getPlayerPosition(target)  -- Change #4: Use getPlayerPosition
    
    -- Cache last known position
    if targetPos then
        S.lastKnownPosition = targetPos
    end
    
    -- Calculate distance
    local distance = targetPos and (myPos - targetPos).Magnitude or 0
    local hDist = targetPos and math.sqrt((targetPos.X - myPos.X)^2 + (targetPos.Z - myPos.Z)^2) or 0
    
    -- Check target death
    local targetAlive = target and isPlayerAlive(target)
    if not targetAlive and not S.targetWasDead then
        S.targetWasDead = true
        S.hasSentTaunt = false
        scheduleTaunt(distance)
    elseif targetAlive and S.targetWasDead then
        S.targetWasDead = false
        S.hasSentTaunt = false
    end
    
    -- Manage flight stamina
    manageFlightStamina()
    
    -- ==========================================
    -- STATE MACHINE (Section 22)
    -- ==========================================
    
    -- RESURFACE MODE (exclusive state)
    if S.resurfaceMode then
        S.currentState = "RESURFACE"
        performSafeResurface()
        
        local stamina = getStamina() or 0
        local canFly = stamina > getEffectiveStaminaMin()
        local resurType = canFly and "DOLPHIN DIVE" or "SWIM UP"
        
        -- Calculate height above start for dolphin
        local heightInfo = ""
        if canFly and S.dolphinStartY then
            local heightAbove = myPos.Y - S.dolphinStartY
            heightInfo = string.format("\nPhase: %s\nHeight: %.1f / %.0f studs", 
                S.dolphinPhase, heightAbove, CONFIG.DOLPHIN_MAX_HEIGHT)
        end
        
        -- Calculate time spent resurfacing
        local resurTime = S.resurfaceStartTime > 0 and (tick() - S.resurfaceStartTime) or 0
        
        local debugInfo = string.format([[
STATE: RESURFACE %s
Mode: %s%s
Air: %.1f / %.1f
Head in water: %s
Stamina: %.0f
Resurface time: %.1fs / %.0fs
Emergency: %s
]], 
            S.emergencyResurface and "(EMERGENCY)" or "",
            resurType,
            heightInfo,
            S.airRemaining, CONFIG.UNDERWATER_MAX_TIME,
            tostring(S.headInWater),
            stamina,
            resurTime, CONFIG.RESURFACE_TIMEOUT,
            tostring(S.emergencyResurface)
        )
        updateDebugGui(debugInfo)
        return
    end
    
    -- BOUNDARY HANDLING
    if S.outsideBoundary then
        S.currentState = "RETURNING_TO_MAP"
        disableFlight()
        local returnDir = getBoundaryReturnDirection(myPos)
        Camera.CFrame = CFrame.lookAt(myPos, myPos + returnDir * 50)
        pulseKey(Enum.KeyCode.W, CONFIG.PULSE_W)
        
        updateDebugGui("STATE: RETURNING_TO_MAP\nWalking back to safe zone...")
        return
    end
    
    if S.nearBoundary then
        S.currentState = "BOUNDARY_WALK"
        disableFlight()
        
        local returnDir = getBoundaryReturnDirection(myPos)
        
        if targetPos then
            local toTarget = safeUnit(targetPos - myPos)
            -- Check if target direction goes more out of bounds
            local dotWithReturn = toTarget:Dot(returnDir)
            
            if dotWithReturn < 0 then
                -- Target is further out of bounds - walk inward instead
                Camera.CFrame = CFrame.lookAt(myPos, myPos + returnDir * 50)
            else
                -- Target is toward center - walk toward target
                Camera.CFrame = CFrame.lookAt(myPos, myPos + toTarget * 50)
            end
        else
            Camera.CFrame = CFrame.lookAt(myPos, myPos + returnDir * 50)
        end
        
        pulseKey(Enum.KeyCode.W, CONFIG.PULSE_W)
        updateDebugGui("STATE: BOUNDARY_WALK\nNear map edge - ground only")
        return
    end
    
    -- NO TARGET or TARGET DEAD
    if not target or S.targetWasDead then
        S.currentState = "IDLE"
        
        if S.targetWasDead and not S.hasSentTaunt then
            -- Waiting for taunt
            updateDebugGui("STATE: IDLE (waiting for taunt)")
        else
            -- Light wandering - always pulse for smooth movement
            disableFlight()
            
            -- Occasionally pick new direction
            if not S.idleFacingDirection or math.random() > 0.98 then
                local angle = math.random() * math.pi * 2
                S.idleFacingDirection = Vector3.new(math.cos(angle), 0, math.sin(angle))
            end
            
            Camera.CFrame = CFrame.lookAt(myPos, myPos + S.idleFacingDirection * 20)
            
            -- Always pulse for continuous smooth walking
            pulseKey(Enum.KeyCode.W, CONFIG.PULSE_IDLE_WALK)
            
            updateDebugGui("STATE: IDLE (wandering)")
        end
        return
    end
    
    -- TARGET UNAVAILABLE (Section 12)
    if not S.targetAvailable then
        S.currentState = "UNAVAILABLE_BAND"
        
        -- Guard against nil targetPos
        if not targetPos then
            -- No target position - just idle in place
            disableFlight()
            stopAllMovementKeys()
            updateDebugGui("STATE: UNAVAILABLE_BAND\nNo target position - idling...")
            return
        end
        
        -- Calculate distance from target
        local distFromTarget = (myPos - targetPos).Magnitude
        
        -- Phase 1: Fly outward to retreat distance (if flight available)
        if distFromTarget < CONFIG.UNAVAILABLE_RETREAT_DIST then
            -- Not at retreat distance yet - fly outward
            local stamina = getStamina()
            local canFly = stamina and stamina > getEffectiveStaminaMin()
            
            if canFly and not S.flightDisabledForStamina then
                -- Fly outward (away from target)
                ensureFlight()
                
                local awayDir = safeUnit(myPos - targetPos)
                -- Keep horizontal, slight up to avoid terrain
                awayDir = safeUnit(Vector3.new(awayDir.X, 0.1, awayDir.Z))
                Camera.CFrame = CFrame.lookAt(myPos, myPos + awayDir * 50)
                pulseKey(Enum.KeyCode.W, CONFIG.PULSE_W)
                
                local debugInfo = string.format([[
STATE: UNAVAILABLE_BAND (RETREATING)
Reason: %s
Target: %s
Distance: %.1f / %.1f
Flying outward to retreat distance...
]], 
                    S.unavailableReason or "Unknown",
                    (target and target.Name or "Unknown"),
                    distFromTarget,
                    CONFIG.UNAVAILABLE_RETREAT_DIST
                )
                updateDebugGui(debugInfo)
                return
            else
                -- No stamina for flight - walk outward
                local awayDir = safeUnit(Vector3.new((myPos - targetPos).X, 0, (myPos - targetPos).Z))
                Camera.CFrame = CFrame.lookAt(myPos, myPos + awayDir * 50)
                pulseKey(Enum.KeyCode.W, CONFIG.PULSE_W)
                
                local debugInfo = string.format([[
STATE: UNAVAILABLE_BAND (WALKING AWAY)
Reason: %s
Target: %s
Distance: %.1f / %.1f
Walking outward (no stamina for flight)...
]], 
                    S.unavailableReason or "Unknown",
                    (target and target.Name or "Unknown"),
                    distFromTarget,
                    CONFIG.UNAVAILABLE_RETREAT_DIST
                )
                updateDebugGui(debugInfo)
                return
            end
        end
        
        -- Phase 2: At retreat distance - disable flight and idle on ground
        disableFlight()
        
        -- Light idle wandering (ground only) - always pulse for smooth movement
        -- Occasionally pick new direction
        if not S.idleFacingDirection or math.random() > 0.98 then
            local angle = math.random() * math.pi * 2
            S.idleFacingDirection = Vector3.new(math.cos(angle), 0, math.sin(angle))
        end
        
        Camera.CFrame = CFrame.lookAt(myPos, myPos + S.idleFacingDirection * 20)
        
        -- Always pulse for continuous smooth walking
        pulseKey(Enum.KeyCode.W, CONFIG.PULSE_IDLE_WALK)
        
        local debugInfo = string.format([[
STATE: UNAVAILABLE_BAND (IDLE)
Reason: %s
Target: %s
Distance: %.1f
At retreat distance - idling on ground...
]], 
            S.unavailableReason or "Unknown",
            (target and target.Name or "Unknown"),
            distFromTarget
        )
        updateDebugGui(debugInfo)
        return
    end
    
    -- DIVING STATE - Flying toward river to engage underwater combat
    -- Keep flight ON, aim at target, dive into water
    if S.riverMethodActive and S.waterState == "DRY" and not S.resurfaceMode then
        S.currentState = "DIVING"
        
        -- Keep flight ON during dive approach
        local isFlying = ensureFlight()
        
        -- Aim toward target (can be above river surface)
        if targetPos then
            local toTarget = safeUnit(targetPos - myPos)
            Camera.CFrame = CFrame.lookAt(myPos, myPos + toTarget * 50)
            
            -- Keep mouse on target for early grabs if in range
            local screenPos, onScreen = Camera:WorldToViewportPoint(targetPos)
            if onScreen then
                pcall(function()
                    VirtualInputManager:SendMouseMoveEvent(screenPos.X, screenPos.Y, game)
                end)
            end
        end
        
        pulseKey(Enum.KeyCode.W, CONFIG.PULSE_W)
        
        local debugInfo = string.format([[
STATE: DIVING
Flying toward river...
Water State: %s
Target in river: YES
Distance: %.1f
Flying: %s
]], 
            S.waterState,
            distance,
            tostring(isFlying)
        )
        updateDebugGui(debugInfo)
        return
    end
    
    -- RIVER COMBAT (Change #2: Only run when actually in water)
    -- Dynamic flight: fly when stamina available, walk when not, fly again when recovered
    if S.riverMethodActive and (S.waterState == "SURFACE" or S.waterState == "UNDERWATER") then
        S.currentState = "RIVER_COMBAT"
        
        -- Dynamic flight management - fly when we have stamina
        local stamina = getStamina()
        local canFly = stamina and stamina > getEffectiveStaminaMin()
        local isFlying = false
        
        if canFly and not S.flightDisabledForStamina then
            isFlying = ensureFlight()
        else
            disableFlight()
        end
        
        -- Attempt attack if conditions met
        if targetPos then
            local canAttack, reason = canAttackNow(myPos, targetPos)
            if canAttack then
                executeAttack(myPos, targetPos, distance)
            end
        end
        
        -- Dolphin movement toward target (aim at target, can be above water surface)
        if targetPos then
            local toTarget = safeUnit(targetPos - myPos)
            Camera.CFrame = CFrame.lookAt(myPos, myPos + toTarget * 50)
            
            -- Keep mouse on target for grabs
            local screenPos, onScreen = Camera:WorldToViewportPoint(targetPos)
            if onScreen then
                pcall(function()
                    VirtualInputManager:SendMouseMoveEvent(screenPos.X, screenPos.Y, game)
                end)
            end
        end
        
        pulseKey(Enum.KeyCode.W, CONFIG.PULSE_W)
        
        local debugInfo = string.format([[
STATE: RIVER_COMBAT
Air: %.1f / %.1f
Distance: %.1f
Water State: %s
Flying: %s (stamina: %.0f)
]], 
            S.airRemaining, CONFIG.UNDERWATER_MAX_TIME,
            distance,
            S.waterState,
            tostring(isFlying),
            stamina or 0
        )
        updateDebugGui(debugInfo)
        return
    end
    
    -- COMBAT FLOW (main state)
    S.currentState = "COMBAT_FLOW"
    
    -- Handle stuck detection
    local stuckTime = updateStuckDetection(myPos, dt)
    if stuckTime > CONFIG.STUCK_TIME_THRESHOLD and not S.isUnsticking then
        startUnsticking(myPos, targetPos)
    end
    
    if S.isUnsticking then
        if tick() > S.unstickEndTime then
            resetStuckDetection()
        else
            local dir = S.unstickDirection or Vector3.new(0, 0, 1)
            Camera.CFrame = CFrame.lookAt(myPos, myPos + dir * 50)
            pulseKey(Enum.KeyCode.W, CONFIG.PULSE_W)
            
            -- Still allow attacks while unsticking if target is in range
            if targetPos and S.targetAvailable then
                -- Keep mouse on target for grabs
                local targetHead = getHead(getCurrentTarget())
                local aimPoint = targetHead and targetHead.Position or targetPos
                local screenPos, onScreen = Camera:WorldToViewportPoint(aimPoint)
                if onScreen then
                    pcall(function()
                        VirtualInputManager:SendMouseMoveEvent(screenPos.X, screenPos.Y, game)
                    end)
                end
                
                local canAttack, reason = canAttackNow(myPos, targetPos)
                if canAttack then
                    executeAttack(myPos, targetPos, distance)
                end
            end
            
            updateDebugGui("STATE: UNSTICKING\nFinding clear path...\n(Still attacking if in range)")
            return
        end
    end
    
    -- Update steering mode
    updateSteeringMode(hDist)
    
    -- Ensure flight if needed
    local flying = ensureFlight()
    
    -- Movement and combat based on distance
    local combatMode = "IDLE"
    
    if distance > CONFIG.COMBAT_ZONE then
        combatMode = "TRAVEL"
    elseif distance > CONFIG.OPTIMAL_MAX then
        combatMode = "APPROACH"
    elseif distance < CONFIG.OPTIMAL_MIN then
        combatMode = "TOO_CLOSE"
    else
        combatMode = "ATTACK"
    end
    
    -- Combat Camera Lock - lerp camera toward target during active combat
    local combatActive = (combatMode == "ATTACK" or combatMode == "TOO_CLOSE")
                     and (S.targetAvailable == true) 
                     and (not S.resurfaceMode) 
                     and (not S.riverMethodActive)
    
    if combatActive then
        -- Get target head position for aiming
        local targetHead = getHead(getCurrentTarget())
        local aimPoint = targetHead and targetHead.Position or targetPos
        if aimPoint then
            aimPoint = aimPoint + CONFIG.COMBAT_CAM_OFFSET
            updateCombatCameraLock(myPos, aimPoint, CONFIG.COMBAT_CAM_SMOOTHNESS)
            
            -- Keep virtual mouse locked on target every frame
            local screenPos, onScreen = Camera:WorldToViewportPoint(aimPoint)
            if onScreen then
                pcall(function()
                    VirtualInputManager:SendMouseMoveEvent(screenPos.X, screenPos.Y, game)
                end)
            end
        end
        -- During combat lock, we skip the normal flight steering camera updates
        -- but still do movement inputs
        pulseKey(Enum.KeyCode.W, CONFIG.PULSE_W)
        
        -- Combat strafing for distance control
        if combatMode == "TOO_CLOSE" then
            pulseKey(Enum.KeyCode.S, CONFIG.PULSE_S)
        end
    else
        -- Normal flight/ground steering (not in combat lock)
        if flying then
            if S.steeringMode == "ARC" then
                -- Arc steering with curve acceleration
                local direction, flightType = getAngledFlightDirection(myPos, targetPos)
                Camera.CFrame = CFrame.lookAt(myPos, myPos + direction * 50)
                
                pulseKey(Enum.KeyCode.W, CONFIG.PULSE_W)
                
                local myRoot = getRoot(player)
                if myRoot then
                    local velocity = myRoot.AssemblyLinearVelocity or myRoot.Velocity or Vector3.new(0,0,0)
                    local curveDir, _ = getCurveDirection(myPos, targetPos, velocity)
                    if curveDir == "RIGHT" then
                        pulseKey(Enum.KeyCode.D, CONFIG.PULSE_D)
                    elseif curveDir == "LEFT" then
                        pulseKey(Enum.KeyCode.A, CONFIG.PULSE_A)
                    else
                        clearKey(Enum.KeyCode.A)
                        clearKey(Enum.KeyCode.D)
                    end
                end
            else
                -- Slope steering (precision)
                local direction, flightType = getAngledFlightDirection(myPos, targetPos)
                Camera.CFrame = CFrame.lookAt(myPos, myPos + direction * 50)
                pulseKey(Enum.KeyCode.W, CONFIG.PULSE_W)
                clearKey(Enum.KeyCode.A)
                clearKey(Enum.KeyCode.D)
            end
        else
            -- Ground movement
            if targetPos then
                local toTarget = safeUnit(Vector3.new(targetPos.X - myPos.X, 0, targetPos.Z - myPos.Z))
                Camera.CFrame = CFrame.lookAt(myPos, myPos + toTarget * 50)
                pulseKey(Enum.KeyCode.W, CONFIG.PULSE_W)
            end
        end
    end
    
    -- Combat execution
    if combatMode == "ATTACK" or combatMode == "TOO_CLOSE" then
        local canAttack, reason = canAttackNow(myPos, targetPos)
        if canAttack then
            executeAttack(myPos, targetPos, distance)
        end
    end
    
    -- Debug info
    local debugInfo = string.format([[
STATE: %s
Target: %s %s
Distance: %.1f (optimal: %d-%d)
Combat: %s
Steering: %s
Flying: %s (stamina disabled: %s)
Water: %s | Air: %.1f
River method: %s
Available: %s
]], 
        S.currentState,
        (target and target.Name or "Unknown"),
        S.onSecondaryTarget and "(SECONDARY)" or "",
        distance, CONFIG.OPTIMAL_MIN, CONFIG.OPTIMAL_MAX,
        combatMode,
        S.steeringMode,
        tostring(flying), tostring(S.flightDisabledForStamina),
        S.waterState, S.airRemaining,
        tostring(S.riverMethodActive),
        tostring(S.targetAvailable)
    )
    updateDebugGui(debugInfo)
end

-- =====================================================
-- START/STOP FOLLOWING
-- =====================================================

local function startFollowing()
    S.following = true
    S.currentState = "IDLE"
    
    -- Capture default FOV (Change #3)
    if S.defaultFOV == nil then
        S.defaultFOV = Camera.FieldOfView
    end
    
    -- Reset all state
    S.targetWasDead = false
    S.targetWasInvisible = false
    S.targetInvisibleStartTime = 0
    S.hasSentTaunt = false
    S.tauntScheduled = false
    S.tauntPauseActive = false
    
    S.waterState = "DRY"
    S.isUnderwater = false
    S.airRemaining = CONFIG.UNDERWATER_MAX_TIME
    S.resurfaceMode = false
    S.emergencyResurface = false
    
    S.riverMethodActive = false
    S.targetTouchedWater = false
    S.targetWaterStartTime = 0
    
    S.targetAvailable = true
    S.unavailableReason = nil
    S.structureTrappedTimer = 0
    S.lastLOSFailTime = 0
    S.lastStructureCheck = 0
    S.lastLOSCheckTime = 0
    S.lastLOSResult = false
    
    S.steeringMode = "SLOPE"
    S.flightDisabledForStamina = false
    
    S.lastQClickTime = 0
    S.isAttacking = false
    S.throwPhase = "PULL"
    
    S.telekBlockStartTime = 0
    S.lastTelekRollTime = 0
    
    S.onSecondaryTarget = false
    S.activeSecondaryUserId = nil
    
    S.idleFacingDirection = nil
    
    resetStuckDetection()
    
    -- Cache stamina settings
    cached2xStamina = nil
    
    -- Start movement loop
    if S.movementConnection then
        S.movementConnection:Disconnect()
    end
    
    local lastTime = tick()
    S.movementConnection = RunService.Heartbeat:Connect(function()
        local now = tick()
        local dt = now - lastTime
        lastTime = now
        
        -- Clamp dt to prevent huge jumps
        dt = math.min(dt, 0.1)
        
        processMovementFrame(dt)
    end)
    
    -- Ensure flight
    ensureFlight()
    
    -- Create GUI
    createTargetIndicator()
    createDebugGui()
    
    -- Store primary
    if S.targetPlayer then
        S.primaryUserId = S.targetPlayer.UserId
    end
    
    print("Started following: " .. (S.targetPlayer and S.targetPlayer.Name or "nil"))
end

local function stopFollowing()
    S.following = false
    S.currentState = "IDLE"
    S.targetPlayer = nil
    
    -- Stop movement loop
    if S.movementConnection then
        S.movementConnection:Disconnect()
        S.movementConnection = nil
    end
    
    -- Release all keys
    stopAllMovementKeys()
    releaseKey(Enum.KeyCode.Q)
    
    -- Reset camera
    Camera.CameraType = Enum.CameraType.Custom
    local hum = getHumanoid(player)
    if hum then Camera.CameraSubject = hum end
    UserInputService.MouseBehavior = Enum.MouseBehavior.Default
    
    -- Restore FOV (Change #3)
    restoreFOV()
    
    -- Clean up GUI
    removeTargetIndicator()
    if S.debugGui then S.debugGui:Destroy(); S.debugGui = nil end
    
    -- Clear state
    clearSecondaryTargets()
    resetStuckDetection()
    
    print("Stopped following")
end

-- =====================================================
-- INPUT HANDLING
-- =====================================================

UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    
    if input.KeyCode == Enum.KeyCode.N then
        if not S.following then
            local target = getClosestPlayerToCursor()
            if target then
                S.targetPlayer = target
                S.primaryUserId = target.UserId
                startFollowing()
            else
                warn("No player found near cursor")
            end
        else
            local newTarget = getClosestPlayerToCursor()
            if newTarget and newTarget ~= S.targetPlayer then
                -- Switch target
                S.targetPlayer = newTarget
                S.primaryUserId = newTarget.UserId
                S.targetWasDead = false
                S.targetWasInvisible = false
                clearSecondaryTargets()
                createTargetIndicator()
                print("Switched target to: " .. newTarget.Name)
            else
                stopFollowing()
            end
        end
    
    elseif input.KeyCode == Enum.KeyCode.M then
        -- Add/remove secondary target
        if S.following then
            local target = getClosestPlayerToCursor()
            if target then
                if target == S.targetPlayer then
                    print("Cannot add primary as secondary")
                else
                    toggleSecondaryTarget(target)
                end
            else
                warn("No player found near cursor")
            end
        else
            warn("Not following - press N first")
        end
    
    elseif input.KeyCode == Enum.KeyCode.L then
        -- Clear all secondaries
        if S.following then
            clearSecondaryTargets()
            print("Cleared all secondary targets")
        end
    end
end)

-- =====================================================
-- EVENT CONNECTIONS
-- =====================================================

player.CharacterAdded:Connect(function()
    S.altIsDead = false
    task.wait(1)
    if S.following and S.targetPlayer then
        S.flightDisabledForStamina = false
        S.isAttacking = false
        ensureFlight()
        createTargetIndicator()
        createDebugGui()
    end
end)

player.CharacterRemoving:Connect(function()
    S.altIsDead = true
    releaseKey(Enum.KeyCode.Q)
    S.isAttacking = false
end)

Players.PlayerAdded:Connect(function(newPlayer)
    if S.following and S.primaryUserId then
        if newPlayer.UserId == S.primaryUserId then
            task.wait(1)
            if S.following then
                S.targetPlayer = newPlayer
                S.targetWasDead = false
                S.targetWasInvisible = false
                createTargetIndicator()
                print("Primary target rejoined: " .. newPlayer.Name)
            end
        end
    end
end)

Players.PlayerRemoving:Connect(function(leavingPlayer)
    if leavingPlayer == S.targetPlayer then
        S.targetPlayer = nil
        S.targetWasDead = true
        removeTargetIndicator()
        print("Target left game - waiting for rejoin")
    end
end)

-- =====================================================
-- STARTUP
-- =====================================================

print(string.rep("=", 55))
print("ALTFOLLOW SCRIPT v6.0 - FULL SPECIFICATION")
print(string.rep("=", 55))
print("Controls:")
print("  N - Toggle/Switch primary target")
print("  M - Add/Remove secondary target")
print("  L - Clear all secondary targets")
print("")
print("FEATURES:")
print("  - Pulse-based input system (Section 17)")
print("  - Water/river detection and combat (Sections 3-7)")
print("  - Safe resurface mechanics (Section 8)")
print("  - Cylindrical LOS system (Section 9)")
print("  - Shield handling (Flyro/Telek) (Section 10)")
print("  - Availability checks (Section 11)")
print("  - Unavailable band behavior (Section 12)")
print("  - Secondary target system (Section 13)")
print("  - Arc vs slope flight steering (Section 18)")
print("  - Map boundary system (Section 19)")
print("  - No-chase zone detection (Section 20)")
print("  - Full state machine (Section 22)")
print("")
print("Comfort range: " .. CONFIG.OPTIMAL_MIN .. "-" .. CONFIG.OPTIMAL_MAX .. " studs")
print(string.rep("=", 55))
