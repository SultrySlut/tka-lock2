

loadstring(game:HttpGet("https://raw.githubusercontent.com/SultrySlut/tka-lock2/refs/heads/main/the%20stuff"))()

-- Complete Alt Follow Script v5.4.45 - Smart Secondary Targeting
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Camera = workspace.CurrentCamera

local player = Players.LocalPlayer

-- =====================================================
-- CORE VARIABLES
-- =====================================================

local targetPlayer = nil
local following = false
local lastKnownPosition = nil
local debugGui = nil
local targetIndicator = nil
local targetBillboard = nil
local screenGui = nil

-- Movement Management
local moveVector = Vector3.new(0, 0, 0)
local movementPulseTimer = 0

-- Combat System
local lastQClickTime = 0
local currentMode = "IDLE"
local spectating = false

-- Stamina Management
local flightDisabledForStamina = false

-- State Tracking
local targetWasDead = false
local targetWasInvisible = false
local stoppedFlightForDeath = false
local lastTargetCheck = 0
local isAttacking = false
local altIsDead = false
local justAttacked = false

-- Target Memory (for rejoin tracking)
local rememberedTargetUserId = nil
local originalPrimaryUserId = nil  -- The first target (N key), for fallback when all die
local manuallySwitchedTarget = false
local mainTargetRespawnTime = 0     -- When main target respawned (for grace period)

-- Multi-Target System (M key)
local secondaryTargetUserIds = {}  -- Store UserIds (persist across rejoin)
local MAX_SECONDARY_TARGETS = 2
local onSecondaryTarget = false    -- True when currently attacking a secondary

-- Telek Shield Tracking (20% chance per second blocked)
local telekBlockStartTime = 0
local lastTelekRollTime = 0

-- River Method (dolphin dive for underwater combat)
local targetTouchedWater = false
local targetWaterStartTime = 0
local riverMethodActive = false

-- Unified "target unavailable" state (invisible, under map, flyro, boulder)
local targetUnavailable = false
local unavailableReason = nil  -- "INVISIBLE", "UNDER_MAP", "FLYRO", "BOULDER", "TERRAIN_BLOCKED"
local unavailableRetreatDone = false  -- Have we retreated to 100 studs yet?

-- Retreat State
local retreatActive = false
local retreatPosition = nil      -- Point to retreat to
local retreatReason = nil        -- "INVISIBLE" or "TERRAIN_BLOCKED"

-- Vertical tracking for smooth movement
local lastVerticalDirection = 0  -- -1 = descending, 0 = level, 1 = ascending
local verticalDirectionStartTime = 0

-- Stuck Detection
local lastPosition = nil
local lastPositionTime = 0
local stuckTimer = 0
local isUnsticking = false
local unstickDirection = nil
local unstickEndTime = 0

-- Tab-out Detection
local lastFrameTime = 0

-- Underwater Detection
local isUnderwater = false
local airRemaining = 10
local lastUnderwaterCheck = 0
local cachedTargetInWater = false

-- Emergency Defense
local emergencyDefenseActive = false
local preEmergencyTask = nil
local lastKnownHealth = 100
local damageThreshold = 15
local resurfaceStarted = false

-- Taunt System
local hasSentTaunt = false
local tauntScheduled = false
local tauntPauseActive = false  -- Pause movement while taunting
local lastBodyPosition = nil    -- Where target died, for walking away

-- Random Walk
local lastRandomWalkTime = 0
local randomWalkDirection = nil

-- Ground Movement Jumping
local lastJumpTime = 0
local lastCombatJumpTime = 0

-- Taunts
local TAUNTS = {
    "GG", "ez", "rip", "too easy", "get good", "lol",
    "nice try", "gg ez", "free", "sit", "back to menu", "yawn",
}

-- =====================================================
-- CONFIGURATION
-- =====================================================

local CONFIG = {
    -- Distance thresholds
    OPTIMAL_MIN = 54,              -- Comfort range (not min Q range - Q has no min)
    OPTIMAL_MAX = 73.3,
    OPTIMAL_MID = 60,
    COMBAT_ZONE = 76,

    -- Timing
    MOVEMENT_PULSE_RATE = 0.5,
    Q_CLICK_COOLDOWN = 1.5,
    KEY_PULSE_DURATION = 10,
    TARGET_CHECK_RATE = 0.1,
    FLIGHT_TOGGLE_COOLDOWN = 1,

    -- Stamina Management
    STAMINA_MIN = 40,
    STAMINA_RECHARGE_THRESHOLD = 140,

    -- Combat
    LINE_OF_SIGHT_CHECKS = 20,
    CLICK_BELOW_OFFSET = 150,      -- Pixels below center for pull attack
    CLICK_ABOVE_OFFSET = 150,      -- Pixels above center for push attack

    -- Vertical Flight
    VERTICAL_THRESHOLD = 10,
    VERTICAL_PRIORITY_THRESHOLD = 25,
    MAX_VERTICAL_SEPARATION = 80,
    SMALL_HEIGHT_CHANGE = 8,
    ANGLED_FLIGHT_RATIO = 0.5,
    VERTICAL_DIRECTION_HOLD_TIME = 0.6,
    HORIZONTAL_TOO_SMALL = 100,

    -- Stuck Detection
    STUCK_VELOCITY_THRESHOLD = 3,
    STUCK_TIME_THRESHOLD = 0.4,
    UNSTUCK_DURATION = 3,
    UNSTUCK_SCAN_DISTANCE = 100,
    UNSTUCK_SPHERE_POINTS = 100,

    -- Terrain Protection
    TERRAIN_CHECK_DISTANCE = 4,

    -- Underwater
    UNDERWATER_MAX_TIME = 10,

    -- River boundaries
    RIVER_X_MIN = -550,
    RIVER_X_MAX = -100,
    RIVER_Z_MIN = -740,
    RIVER_Z_MAX = 580,
    RIVER_SURFACE_Y = -40,
    RIVER_COMMIT_TIME = 1.0,      -- Seconds in water before committing to river method
    RIVER_EXIT_HEIGHT = 20,       -- Exit river method if target > this many studs above surface
    AIR_RESURFACE_THRESHOLD = 2,  -- Pop head out when air <= this

    -- Under map detection
    UNDER_MAP_Y = -85,

    -- Taunts
    TAUNT_MIN_DELAY = 1.0,
    TAUNT_MAX_DELAY = 1.5,
    TAUNT_RANGE = 100,

    -- Ground movement jumping
    JUMP_CHANCE = 0.3,
    JUMP_INTERVAL = 0.8,
    COMBAT_JUMP_CHANCE = 0.4,

    -- Curve acceleration (flight boost)
    CURVE_THRESHOLD = 0.30,
    CURVE_DEVIATION_RATIO = 0.20,
    CURVE_MIN_VELOCITY = 5,

    -- Shield detection
    TELEK_SHIELD_DIAMETER = 29,    -- Telekinesis shield disk diameter
    TELEK_GRAB_CHANCE = 0.20,      -- 20% chance/sec while blocked

    -- Unified unavailable behavior (invisible, under map, flyro, boulder, terrain blocked)
    UNAVAILABLE_RETREAT_DIST = 100,   -- Retreat to this distance
    UNAVAILABLE_STAY_RANGE = 30,      -- Stay within +/- this range of retreat point
    UNAVAILABLE_JUMP_CHANCE = 0.4,    -- Chance to jump while walking

    -- =================================================
    -- Secondary targeting settings
    -- =================================================
    ENABLE_TARGET_SWITCHING = true,
    SECONDARY_TARGET_RANGE = 140,  -- Can only "see" secondaries within this range
    MAIN_RESPAWN_GRACE = 0.5,      -- Seconds after main respawns before switching back (finish secondary kill)
}

-- =====================================================
-- CHARACTER/POSITION HELPERS
-- =====================================================

local function getChar(plr)
    if not plr then return nil end
    local chars = workspace:FindFirstChild("Characters")
    return (chars and chars:FindFirstChild(plr.Name)) or plr.Character
end

local function getRoot(plr)
    local char = getChar(plr)
    if not char then return nil end
    return char:FindFirstChild("HumanoidRootPart") or
           char:FindFirstChild("Torso") or
           char:FindFirstChild("UpperTorso") or
           char.PrimaryPart
end

local function getHumanoid(plr)
    local char = getChar(plr)
    return char and char:FindFirstChildOfClass("Humanoid")
end

local function getTargetPosition()
    if not targetPlayer then return nil end
    local root = getRoot(targetPlayer)
    if root then
        lastKnownPosition = root.Position
        return root.Position
    end
    local char = getChar(targetPlayer)
    if char then
        for _, part in pairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                lastKnownPosition = part.Position
                return part.Position
            end
        end
    end
    return lastKnownPosition
end

local function isPlayerAlive(plr)
    if not plr then return false end
    local hum = getHumanoid(plr)
    if not hum then return true end  -- No humanoid yet, assume alive
    return hum.Health > 0
end

local function isTargetAlive()
    return isPlayerAlive(targetPlayer)
end

local function isTargetInvisible()
    if not targetPlayer then return false end
    local chars = workspace:FindFirstChild("Characters")
    if not chars then return false end
    local targetChar = chars:FindFirstChild(targetPlayer.Name)
    if not targetChar then return false end
    local invisible = targetChar:FindFirstChild("Invisible")
    if invisible and invisible:IsA("BoolValue") then
        return invisible.Value
    end
    return false
end

local function getStamina()
    local chars = workspace:FindFirstChild("Characters")
    if not chars then return nil end
    local myChar = chars:FindFirstChild(player.Name)
    if not myChar then return nil end
    local stamina = myChar:FindFirstChild("Stamina")
    if stamina then
        if stamina:IsA("IntValue") or stamina:IsA("NumberValue") then
            return stamina.Value
        elseif stamina:FindFirstChild("Value") then
            return stamina.Value.Value
        end
    end
    return nil
end

local function getAltHealth()
    local hum = getHumanoid(player)
    if hum then return hum.Health end
    return 0
end

-- 2xStamina caching
local cached2xStamina = nil

local function has2xStamina()
    if cached2xStamina ~= nil then return cached2xStamina end
    local data = player:FindFirstChild("Data")
    if data then
        local doubleStamina = data:FindFirstChild("2xStamina")
        if doubleStamina then
            cached2xStamina = doubleStamina.Value == true
            return cached2xStamina
        end
    end
    cached2xStamina = false
    return false
end

local cachedStaminaMin = nil
local cachedStaminaRecharge = nil

local function getEffectiveStaminaMin()
    if cachedStaminaMin then return cachedStaminaMin end
    cachedStaminaMin = has2xStamina() and CONFIG.STAMINA_MIN or (CONFIG.STAMINA_MIN / 2)
    return cachedStaminaMin
end

local function getEffectiveStaminaRecharge()
    if cachedStaminaRecharge then return cachedStaminaRecharge end
    cachedStaminaRecharge = has2xStamina() and CONFIG.STAMINA_RECHARGE_THRESHOLD or (CONFIG.STAMINA_RECHARGE_THRESHOLD / 2)
    return cachedStaminaRecharge
end

-- Terrain check (throttled)
local lastTerrainCheck = 0
local lastTerrainResult = false

local function isTerrainBelow()
    local now = tick()
    if now - lastTerrainCheck < 0.1 then return lastTerrainResult end
    lastTerrainCheck = now

    local char = getChar(player)
    if not char then lastTerrainResult = false; return false end

    local head = char:FindFirstChild("Head")
    local upperTorso = char:FindFirstChild("UpperTorso") or char:FindFirstChild("Torso")

    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {char}

    for _, part in ipairs({head, upperTorso}) do
        if part then
            local result = workspace:Raycast(part.Position, Vector3.new(0, -CONFIG.TERRAIN_CHECK_DISTANCE, 0), raycastParams)
            if result and result.Instance:IsA("Terrain") then
                lastTerrainResult = true
                return true
            end
        end
    end

    lastTerrainResult = false
    return false
end

-- =====================================================
-- WATER DETECTION
-- =====================================================

local Terrain = workspace:FindFirstChildOfClass("Terrain")
local waterOverlapParams = OverlapParams.new()
waterOverlapParams.FilterType = Enum.RaycastFilterType.Blacklist

local function isWaterPart(part)
    if not part or not part:IsA("BasePart") then return false end
    if part.Material == Enum.Material.Water then return true end
    if string.find(string.lower(part.Name or ""), "water") then return true end
    return false
end

local function waterPartsNearPoint(point, halfSize, blacklistChar)
    waterOverlapParams.FilterDescendantsInstances = blacklistChar and {blacklistChar} or {}
    local ok, parts = pcall(function()
        return workspace:GetPartBoundsInBox(CFrame.new(point), Vector3.new(halfSize*2, halfSize*2, halfSize*2), waterOverlapParams)
    end)
    if not ok or not parts then return false, nil end
    for _, p in ipairs(parts) do
        if isWaterPart(p) then return true, p end
    end
    return false, nil
end

local function terrainWaterAtPoint(point)
    if not Terrain or not Terrain.ReadVoxels then return false end
    local half = Vector3.new(2, 2, 2)
    local region = Region3.new(point - half, point + half):ExpandToGrid(4)
    local ok, materials = pcall(function() return Terrain:ReadVoxels(region, 4) end)
    if not ok or not materials then return false end
    for x = 1, #materials do
        local col = materials[x]
        if col then
            for y = 1, #col do
                local row = col[y]
                if row then
                    for z = 1, #row do
                        if row[z] == Enum.Material.Water then return true end
                    end
                end
            end
        end
    end
    return false
end

local function waterAtPoint(point, halfSize, blacklistChar)
    local touchingWaterPart = waterPartsNearPoint(point, halfSize, blacklistChar)
    if touchingWaterPart then return true end
    if terrainWaterAtPoint(point) then return true end
    return false
end

local function checkUnderwater()
    local char = getChar(player)
    if not char then return false end
    local head = char:FindFirstChild("Head")
    local root = char:FindFirstChild("HumanoidRootPart")
    if not head and not root then return false end
    if head and waterAtPoint(head.Position, 2.0, char) then return true end
    if root and waterAtPoint(root.Position, 3.0, char) then return true end
    return false
end

local function isTargetUnderwater()
    if not targetPlayer then return false end
    local char = getChar(targetPlayer)
    if not char then return false end
    local head = char:FindFirstChild("Head")
    local root = char:FindFirstChild("HumanoidRootPart")
    if not head and not root then return false end
    if head and waterAtPoint(head.Position, 2.0, char) then return true end
    if root and waterAtPoint(root.Position, 3.0, char) then return true end
    return false
end

local function isValidUnderwaterAttackPosition(myPos, targetPos)
    if not isUnderwater then return false, "ALT_NOT_UNDERWATER" end
    local yDiff = myPos.Y - targetPos.Y
    if yDiff > 4 then return false, "ALT_TOO_HIGH" end
    if yDiff < -10 then return false, "ALT_TOO_LOW" end
    return true, "VALID"
end

local function getUnderwaterRepositionDirection(myPos, targetPos)
    local yDiff = myPos.Y - targetPos.Y
    if yDiff > 4 then return Vector3.new(0, -1, 0), "DESCEND"
    elseif yDiff < -10 then return Vector3.new(0, 1, 0), "ASCEND" end
    local horizontalDir = Vector3.new(targetPos.X - myPos.X, 0, targetPos.Z - myPos.Z)
    if horizontalDir.Magnitude > 0.1 then return horizontalDir.Unit, "HORIZONTAL" end
    return Vector3.new(0, 0, 0), "HOLD"
end

local function canEnterCombatMode()
    if cachedTargetInWater then return isUnderwater end
    return true
end

-- Check if target is under the map (Y check OR terrain blocked when not in river)
local function isTargetUnderMap(targetPos)
    if not targetPos then return false end
    -- Direct Y check
    if targetPos.Y <= CONFIG.UNDER_MAP_Y then return true end
    return false
end

-- Check if target is blocked by terrain between alt and target (indicates under map if not in river)
local function isTargetBehindTerrain(myPos, targetPos)
    if not myPos or not targetPos then return false end
    -- If target is in river bounds, don't use terrain check (river has terrain)
    if isInRiverBoundsHorizontal(targetPos) then return false end
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {
        workspace:FindFirstChild("Characters"),
        player.Character,
        targetPlayer and targetPlayer.Character
    }
    
    local result = workspace:Raycast(myPos, targetPos - myPos, raycastParams)
    if result and result.Instance then
        -- Check if it's terrain blocking
        if result.Instance:IsA("Terrain") or result.Instance.Name == "Terrain" then
            return true
        end
    end
    return false
end

-- Check if position is in river bounds (horizontal only)
local function isInRiverBoundsHorizontal(pos)
    if not pos then return false end
    return pos.X >= CONFIG.RIVER_X_MIN and pos.X <= CONFIG.RIVER_X_MAX
       and pos.Z >= CONFIG.RIVER_Z_MIN and pos.Z <= CONFIG.RIVER_Z_MAX
end

-- Check if position is underwater in river (below surface, above under-map)
local function isInRiverBounds(pos)
    if not pos then return false end
    return pos.X >= CONFIG.RIVER_X_MIN and pos.X <= CONFIG.RIVER_X_MAX
       and pos.Z >= CONFIG.RIVER_Z_MIN and pos.Z <= CONFIG.RIVER_Z_MAX
       and pos.Y <= CONFIG.RIVER_SURFACE_Y
       and pos.Y > CONFIG.UNDER_MAP_Y  -- Not under map
end

-- Check if target is in river zone (could be above or below water)
local function isTargetInRiverZone(targetPos)
    if not targetPos then return false end
    return isInRiverBoundsHorizontal(targetPos) and targetPos.Y > CONFIG.UNDER_MAP_Y
end

-- Check if alt needs to dive down to reach river target
local function shouldDiveForRiverTarget(myPos, targetPos)
    if not myPos or not targetPos then return false end

    -- Target must be in river zone
    if not isTargetInRiverZone(targetPos) then return false end

    -- Target is underwater (below surface)
    local targetUnderwater = targetPos.Y <= CONFIG.RIVER_SURFACE_Y

    -- Alt is above water
    local altAboveWater = myPos.Y > CONFIG.RIVER_SURFACE_Y

    -- If target underwater and alt above water, need to dive
    if targetUnderwater and altAboveWater then
        return true
    end

    return false
end

-- Get dive entry point (above water, then down)
local function getRiverDivePoint(myPos, targetPos)
    -- Entry point is above target's X/Z position, at surface level
    return Vector3.new(targetPos.X, CONFIG.RIVER_SURFACE_Y + 5, targetPos.Z)
end

local function canGrabRiverTarget(myPos, targetPos)
    if not myPos or not targetPos then return false end
    local myChar = getChar(player)
    local targetChar = targetPlayer and getChar(targetPlayer)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {myChar, targetChar}
    local directions = {
        (myPos - targetPos).Unit, Vector3.new(0, 1, 0),
        Vector3.new(1, 0, 0), Vector3.new(-1, 0, 0),
        Vector3.new(0, 0, 1), Vector3.new(0, 0, -1),
    }
    local clearCount = 0
    for _, dir in ipairs(directions) do
        local result = workspace:Raycast(targetPos, dir * 60, raycastParams)
        if not result then clearCount = clearCount + 1
        elseif result.Distance > 20 then clearCount = clearCount + 0.5 end
    end
    return clearCount >= 2
end

-- Check if target's root is actually in water (not just in river zone)
local function isTargetRootInWater()
    if not targetPlayer then return false end
    local root = getRoot(targetPlayer)
    if not root then return false end
    return waterAtPoint(root.Position, 2.0, getChar(targetPlayer))
end

-- Check if target is within river method engagement range
local function isTargetInRiverMethodRange(targetPos)
    if not targetPos then return false end
    if not isInRiverBoundsHorizontal(targetPos) then return false end
    if targetPos.Y <= CONFIG.UNDER_MAP_Y then return false end
    -- Must be within 20 studs above surface (or below)
    return targetPos.Y <= CONFIG.RIVER_SURFACE_Y + CONFIG.RIVER_EXIT_HEIGHT
end

-- Update river method tracking state
local function updateRiverMethodState(targetPos, now)
    -- Check exit conditions first
    if not isTargetInRiverMethodRange(targetPos) then
        -- Target left river method range - reset everything
        riverMethodActive = false
        targetTouchedWater = false
        targetWaterStartTime = 0
        return
    end
    
    -- Target is in river bounds and within height range
    local rootInWater = isTargetRootInWater()
    
    if rootInWater then
        if not targetTouchedWater then
            -- First time touching water
            targetTouchedWater = true
            targetWaterStartTime = now
        elseif not riverMethodActive and (now - targetWaterStartTime >= CONFIG.RIVER_COMMIT_TIME) then
            -- Been in water 1+ second - commit to river method
            riverMethodActive = true
            print("River method activated - target committed to water")
        end
    end
    -- Note: Don't reset targetTouchedWater if they pop out briefly - only reset when leaving range
end

-- Resurface for air (dolphin up)
local function tryResurface(myPos)
    -- Pop head out - aim for surface + 3 studs
    local surfacePoint = Vector3.new(myPos.X, CONFIG.RIVER_SURFACE_Y + 3, myPos.Z)
    Camera.CameraType = Enum.CameraType.Scriptable
    Camera.CFrame = CFrame.lookAt(myPos, surfacePoint)
    -- Don't try to fly - just swim up with W + Space
    -- Flight is not needed underwater, swimming works fine
    pulseMovementKey(Enum.KeyCode.W)
    pulseMovementKey(Enum.KeyCode.Space)  -- Swim up
end

-- Unpredictable walking behavior for when target is unavailable
local lastUnpredictableWalkTime = 0
local unpredictableWalkDirection = nil
local unpredictableWalkDuration = 0

local function doUnpredictableWalk(myPos, targetPos)
    local currentTime = tick()
    
    -- Change direction every 1-3 seconds
    if not unpredictableWalkDirection or currentTime - lastUnpredictableWalkTime > unpredictableWalkDuration then
        lastUnpredictableWalkTime = currentTime
        unpredictableWalkDuration = 1 + math.random() * 2  -- 1-3 seconds
        
        -- Random direction, but generally stay near 100 studs from target
        local distToTarget = (myPos - targetPos).Magnitude
        local awayDir = (myPos - targetPos)
        if awayDir.Magnitude > 0.1 then awayDir = awayDir.Unit else awayDir = Vector3.new(1, 0, 0) end
        
        -- Add randomness - pick angle offset from away direction
        local angleOffset = (math.random() - 0.5) * math.pi  -- -90 to +90 degrees
        local cos, sin = math.cos(angleOffset), math.sin(angleOffset)
        unpredictableWalkDirection = Vector3.new(
            awayDir.X * cos - awayDir.Z * sin,
            0,
            awayDir.X * sin + awayDir.Z * cos
        )
        
        -- Random chance to jump
        if math.random() < CONFIG.UNAVAILABLE_JUMP_CHANCE then
            pcall(function()
                VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Space, false, game)
                task.wait(0.1)
                VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Space, false, game)
            end)
        end
    end
    
    -- Move in current direction
    if unpredictableWalkDirection then
        Camera.CameraType = Enum.CameraType.Scriptable
        Camera.CFrame = CFrame.lookAt(myPos, myPos + unpredictableWalkDirection * 20)
        pulseMovementKey(Enum.KeyCode.W)
    end
end

-- =====================================================
-- CHAT/TAUNT SYSTEM
-- =====================================================

local function sendChat(message)
    pcall(function()
        local textChatService = game:GetService("TextChatService")
        local channel = textChatService.TextChannels:FindFirstChild("RBXGeneral")
        if channel then
            channel:SendAsync(message)
        else
            game:GetService("ReplicatedStorage"):FindFirstChild("DefaultChatSystemChatEvents")
                :FindFirstChild("SayMessageRequest"):FireServer(message, "All")
        end
    end)
end

local function sendRandomTaunt()
    local availableTaunts = {}
    for _, taunt in ipairs(TAUNTS) do table.insert(availableTaunts, taunt) end
    if getAltHealth() > 80 then table.insert(availableTaunts, "not even close") end
    if #availableTaunts > 0 then
        sendChat(availableTaunts[math.random(1, #availableTaunts)])
    end
end

-- Forward declaration (used before definition in file)
local stopAllMovementKeys

local function scheduleTaunt(distanceWhenDied)
    if tauntScheduled then return end

    -- Only taunt if we were within range when target died
    if distanceWhenDied and distanceWhenDied > CONFIG.TAUNT_RANGE then
        return  -- Too far away, don't taunt
    end

    tauntScheduled = true
    local delay = CONFIG.TAUNT_MIN_DELAY + math.random() * (CONFIG.TAUNT_MAX_DELAY - CONFIG.TAUNT_MIN_DELAY)
    task.spawn(function()
        task.wait(delay)
        if targetWasDead and not hasSentTaunt then
            -- Pause movement while taunting (0.5-0.8s)
            tauntPauseActive = true
            stopAllMovementKeys()

            sendRandomTaunt()
            hasSentTaunt = true

            -- Random pause duration
            local pauseDuration = 0.5 + math.random() * 0.3  -- 0.5 to 0.8
            task.wait(pauseDuration)
            tauntPauseActive = false
        end
        tauntScheduled = false
    end)
end

-- =====================================================
-- FLIGHT CONTROL
-- =====================================================

local function hasFlight()
    local chars = workspace:FindFirstChild("Characters")
    if not chars then return false end
    local myChar = chars:FindFirstChild(player.Name)
    if not myChar then return false end
    local root = myChar:FindFirstChild("HumanoidRootPart")
    return root and root:FindFirstChild("TelekinesisFlight") ~= nil
end

local lastFlightToggle = 0

local function toggleFlight()
    local now = tick()
    if now - lastFlightToggle < CONFIG.FLIGHT_TOGGLE_COOLDOWN then return end
    lastFlightToggle = now
    task.spawn(function()
        pcall(function()
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game)
            task.wait(0.05)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, game)
        end)
    end)
end

local function manageFlightStamina()
    local stamina = getStamina()
    if not stamina then return end
    local effectiveMin = getEffectiveStaminaMin()
    local effectiveRecharge = getEffectiveStaminaRecharge()
    local currentlyFlying = hasFlight()
    if stamina <= effectiveMin and currentlyFlying then
        toggleFlight()
        flightDisabledForStamina = true
    elseif stamina >= effectiveRecharge and flightDisabledForStamina and not currentlyFlying then
        toggleFlight()
        flightDisabledForStamina = false
    end
end

local function ensureFlight()
    if flightDisabledForStamina then return false end
    local stamina = getStamina()
    if stamina and stamina <= getEffectiveStaminaMin() then return false end
    if not hasFlight() then toggleFlight() end
    return hasFlight()
end

-- =====================================================
-- MOVEMENT KEY PULSING
-- =====================================================

local activeKeyThreads = {}
local keyHeldState = {}

stopAllMovementKeys = function()
    for keyName, _ in pairs(activeKeyThreads) do
        activeKeyThreads[keyName] = nil
    end
    local movementKeys = {Enum.KeyCode.W, Enum.KeyCode.S, Enum.KeyCode.A, Enum.KeyCode.D, Enum.KeyCode.Space}
    for _, keyCode in ipairs(movementKeys) do
        if keyHeldState[keyCode] then
            pcall(function() VirtualInputManager:SendKeyEvent(false, keyCode, false, game) end)
            keyHeldState[keyCode] = false
        end
    end
end

local function pulseMovementKey(keyCode)
    local keyName = tostring(keyCode)
    if activeKeyThreads[keyName] then return end
    activeKeyThreads[keyName] = true
    task.spawn(function()
        pcall(function()
            VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
            keyHeldState[keyCode] = true
        end)
        local startTime = tick()
        while activeKeyThreads[keyName] and (tick() - startTime) < CONFIG.KEY_PULSE_DURATION do
            task.wait(0.1)
        end
        pcall(function()
            VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
            keyHeldState[keyCode] = false
        end)
        activeKeyThreads[keyName] = nil
    end)
end

local function stopMovementKey(keyCode)
    local keyName = tostring(keyCode)
    activeKeyThreads[keyName] = nil
    if keyHeldState[keyCode] then
        pcall(function() VirtualInputManager:SendKeyEvent(false, keyCode, false, game) end)
        keyHeldState[keyCode] = false
    end
end

local function holdKey(keyCode)
    pcall(function() VirtualInputManager:SendKeyEvent(true, keyCode, false, game) end)
end

local function releaseKey(keyCode)
    pcall(function() VirtualInputManager:SendKeyEvent(false, keyCode, false, game) end)
end

local function doRandomWalk()
    local currentTime = tick()
    if not randomWalkDirection or currentTime - lastRandomWalkTime > (1 + math.random()) then
        lastRandomWalkTime = currentTime
        local angle = math.random() * math.pi * 2
        randomWalkDirection = Vector3.new(math.cos(angle), 0, math.sin(angle))
        if math.random() > 0.5 then
            pcall(function()
                VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Space, false, game)
                task.wait(0.1)
                VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Space, false, game)
            end)
        end
    end
    if randomWalkDirection then
        local myRoot = getRoot(player)
        if myRoot then
            Camera.CFrame = CFrame.lookAt(myRoot.Position, myRoot.Position + randomWalkDirection * 20)
            pulseMovementKey(Enum.KeyCode.W)
        end
    end
end

-- Random jump while walking (to get over hills/obstacles)
local function tryRandomJump()
    local currentTime = tick()
    if currentTime - lastJumpTime < CONFIG.JUMP_INTERVAL then
        return false
    end

    -- Only jump if not flying
    if hasFlight() then
        return false
    end

    -- Random chance to jump
    if math.random() < CONFIG.JUMP_CHANCE then
        lastJumpTime = currentTime
        pcall(function()
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Space, false, game)
            task.wait(0.1)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Space, false, game)
        end)
        return true
    end

    return false
end

-- Combat jump (to throw off enemy aim)
local function tryCombatJump()
    local currentTime = tick()
    if currentTime - lastCombatJumpTime < CONFIG.JUMP_INTERVAL then
        return false
    end

    -- Only jump if not flying
    if hasFlight() then
        return false
    end

    -- Higher chance during combat
    if math.random() < CONFIG.COMBAT_JUMP_CHANCE then
        lastCombatJumpTime = currentTime
        pcall(function()
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Space, false, game)
            task.wait(0.1)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Space, false, game)
        end)
        return true
    end

    return false
end

-- =====================================================
-- CURVE ACCELERATION (Flight Speed Boost)
-- =====================================================

local function getCurveDirection(myPos, targetPos, velocity)
    if velocity.Magnitude < CONFIG.CURVE_MIN_VELOCITY then
        return "STRAIGHT", 0
    end

    local toTarget = targetPos - myPos
    toTarget = Vector3.new(toTarget.X, 0, toTarget.Z)

    if toTarget.Magnitude < 1 then
        return "STRAIGHT", 0
    end

    local velDir = Vector3.new(velocity.X, 0, velocity.Z)
    if velDir.Magnitude < 1 then
        return "STRAIGHT", 0
    end

    local cross = velDir.Unit:Cross(toTarget.Unit)

    if cross.Y > CONFIG.CURVE_THRESHOLD then
        return "RIGHT", cross.Y
    elseif cross.Y < -CONFIG.CURVE_THRESHOLD then
        return "LEFT", cross.Y
    else
        return "STRAIGHT", cross.Y
    end
end

local function getPathDeviation(myPos, targetPos, velocity)
    local toTarget = targetPos - myPos
    local distance = toTarget.Magnitude

    if distance < 10 then
        return 0, 0
    end

    local toTargetUnit = toTarget.Unit
    local velOnPath = velocity:Dot(toTargetUnit)

    local velPerp = velocity - (toTargetUnit * velOnPath)
    local deviation = velPerp.Magnitude

    local maxDeviation = distance * CONFIG.CURVE_DEVIATION_RATIO

    return deviation, maxDeviation
end

local function pulseCurveAcceleration(myPos, targetPos)
    local myRoot = getRoot(player)
    if not myRoot then
        pulseMovementKey(Enum.KeyCode.W)
        return false
    end

    local velocity = myRoot.Velocity
    local curveDir, crossY = getCurveDirection(myPos, targetPos, velocity)
    local deviation, maxDeviation = getPathDeviation(myPos, targetPos, velocity)

    pulseMovementKey(Enum.KeyCode.W)

    if deviation > maxDeviation and maxDeviation > 0 then
        if crossY > 0 then
            pulseMovementKey(Enum.KeyCode.A)
            return true, "CORRECT_LEFT"
        elseif crossY < 0 then
            pulseMovementKey(Enum.KeyCode.D)
            return true, "CORRECT_RIGHT"
        end
    end

    if curveDir == "RIGHT" then
        pulseMovementKey(Enum.KeyCode.D)
        return true, "CURVE_RIGHT"
    elseif curveDir == "LEFT" then
        pulseMovementKey(Enum.KeyCode.A)
        return true, "CURVE_LEFT"
    end

    return false, "STRAIGHT"
end

-- =====================================================
-- MOUSE HELPERS
-- =====================================================

local function getScreenCenter()
    local viewportSize = Camera.ViewportSize
    return viewportSize.X / 2, viewportSize.Y / 2
end

local function moveMouseToCenter()
    pcall(function()
        local centerX, centerY = getScreenCenter()
        VirtualInputManager:SendMouseMoveEvent(centerX, centerY, game)
    end)
end

local function sendMouseClick()
    spawn(function()
        pcall(function()
            local centerX, centerY = getScreenCenter()
            VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, true, game, 0)
            wait(0.05)
            VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, false, game, 0)
        end)
    end)
end

local function sendClickAboveCenter()
    local viewportSize = Camera.ViewportSize
    local centerX = viewportSize.X / 2
    local centerY = viewportSize.Y / 2
    local clickY = centerY - CONFIG.CLICK_ABOVE_OFFSET
    if clickY < 10 then clickY = 10 end

    pcall(function()
        VirtualInputManager:SendMouseButtonEvent(centerX, clickY, 0, true, game, 0)
    end)
    task.wait(0.05)
    pcall(function()
        VirtualInputManager:SendMouseButtonEvent(centerX, clickY, 0, false, game, 0)
    end)
end

local function sendClickBelowCenter()
    local viewportSize = Camera.ViewportSize
    local centerX = viewportSize.X / 2
    local centerY = viewportSize.Y / 2
    local clickY = centerY + CONFIG.CLICK_BELOW_OFFSET
    if clickY > viewportSize.Y - 10 then clickY = viewportSize.Y - 10 end

    pcall(function()
        VirtualInputManager:SendMouseButtonEvent(centerX, clickY, 0, true, game, 0)
    end)
    task.wait(0.05)
    pcall(function()
        VirtualInputManager:SendMouseButtonEvent(centerX, clickY, 0, false, game, 0)
    end)
end

-- =====================================================
-- STUCK DETECTION
-- =====================================================

local function isVelocityStuck(velocity)
    return math.abs(velocity.X) < CONFIG.STUCK_VELOCITY_THRESHOLD
       and math.abs(velocity.Z) < CONFIG.STUCK_VELOCITY_THRESHOLD
end

local function scanForAlternativePath(myPos, targetPos)
    local toTarget = (targetPos - myPos).Unit
    local numPoints = CONFIG.UNSTUCK_SPHERE_POINTS
    local goldenRatio = (1 + math.sqrt(5)) / 2

    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {
        workspace:FindFirstChild("Characters"),
        player.Character,
        targetPlayer and targetPlayer.Character
    }

    local bestDirection = nil
    local bestScore = -math.huge

    for i = 0, numPoints - 1 do
        local theta = 2 * math.pi * i / goldenRatio
        local phi = math.acos(1 - 2 * (i + 0.5) / numPoints)
        local x = math.sin(phi) * math.cos(theta)
        local y = math.cos(phi)
        local z = math.sin(phi) * math.sin(theta)
        local dir = Vector3.new(x, y, z)

        local result = workspace:Raycast(myPos, dir * CONFIG.UNSTUCK_SCAN_DISTANCE, raycastParams)
        local clearDistance = result and (result.Position - myPos).Magnitude or CONFIG.UNSTUCK_SCAN_DISTANCE
        local dotToTarget = dir:Dot(toTarget)
        local score = clearDistance + (dotToTarget * 15)
        if dir.Y > 0.3 then score = score + 20 end
        if dotToTarget < -0.8 then score = score - 10 end
        if clearDistance > 15 and score > bestScore then
            bestScore = score
            bestDirection = dir
        end
    end

    return bestDirection or Vector3.new(0, 1, 0)
end

local function startUnsticking(myPos, targetPos)
    isUnsticking = true
    unstickDirection = scanForAlternativePath(myPos, targetPos)
    unstickEndTime = tick() + CONFIG.UNSTUCK_DURATION
    stopAllMovementKeys()
end

local function updateStuckDetection(myPos, deltaTime)
    local currentTime = tick()
    if lastPosition and lastPositionTime > 0 then
        local timeDelta = currentTime - lastPositionTime
        if timeDelta > 1 then
            stuckTimer = 0
            lastPosition = myPos
            lastPositionTime = currentTime
            return 0
        end
        if timeDelta > 0 then
            local velocity = (myPos - lastPosition) / timeDelta
            if isVelocityStuck(velocity) then
                stuckTimer = stuckTimer + deltaTime
            else
                stuckTimer = 0
            end
        end
    end
    lastPosition = myPos
    lastPositionTime = currentTime
    return stuckTimer
end

local function resetStuckDetection()
    stuckTimer = 0
    lastPosition = nil
    lastPositionTime = 0
    isUnsticking = false
    unstickDirection = nil
    unstickEndTime = 0
end

-- =====================================================
-- LINE OF SIGHT
-- =====================================================

local function getRaycastFilter()
    local filterList = {
        workspace:FindFirstChild("Characters"),
        player.Character,
        targetPlayer and targetPlayer.Character
    }

    local trunks = workspace:FindFirstChild("World") and workspace.World:FindFirstChild("Trunks")
    if trunks then
        for _, tree in ipairs(trunks:GetChildren()) do
            table.insert(filterList, tree)
        end
    end

    local earth = workspace:FindFirstChild("World") and workspace.World:FindFirstChild("Earth")
    if earth then
        for _, earthPart in ipairs(earth:GetChildren()) do
            table.insert(filterList, earthPart)
        end
    end

    return filterList
end

local function isInFlyroShield(targetPos)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Whitelist

    local shieldParts = workspace:FindFirstChild("World") and workspace.World:FindFirstChild("ShieldParts")
    if not shieldParts then return false end

    raycastParams.FilterDescendantsInstances = {shieldParts}

    local result = workspace:Raycast(targetPos, Vector3.new(0, 50, 0), raycastParams)
    if result and result.Instance then
        local parent = result.Instance.Parent
        if parent and parent:FindFirstChild("Forceshield") then
            return true
        end
    end

    return false
end

-- Check if blocked by Telek Shield (disk) - MUST be from ShieldParts
-- Returns: "FLYRO" (don't grab), "TELEK" (20% chance), or nil (no shield)
local function checkShieldBlocking(fromPos, toPos)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Whitelist

    local shieldParts = workspace:FindFirstChild("World") and workspace.World:FindFirstChild("ShieldParts")
    if not shieldParts then return nil end

    raycastParams.FilterDescendantsInstances = {shieldParts}

    local result = workspace:Raycast(fromPos, toPos - fromPos, raycastParams)
    if result and result.Instance then
        -- Must be a descendant of ShieldParts to count as a shield
        local part = result.Instance
        if part:IsDescendantOf(shieldParts) then
            local parent = part.Parent
            if parent then
                if parent:FindFirstChild("Forceshield") then
                    return "FLYRO"
                elseif parent:FindFirstChild("Telekinesis") then
                    return "TELEK"
                end
            end
        end
    end

    return nil
end

local function canGrabTarget(myPos, targetPos)
    if isInFlyroShield(targetPos) then
        telekBlockStartTime = 0
        return false, "FLYRO_DOME"
    end

    local shieldType = checkShieldBlocking(myPos, targetPos)
    if shieldType == "FLYRO" then
        telekBlockStartTime = 0
        return false, "FLYRO_BLOCKED"
    elseif shieldType == "TELEK" then
        local currentTime = tick()

        if telekBlockStartTime == 0 then
            telekBlockStartTime = currentTime
            lastTelekRollTime = currentTime
        end

        if currentTime - lastTelekRollTime >= 1.0 then
            lastTelekRollTime = currentTime
            if math.random() < CONFIG.TELEK_GRAB_CHANCE then
                telekBlockStartTime = 0
                return true, "TELEK_THROUGH"
            end
        end

        return false, "TELEK_BLOCKED"
    end

    telekBlockStartTime = 0
    return true, "CLEAR"
end

-- Check if target is trapped inside earth/boulder (check 6 directions within 10 studs)
-- If trapped on all sides, don't throw through earth
local function isTargetTrappedInEarth(targetPos)
    local earth = workspace:FindFirstChild("World") and workspace.World:FindFirstChild("Earth")
    if not earth then return false end
    
    local checkDist = 10
    local directions = {
        Vector3.new(1, 0, 0),   -- Right
        Vector3.new(-1, 0, 0),  -- Left
        Vector3.new(0, 1, 0),   -- Top
        Vector3.new(0, -1, 0),  -- Bottom
        Vector3.new(0, 0, 1),   -- Front
        Vector3.new(0, 0, -1),  -- Back
    }
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Whitelist
    raycastParams.FilterDescendantsInstances = {earth}
    
    local blockedCount = 0
    for _, dir in ipairs(directions) do
        local result = workspace:Raycast(targetPos, dir * checkDist, raycastParams)
        if result then
            blockedCount = blockedCount + 1
        end
    end
    
    -- If blocked on 4+ sides, they're trapped
    return blockedCount >= 4
end

-- Unified check for target unavailability (all treated the same way)
-- Returns: reason string or nil if available
local function checkTargetUnavailable(myPos, targetPos)
    if not targetPos then return nil end
    
    -- Check invisible
    if isTargetInvisible() then
        return "INVISIBLE"
    end
    
    -- Check under map (Y position)
    if isTargetUnderMap(targetPos) then
        return "UNDER_MAP"
    end
    
    -- Check terrain blocked (not in river) - indicates under map
    if isTargetBehindTerrain(myPos, targetPos) then
        return "TERRAIN_BLOCKED"
    end
    
    -- Check flyro shield
    if isInFlyroShield(targetPos) then
        return "FLYRO"
    end
    
    -- Check boulder trapped
    if isTargetTrappedInEarth(targetPos) then
        return "BOULDER"
    end
    
    return nil  -- Target is available
end

local function hasLineOfSight(fromPos, toPos)
    if not fromPos or not toPos then return false end
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = getRaycastFilter()
    local result = workspace:Raycast(fromPos, toPos - fromPos, raycastParams)
    if not result then return true end
    return (result.Position - toPos).Magnitude < 5
end

local function hasCompleteLineOfSight(myRoot, targetRoot)
    if not myRoot or not targetRoot then return false end
    local myPos = myRoot.Position
    local targetPos = targetRoot.Position
    local direction = (targetPos - myPos).Unit

    local upVector = Vector3.new(0, 1, 0)
    local rightVector = direction:Cross(upVector)
    if rightVector.Magnitude < 0.1 then rightVector = direction:Cross(Vector3.new(1, 0, 0)) end
    rightVector = rightVector.Unit
    local upPerpVector = rightVector:Cross(direction).Unit

    local spreadRadius = 3
    local coneRays = {targetPos}
    local numRingRays = CONFIG.LINE_OF_SIGHT_CHECKS - 1
    for i = 1, numRingRays do
        local angle = (i / numRingRays) * math.pi * 2
        local offset = rightVector * math.cos(angle) * spreadRadius + upPerpVector * math.sin(angle) * spreadRadius
        table.insert(coneRays, targetPos + offset)
    end

    local visibleRays = 0
    for _, endPoint in ipairs(coneRays) do
        if hasLineOfSight(myPos, endPoint) then visibleRays = visibleRays + 1 end
    end
    return visibleRays >= math.ceil(#coneRays * 0.5)
end

local function isTargetBlockedByTerrainBelow(myPos, targetPos)
    if targetPos.Y >= myPos.Y then return false end

    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = getRaycastFilter()

    local result = workspace:Raycast(myPos, targetPos - myPos, raycastParams)
    if result then
        local hitPart = result.Instance
        if hitPart and (hitPart:IsDescendantOf(workspace.Terrain) or hitPart.Name == "Terrain" or hitPart.Anchored) then
            return true
        end
    end

    return false
end

-- =====================================================
-- VISUAL INDICATORS
-- =====================================================

local function createTargetIndicator()
    if targetIndicator then targetIndicator:Destroy(); targetIndicator = nil end
    if targetBillboard then targetBillboard:Destroy(); targetBillboard = nil end
    if not targetPlayer then return end

    local targetChar = getChar(targetPlayer)
    local targetRoot = getRoot(targetPlayer)
    if not targetChar or not targetRoot then return end

    local selectionBox = Instance.new("SelectionBox")
    selectionBox.Name = "TargetIndicator"
    selectionBox.Adornee = targetChar
    selectionBox.Color3 = Color3.fromRGB(255, 0, 0)
    selectionBox.LineThickness = 0.1
    selectionBox.Transparency = 0.3
    selectionBox.Parent = targetChar
    targetIndicator = selectionBox

    local billboard = Instance.new("BillboardGui")
    billboard.Name = "TargetBillboard"
    billboard.Adornee = targetRoot
    billboard.Size = UDim2.new(0, 200, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 5, 0)
    billboard.AlwaysOnTop = true

    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 1, 0)
    frame.BackgroundTransparency = 0.5
    frame.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    frame.BorderSizePixel = 0
    frame.Parent = billboard

    local text = Instance.new("TextLabel")
    text.Size = UDim2.new(1, 0, 1, 0)
    text.BackgroundTransparency = 1
    text.Text = "üéØ TARGET"
    text.TextColor3 = Color3.fromRGB(255, 255, 255)
    text.TextScaled = true
    text.Font = Enum.Font.SourceSansBold
    text.Parent = frame

    billboard.Parent = targetRoot
    targetBillboard = billboard
end

local function updateTargetIndicator(status)
    if not targetBillboard then return end
    local frame = targetBillboard:FindFirstChild("Frame")
    if not frame then return end
    local text = frame:FindFirstChild("TextLabel")
    if not text then return end

    local statusConfig = {
        attacking = {Color3.fromRGB(0, 255, 0), "‚öîÔ∏è ATTACKING"},
        invisible = {Color3.fromRGB(128, 0, 255), "üëª INVISIBLE"},
        dead = {Color3.fromRGB(128, 128, 128), "üíÄ DEAD"},
        blocked = {Color3.fromRGB(255, 128, 0), "üö´ BLOCKED"},
        normal = {Color3.fromRGB(255, 0, 0), "üéØ TARGET"}
    }
    local config = statusConfig[status] or statusConfig.normal
    frame.BackgroundColor3 = config[1]
    text.Text = config[2]
    if targetIndicator then targetIndicator.Color3 = config[1] end
end

local function removeTargetIndicator()
    if targetIndicator then targetIndicator:Destroy(); targetIndicator = nil end
    if targetBillboard then targetBillboard:Destroy(); targetBillboard = nil end
end

-- =====================================================
-- DEBUG GUI
-- =====================================================

local function createDebugGui()
    local playerGui = player:WaitForChild("PlayerGui")
    if debugGui then debugGui:Destroy() end

    debugGui = Instance.new("ScreenGui")
    debugGui.Name = "AltFollowDebug"
    debugGui.ResetOnSpawn = false

    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 400, 0, 320)
    frame.Position = UDim2.new(0, 10, 0, 10)
    frame.BackgroundColor3 = Color3.new(0, 0, 0)
    frame.BackgroundTransparency = 0.3
    frame.BorderSizePixel = 2
    frame.BorderColor3 = Color3.new(0, 1, 1)
    frame.Parent = debugGui

    local textLabel = Instance.new("TextLabel")
    textLabel.Name = "DebugText"
    textLabel.Size = UDim2.new(1, -10, 1, -10)
    textLabel.Position = UDim2.new(0, 5, 0, 5)
    textLabel.BackgroundTransparency = 1
    textLabel.TextColor3 = Color3.new(1, 1, 1)
    textLabel.TextXAlignment = Enum.TextXAlignment.Left
    textLabel.TextYAlignment = Enum.TextYAlignment.Top
    textLabel.TextSize = 12
    textLabel.Font = Enum.Font.Code
    textLabel.Text = "Debug Info"
    textLabel.Parent = frame

    debugGui.Parent = playerGui
end

local function updateDebug(info)
    if debugGui then
        local textLabel = debugGui:FindFirstChild("DebugText", true)
        if textLabel then textLabel.Text = info end
    end
end

-- =====================================================
-- SPECTATE CONTROL
-- =====================================================

local function startSpectating()
    if spectating then return end
    if not canEnterCombatMode() then return end
    spectating = true
    Camera.CameraType = Enum.CameraType.Scriptable
    UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
end

local function stopSpectating()
    if not spectating then return end
    spectating = false
    Camera.CameraType = Enum.CameraType.Custom
    local hum = getHumanoid(player)
    if hum then Camera.CameraSubject = hum end
    UserInputService.MouseBehavior = Enum.MouseBehavior.Default
end

local function updateSpectateCamera()
    if not spectating or not targetPlayer then return end
    local targetRoot = getRoot(targetPlayer)
    if targetRoot then
        local targetPos = targetRoot.Position
        Camera.CFrame = CFrame.lookAt(targetPos + Vector3.new(0, 5, 10), targetPos)
    end
end

local function moveWhileSpectating(moveToward)
    local myRoot = getRoot(player)
    local targetRoot = getRoot(targetPlayer)
    if not myRoot or not targetRoot then return end

    local myPos = myRoot.Position
    local targetPos = targetRoot.Position
    local camCFrame = Camera.CFrame

    local altInCamSpace = camCFrame:PointToObjectSpace(myPos)
    local targetInCamSpace = camCFrame:PointToObjectSpace(targetPos)
    local dirInCamSpace = (targetInCamSpace - altInCamSpace).Unit
    if not moveToward then dirInCamSpace = -dirInCamSpace end

    stopAllMovementKeys()
    if dirInCamSpace.Z < -0.2 then pulseMovementKey(Enum.KeyCode.W) end
    if dirInCamSpace.Z > 0.2 then pulseMovementKey(Enum.KeyCode.S) end
    if dirInCamSpace.X < -0.2 then pulseMovementKey(Enum.KeyCode.A) end
    if dirInCamSpace.X > 0.2 then pulseMovementKey(Enum.KeyCode.D) end
end

local cameraUpdateConnection = nil

local function startCameraUpdate()
    if cameraUpdateConnection then return end
    cameraUpdateConnection = RunService.RenderStepped:Connect(function()
        if spectating and targetPlayer and not altIsDead then
            updateSpectateCamera()
        end
    end)
end

local function stopCameraUpdate()
    if cameraUpdateConnection then
        cameraUpdateConnection:Disconnect()
        cameraUpdateConnection = nil
    end
end

-- =====================================================
-- COMBAT SYSTEM
-- =====================================================

local lastCanAttackCheck = 0
local lastCanAttackResult = false
local sustainedAttackMode = false
local sustainedDamageAccumulated = 0
local lastDamageTime = 0
local SUSTAINED_DAMAGE_MIN = 20
local SUSTAINED_DAMAGE_MAX = 30
local SUSTAINED_DAMAGE_TIMEOUT = 0.5

local function checkDamageTaken()
    local currentHealth = getAltHealth()
    local damageTaken = lastKnownHealth - currentHealth
    if currentHealth < lastKnownHealth then
        lastKnownHealth = currentHealth
    elseif currentHealth > lastKnownHealth then
        lastKnownHealth = currentHealth
        return 0
    end
    return damageTaken
end

local function updateSustainedAttackMode()
    local damageTaken = checkDamageTaken()
    local currentTime = tick()

    if damageTaken > 0 then
        sustainedDamageAccumulated = sustainedDamageAccumulated + damageTaken
        lastDamageTime = currentTime

        if sustainedDamageAccumulated >= SUSTAINED_DAMAGE_MIN and sustainedDamageAccumulated <= SUSTAINED_DAMAGE_MAX then
            sustainedAttackMode = true
        end
    end

    if sustainedAttackMode and (currentTime - lastDamageTime) > SUSTAINED_DAMAGE_TIMEOUT then
        sustainedAttackMode = false
        sustainedDamageAccumulated = 0
    end

    return sustainedAttackMode
end

local function resetDamageTracking()
    lastKnownHealth = getAltHealth()
    sustainedAttackMode = false
    sustainedDamageAccumulated = 0
    lastDamageTime = 0
end

local function canAttackNow()
    local now = tick()
    if now - lastCanAttackCheck < 0.2 then return lastCanAttackResult end
    lastCanAttackCheck = now

    if now - lastQClickTime < CONFIG.Q_CLICK_COOLDOWN then lastCanAttackResult = false; return false end
    if isAttacking then lastCanAttackResult = false; return false end

    local targetPos = getTargetPosition()
    if targetPos and isTargetUnderMap(targetPos) then lastCanAttackResult = false; return false end

    if not sustainedAttackMode then
        local stamina = getStamina()
        if not stamina or stamina < getEffectiveStaminaMin() then lastCanAttackResult = false; return false end
    end

    if targetWasDead or targetWasInvisible then lastCanAttackResult = false; return false end

    lastCanAttackResult = true
    return true
end

local function isInAttackRange(totalDist)
    return totalDist <= CONFIG.OPTIMAL_MAX
end

local function isInComfortRange(totalDist)
    return totalDist >= CONFIG.OPTIMAL_MIN and totalDist <= CONFIG.OPTIMAL_MAX
end

local function checkEmergencyDefense(myPos, targetPos)
    if not targetPlayer or targetWasDead or targetWasInvisible then return false end
    local damageTaken = checkDamageTaken()
    if damageTaken < damageThreshold then return false end
    local totalDist = (targetPos - myPos).Magnitude
    if not isInAttackRange(totalDist) then return false end
    if tick() - lastQClickTime < CONFIG.Q_CLICK_COOLDOWN then return false end
    if isAttacking then return false end
    local stamina = getStamina()
    if not stamina or stamina < getEffectiveStaminaMin() then return false end
    local myRoot = getRoot(player)
    local targetRoot = getRoot(targetPlayer)
    if not myRoot or not targetRoot then return false end
    if not hasCompleteLineOfSight(myRoot, targetRoot) then return false end
    return true
end

local function performEmergencyDefense(myPos, targetPos, interruptedTask)
    emergencyDefenseActive = true
    preEmergencyTask = interruptedTask
    if not spectating then startSpectating() end
    isAttacking = true
    updateTargetIndicator("attacking")

    spawn(function()
        moveMouseToCenter()
        wait(0.03)
        holdKey(Enum.KeyCode.Q)
        wait(0.15)
        sendMouseClick()
        wait(0.2)
        releaseKey(Enum.KeyCode.Q)
        isAttacking = false
        lastQClickTime = tick()
        emergencyDefenseActive = false
        preEmergencyTask = nil
        if currentMode == "ATTACK" and not targetWasInvisible then
            updateTargetIndicator("normal")
        end
    end)
    return true
end

local function performQClickAttack()
    local currentTime = tick()
    if currentTime - lastQClickTime < CONFIG.Q_CLICK_COOLDOWN then return false end
    if isAttacking then return false end

    local myRoot = getRoot(player)
    local targetRoot = getRoot(targetPlayer)
    if not myRoot or not targetRoot then return false end

    local myPos = myRoot.Position
    local targetPos = targetRoot.Position
    local distance = (targetPos - myPos).Magnitude

    if isTargetUnderMap(targetPos) then updateTargetIndicator("blocked"); return false end

    local canGrab, shieldStatus = canGrabTarget(myPos, targetPos)
    if not canGrab then
        updateTargetIndicator("blocked")
        return false
    end
    
    -- Check if target is trapped inside earth/boulder
    if isTargetTrappedInEarth(targetPos) then
        updateTargetIndicator("blocked")
        return false
    end

    if cachedTargetInWater then
        local validPos = isValidUnderwaterAttackPosition(myPos, targetPos)
        if not validPos then return false end
    end

    local hasLOS = hasCompleteLineOfSight(myRoot, targetRoot)
    if not hasLOS and isInRiverBounds(targetPos) then
        if canGrabRiverTarget(myPos, targetPos) then hasLOS = true end
    end
    if not hasLOS then updateTargetIndicator("blocked"); return false end

    local pullThreshold = CONFIG.OPTIMAL_MAX - 5
    local shouldPull = distance >= pullThreshold

    isAttacking = true
    updateTargetIndicator("attacking")

    spawn(function()
        Camera.CameraType = Enum.CameraType.Scriptable
        Camera.CFrame = CFrame.lookAt(myPos, targetPos)

        wait(0.05)
        holdKey(Enum.KeyCode.Q)
        wait(0.2)

        if shouldPull then
            sendClickBelowCenter()
        else
            sendClickAboveCenter()
        end

        wait(0.3)
        releaseKey(Enum.KeyCode.Q)
        isAttacking = false
        justAttacked = true
        lastQClickTime = tick()
        if currentMode == "ATTACK" and not targetWasInvisible then
            updateTargetIndicator("normal")
        end
    end)
    return true
end

-- =====================================================
-- MAIN MOVEMENT CALCULATION
-- =====================================================

local function calculateMovementAndMode(myPos, targetPos)
    local fullVector = targetPos - myPos
    local horizontalVector = Vector3.new(fullVector.X, 0, fullVector.Z)
    local horizontalDistance = horizontalVector.Magnitude
    local verticalDiff = fullVector.Y
    local totalDistance = fullVector.Magnitude

    local newMode = currentMode
    if flightDisabledForStamina then
        newMode = "STAMINA_REGEN"
    elseif totalDistance > CONFIG.COMBAT_ZONE then
        newMode = "TRAVEL"
    elseif totalDistance > CONFIG.OPTIMAL_MAX then
        newMode = "APPROACH"
    elseif isInComfortRange(totalDistance) then
        newMode = "ATTACK"
    else
        newMode = "TOO_CLOSE"
    end

    return newMode, horizontalDistance, verticalDiff, horizontalVector, totalDistance
end

-- =====================================================
-- TARGET SELECTION + MULTI-TARGET
-- =====================================================

local function getClosestPlayerToCursor()
    local closest = nil
    local minDist = math.huge
    local mousePos = UserInputService:GetMouseLocation()

    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= player then
            local root = getRoot(plr)
            if root then
                local success, pos, onScreen = pcall(function()
                    return Camera:WorldToViewportPoint(root.Position)
                end)
                if success and onScreen then
                    local screenDist = (Vector2.new(pos.X, pos.Y) - mousePos).Magnitude
                    if screenDist < minDist then
                        minDist = screenDist
                        closest = plr
                    end
                end
            end
        end
    end
    return closest
end

local function isSecondaryTargetById(userId)
    for i, uid in ipairs(secondaryTargetUserIds) do
        if uid == userId then
            return true, i
        end
    end
    return false, 0
end

local function getPlayerByUserId(userId)
    for _, plr in pairs(Players:GetPlayers()) do
        if plr.UserId == userId then
            return plr
        end
    end
    return nil
end

local function addSecondaryTarget(plr)
    if not plr then return false end
    if targetPlayer and plr.UserId == targetPlayer.UserId then return false end
    local exists, _ = isSecondaryTargetById(plr.UserId)
    if exists then return false end
    if #secondaryTargetUserIds >= MAX_SECONDARY_TARGETS then
        return false
    end
    table.insert(secondaryTargetUserIds, plr.UserId)
    print("Added secondary target #" .. #secondaryTargetUserIds .. ": " .. plr.Name)
    return true
end

local function removeSecondaryTarget(plr)
    if not plr then return false end
    local exists, index = isSecondaryTargetById(plr.UserId)
    if exists then
        table.remove(secondaryTargetUserIds, index)
        print("Removed secondary target: " .. plr.Name)
        return true
    end
    return false
end

local function toggleSecondaryTarget(plr)
    if not plr then return end
    local exists, _ = isSecondaryTargetById(plr.UserId)
    if exists then
        removeSecondaryTarget(plr)
    else
        if not addSecondaryTarget(plr) then
            if #secondaryTargetUserIds >= MAX_SECONDARY_TARGETS then
                print("Max secondary targets reached (" .. MAX_SECONDARY_TARGETS .. ")")
            end
        end
    end
end

local function getNextTarget(myPos)
    -- Find the lowest HP secondary target within range
    -- Like "your friend told you about someone" - you only see them if within 140 studs
    if #secondaryTargetUserIds == 0 then
        return nil
    end
    
    local bestTarget = nil
    local lowestHP = math.huge
    
    for _, userId in ipairs(secondaryTargetUserIds) do
        local plr = getPlayerByUserId(userId)
        if plr and plr.Parent then
            local root = getRoot(plr)
            if root and isPlayerAlive(plr) then
                -- Check if within "sight" range
                local dist = myPos and (root.Position - myPos).Magnitude or 0
                if not myPos or dist <= CONFIG.SECONDARY_TARGET_RANGE then
                    -- Get their HP
                    local hum = getHumanoid(plr)
                    local hp = hum and hum.Health or 100
                    if hp < lowestHP then
                        lowestHP = hp
                        bestTarget = plr
                    end
                end
            end
        end
    end
    
    return bestTarget
end

local function getSecondaryTargetNames()
    local names = {}
    for _, userId in ipairs(secondaryTargetUserIds) do
        local plr = getPlayerByUserId(userId)
        if plr and plr.Name then
            if isPlayerAlive(plr) then
                table.insert(names, plr.Name)
            else
                table.insert(names, plr.Name .. "(dead)")
            end
        else
            table.insert(names, "[offline]")
        end
    end
    return names
end

local function switchToNextTarget(myPos)
    -- Hard reset movement/attack state before changing target (prevents carry-over)
    if spectating then stopSpectating() end
    stopAllMovementKeys()
    releaseKey(Enum.KeyCode.Q)
    releaseKey(Enum.KeyCode.Space)
    isAttacking = false
    resetStuckDetection()
    movementPulseTimer = CONFIG.MOVEMENT_PULSE_RATE

    -- Find lowest HP secondary within range
    local nextTarget = getNextTarget(myPos)

    if nextTarget then
        targetPlayer = nextTarget
        targetWasDead = false
        targetWasInvisible = false
        stoppedFlightForDeath = false
        tauntPauseActive = false
        lastBodyPosition = nil
        onSecondaryTarget = true  -- Mark that we're on a secondary
        createTargetIndicator()
        print("Switched to secondary target: " .. nextTarget.Name)
        return true
    end
    return false
end

-- Check if main target is back and we should switch to them
local function checkMainTargetBack(myPos)
    if not onSecondaryTarget then return false end
    if not originalPrimaryUserId then return false end
    
    local mainPlayer = getPlayerByUserId(originalPrimaryUserId)
    if not mainPlayer or not mainPlayer.Parent then return false end
    
    local mainRoot = getRoot(mainPlayer)
    if not mainRoot then return false end
    if not isPlayerAlive(mainPlayer) then return false end
    
    -- Main is alive! Check grace period
    local now = tick()
    if mainTargetRespawnTime == 0 then
        -- First frame we noticed main is back
        mainTargetRespawnTime = now
    end
    
    -- Grace period: don't switch mid-kill if main JUST respawned
    if now - mainTargetRespawnTime < CONFIG.MAIN_RESPAWN_GRACE then
        return false  -- Still in grace period, finish current kill
    end
    
    -- Switch back to main target immediately
    if spectating then stopSpectating() end
    stopAllMovementKeys()
    releaseKey(Enum.KeyCode.Q)
    isAttacking = false
    
    targetPlayer = mainPlayer
    targetWasDead = false
    targetWasInvisible = false
    stoppedFlightForDeath = false
    tauntPauseActive = false
    lastBodyPosition = nil
    onSecondaryTarget = false
    rememberedTargetUserId = mainPlayer.UserId
    mainTargetRespawnTime = 0  -- Reset
    createTargetIndicator()
    print("Main target back! Switching to: " .. mainPlayer.Name)
    return true
end

local function clearSecondaryTargets()
    secondaryTargetUserIds = {}
    onSecondaryTarget = false
end

-- =====================================================
-- MAIN FOLLOW LOOP
-- =====================================================

local movementLoop = nil

local function startMovementLoop()
    movementLoop = RunService.Heartbeat:Connect(function(deltaTime)
        if not following or not targetPlayer then return end
        if altIsDead then return end

        local myRoot = getRoot(player)
        local targetPos = getTargetPosition()
        if not myRoot or not targetPos then return end
        local myPos = myRoot.Position

        local currentFrameTime = tick()
        if lastFrameTime > 0 then
            local frameGap = currentFrameTime - lastFrameTime
            if frameGap > 0.5 then
                for keyName in pairs(activeKeyThreads) do activeKeyThreads[keyName] = nil end
                movementPulseTimer = CONFIG.MOVEMENT_PULSE_RATE
            end
        end
        lastFrameTime = currentFrameTime

        manageFlightStamina()
        updateSustainedAttackMode()
        
        -- PRIORITY: Check if main target is back while we're on a secondary
        if onSecondaryTarget and checkMainTargetBack(myPos) then
            ensureFlight()
            return  -- Switched back to main, restart loop
        end

        local currentTime = tick()
        if currentTime - lastUnderwaterCheck > 0.25 then
            lastUnderwaterCheck = currentTime
            local wasUnderwater = isUnderwater
            isUnderwater = checkUnderwater()
            cachedTargetInWater = isTargetUnderwater()
            if not isUnderwater and wasUnderwater then
                airRemaining = CONFIG.UNDERWATER_MAX_TIME
                resurfaceStarted = false
            end
        end

        if isUnderwater then
            airRemaining = airRemaining - deltaTime
        else
            airRemaining = CONFIG.UNDERWATER_MAX_TIME
            resurfaceStarted = false
        end

        if spectating and not canEnterCombatMode() then stopSpectating() end
        
        -- Update river method state (check if target entered/exited river)
        updateRiverMethodState(targetPos, currentTime)
        
        -- Reset river method on target death or invisible
        if targetWasDead or targetWasInvisible then
            riverMethodActive = false
            targetTouchedWater = false
            targetWaterStartTime = 0
        end

        -- RIVER METHOD: Committed underwater fighting with dolphin dive
        -- Alt must be UNDERWATER to attack
        -- Target can be up to 20 studs above surface (river method stays active)
        -- Alt keeps diving back as long as river method is active
        if riverMethodActive and not targetWasDead and not targetWasInvisible then
            
            -- Safety: Don't go under the map
            local safeTargetPos = targetPos
            if targetPos.Y < CONFIG.UNDER_MAP_Y + 10 then
                safeTargetPos = Vector3.new(targetPos.X, CONFIG.UNDER_MAP_Y + 15, targetPos.Z)
            end
            
            -- Calculate distance to target
            local vec = safeTargetPos - myPos
            local totalDist = vec.Magnitude
            
            -- Step 1: Fly to river if not in river bounds horizontally
            if not isInRiverBoundsHorizontal(myPos) then
                currentMode = "RIVER_APPROACH"
                if spectating then stopSpectating() end
                ensureFlight()
                Camera.CameraType = Enum.CameraType.Scriptable
                local entryPoint = getRiverDivePoint(myPos, safeTargetPos)
                Camera.CFrame = CFrame.lookAt(myPos, entryPoint)
                if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                    movementPulseTimer = 0
                    pulseMovementKey(Enum.KeyCode.W)
                end
                movementPulseTimer = movementPulseTimer + deltaTime
                return
            end
            
            -- Step 2: Need air - resurface (dolphin up)
            if isUnderwater and airRemaining <= CONFIG.AIR_RESURFACE_THRESHOLD then
                currentMode = "RESURFACE"
                if spectating then stopSpectating() end
                tryResurface(myPos)
                movementPulseTimer = movementPulseTimer + deltaTime
                return
            end
            
            -- Step 3: Not underwater - dive back down (river method still active, so keep diving)
            if not isUnderwater then
                currentMode = "DIVING"
                if spectating then stopSpectating() end
                Camera.CameraType = Enum.CameraType.Scriptable
                -- Aim toward target (dive down toward them)
                Camera.CFrame = CFrame.lookAt(myPos, safeTargetPos, Vector3.new(0, 0, -1))
                if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                    movementPulseTimer = 0
                    pulseMovementKey(Enum.KeyCode.W)
                end
                movementPulseTimer = movementPulseTimer + deltaTime
                return
            end
            
            -- Step 4: Underwater with air - swim toward target and attack
            -- Alt is underwater, target can be up to 20 studs above surface
            currentMode = "RIVER_COMBAT"
            if spectating then stopSpectating() end
            Camera.CameraType = Enum.CameraType.Scriptable
            
            -- If in attack range, try to attack
            if totalDist <= CONFIG.OPTIMAL_MAX then
                local canAttack = currentTime - lastQClickTime >= CONFIG.Q_CLICK_COOLDOWN and not isAttacking
                if canAttack then
                    performQClickAttack()
                end
            end
            
            -- Swim toward target
            Camera.CFrame = CFrame.lookAt(myPos, safeTargetPos)
            if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                movementPulseTimer = 0
                pulseMovementKey(Enum.KeyCode.W)
            end
            movementPulseTimer = movementPulseTimer + deltaTime
            return  -- Don't fall through to normal combat
        end

        -- Forced resurface when completely out of air (safety net - not in river method)
        if isUnderwater and airRemaining <= 0 then
            if not resurfaceStarted then
                resurfaceStarted = true
                resetDamageTracking()
            end
            if checkEmergencyDefense(myPos, targetPos) then
                performEmergencyDefense(myPos, targetPos, "RESURFACE")
            else
                if spectating then stopSpectating() end
            end
            if not isAttacking then tryResurface(myPos) end
            movementPulseTimer = movementPulseTimer + deltaTime
            return
        end

        if currentTime - lastTargetCheck > CONFIG.TARGET_CHECK_RATE then
            lastTargetCheck = currentTime
            local alive = isTargetAlive()
            local invisible = isTargetInvisible()

            if not alive and not targetWasDead then
                targetWasDead = true
                stopSpectating()
                updateTargetIndicator("dead")
                hasSentTaunt = false
                tauntPauseActive = false
                lastBodyPosition = targetPos
                local deathDistance = targetPos and (targetPos - myPos).Magnitude or 999
                
                -- If we killed a secondary, check if we should go back to main
                if onSecondaryTarget then
                    -- Check if main is back
                    local mainPlayer = originalPrimaryUserId and getPlayerByUserId(originalPrimaryUserId)
                    local mainAlive = mainPlayer and mainPlayer.Parent and getRoot(mainPlayer) and isPlayerAlive(mainPlayer)
                    
                    if mainAlive then
                        -- Main is back! Check grace period
                        local now = tick()
                        if mainTargetRespawnTime > 0 and (now - mainTargetRespawnTime) >= CONFIG.MAIN_RESPAWN_GRACE then
                            -- Grace period over, switch to main immediately
                            targetPlayer = mainPlayer
                            targetWasDead = false
                            targetWasInvisible = false
                            stoppedFlightForDeath = false
                            onSecondaryTarget = false
                            rememberedTargetUserId = mainPlayer.UserId
                            mainTargetRespawnTime = 0
                            createTargetIndicator()
                            ensureFlight()
                            print("Secondary killed, main target back! Switching to: " .. mainPlayer.Name)
                            return
                        end
                    end
                    -- Main not back or grace period - schedule taunt and look for more secondaries
                    scheduleTaunt(deathDistance)
                else
                    -- Main target died - schedule taunt
                    scheduleTaunt(deathDistance)
                end
            elseif alive and targetWasDead then
                targetWasDead = false
                stoppedFlightForDeath = false
                hasSentTaunt = false
                tauntScheduled = false
                tauntPauseActive = false
                lastBodyPosition = nil
                createTargetIndicator()
            end

            if invisible and not targetWasInvisible then
                targetWasInvisible = true
                updateTargetIndicator("invisible")
            elseif not invisible and targetWasInvisible then
                targetWasInvisible = false
                updateTargetIndicator("normal")
            end
        end

        -- UNIFIED UNAVAILABLE CHECK
        -- Treats invisible, under map, flyro shield, boulder trap all the same:
        -- Fly to 100 studs ‚Üí land ‚Üí walk around unpredictably ‚Üí stay ~100 studs
        local unavailableReasonNow = checkTargetUnavailable(myPos, targetPos)
        
        if unavailableReasonNow then
            -- Target is unavailable
            if not targetUnavailable then
                targetUnavailable = true
                unavailableReason = unavailableReasonNow
                unavailableRetreatDone = false
                updateTargetIndicator("blocked")
                print("Target unavailable: " .. unavailableReasonNow)
            end
            
            local distToTarget = (targetPos - myPos).Magnitude
            local minDist = CONFIG.UNAVAILABLE_RETREAT_DIST - CONFIG.UNAVAILABLE_STAY_RANGE  -- 70
            local maxDist = CONFIG.UNAVAILABLE_RETREAT_DIST + CONFIG.UNAVAILABLE_STAY_RANGE  -- 130
            
            if spectating then stopSpectating() end
            
            -- Phase 1: Fly away to 100 studs if too close
            if distToTarget < minDist then
                currentMode = "UNAVAILABLE_RETREAT"
                ensureFlight()
                Camera.CameraType = Enum.CameraType.Scriptable
                local awayDir = (myPos - targetPos)
                if awayDir.Magnitude > 0.1 then awayDir = awayDir.Unit else awayDir = Vector3.new(1, 0, 0) end
                Camera.CFrame = CFrame.lookAt(myPos, myPos + awayDir * 50)
                if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                    movementPulseTimer = 0
                    pulseMovementKey(Enum.KeyCode.W)
                end
                movementPulseTimer = movementPulseTimer + deltaTime
                return
            end
            
            -- Phase 2: In range (70-130 studs) - land and walk unpredictably
            if distToTarget >= minDist and distToTarget <= maxDist then
                currentMode = "UNAVAILABLE_IDLE"
                unavailableRetreatDone = true
                
                -- Land if flying
                if hasFlight() then
                    toggleFlight()
                end
                
                -- Walk around unpredictably
                doUnpredictableWalk(myPos, targetPos)
                movementPulseTimer = movementPulseTimer + deltaTime
                return
            end
            
            -- Phase 3: Too far - walk toward target to stay in range
            if distToTarget > maxDist then
                currentMode = "UNAVAILABLE_APPROACH"
                -- Walk toward, don't fly
                if hasFlight() then
                    toggleFlight()
                end
                Camera.CameraType = Enum.CameraType.Scriptable
                Camera.CFrame = CFrame.lookAt(myPos, targetPos)
                if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                    movementPulseTimer = 0
                    pulseMovementKey(Enum.KeyCode.W)
                    tryRandomJump()
                end
                movementPulseTimer = movementPulseTimer + deltaTime
                return
            end
        else
            -- Target is available again
            if targetUnavailable then
                targetUnavailable = false
                unavailableReason = nil
                unavailableRetreatDone = false
                targetWasInvisible = false  -- Clear legacy flag
                updateTargetIndicator("normal")
                ensureFlight()
                print("Target available again!")
            end
        end

        if targetWasDead then
            currentMode = "WAITING"
            if not stoppedFlightForDeath and hasFlight() then
                toggleFlight()
                stoppedFlightForDeath = true
            end

            if tauntPauseActive then
                movementPulseTimer = movementPulseTimer + deltaTime
                return
            end

            local distFromBody = lastBodyPosition and (myPos - lastBodyPosition).Magnitude or 0
            local walkedAwayEnough = distFromBody > 30
            
            -- When on secondary and target died, first priority is check if main is back
            if onSecondaryTarget then
                local mainPlayer = originalPrimaryUserId and getPlayerByUserId(originalPrimaryUserId)
                local mainAlive = mainPlayer and mainPlayer.Parent and getRoot(mainPlayer) and isPlayerAlive(mainPlayer)
                
                if mainAlive then
                    local now = tick()
                    -- Track when we first noticed main is back
                    if mainTargetRespawnTime == 0 then
                        mainTargetRespawnTime = now
                    end
                    -- Check grace period
                    if (now - mainTargetRespawnTime) >= CONFIG.MAIN_RESPAWN_GRACE then
                        -- Switch back to main
                        targetPlayer = mainPlayer
                        targetWasDead = false
                        targetWasInvisible = false
                        stoppedFlightForDeath = false
                        onSecondaryTarget = false
                        rememberedTargetUserId = mainPlayer.UserId
                        mainTargetRespawnTime = 0
                        createTargetIndicator()
                        ensureFlight()
                        print("Main target back! Switching from secondary")
                        return
                    end
                end
                
                -- Main not back or in grace - try another secondary if walked away
                if CONFIG.ENABLE_TARGET_SWITCHING and walkedAwayEnough and (hasSentTaunt or not tauntScheduled) and (not isUnderwater) and (not isAttacking) then
                    if switchToNextTarget(myPos) then
                        ensureFlight()
                        return
                    end
                end
            else
                -- Main target died - check for secondaries (only after finishing task)
                if CONFIG.ENABLE_TARGET_SWITCHING and walkedAwayEnough and (hasSentTaunt or not tauntScheduled) and (not isUnderwater) and (not isAttacking) then
                    if #secondaryTargetUserIds > 0 and switchToNextTarget(myPos) then
                        ensureFlight()
                        return
                    end
                end
            end

            if isUnderwater and airRemaining <= 0 then
                tryResurface(myPos)
            elseif not walkedAwayEnough and lastBodyPosition then
                local awayFromBody = myPos - lastBodyPosition
                if awayFromBody.Magnitude > 0.1 then
                    awayFromBody = Vector3.new(awayFromBody.X, 0, awayFromBody.Z).Unit
                else
                    awayFromBody = Vector3.new(1, 0, 0)
                end

                Camera.CameraType = Enum.CameraType.Scriptable
                Camera.CFrame = CFrame.lookAt(myPos, myPos + awayFromBody * 20)

                if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                    movementPulseTimer = 0
                    pulseMovementKey(Enum.KeyCode.W)
                end
            else
                doRandomWalk()
            end
            movementPulseTimer = movementPulseTimer + deltaTime
            return
        end

        -- (Old invisible and terrain blocked handlers removed - now handled by unified unavailable check above)

        local newMode, hDist, vDiff, hVector, totalDist = calculateMovementAndMode(myPos, targetPos)

        local currentStuckTime = updateStuckDetection(myPos, deltaTime)
        if not isUnsticking and currentStuckTime >= CONFIG.STUCK_TIME_THRESHOLD then
            startUnsticking(myPos, targetPos)
        end
        if isUnsticking and tick() >= unstickEndTime then
            isUnsticking = false
            unstickDirection = nil
            stuckTimer = 0
        end

        local shouldAttack = isInAttackRange(totalDist) and canAttackNow()
        if sustainedAttackMode and canAttackNow() and totalDist <= CONFIG.COMBAT_ZONE then
            shouldAttack = true
        end
        if shouldAttack then
            performQClickAttack()
        end

        if isUnsticking and unstickDirection then
            if spectating then stopSpectating() end
            ensureFlight()
            Camera.CameraType = Enum.CameraType.Scriptable
            Camera.CFrame = CFrame.lookAt(myPos, myPos + unstickDirection * 50)
            if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                movementPulseTimer = 0
                pulseMovementKey(Enum.KeyCode.W)
            end
            movementPulseTimer = movementPulseTimer + deltaTime
            return
        end

        if newMode ~= currentMode then
            stopAllMovementKeys()
            movementPulseTimer = CONFIG.MOVEMENT_PULSE_RATE
            currentMode = newMode
        end

        if totalDist <= CONFIG.COMBAT_ZONE and not spectating then
            startSpectating()
        elseif totalDist > CONFIG.COMBAT_ZONE and spectating then
            stopSpectating()
        end

        movementPulseTimer = movementPulseTimer + deltaTime

        if currentMode == "TRAVEL" or currentMode == "APPROACH" then
            ensureFlight()
            Camera.CameraType = Enum.CameraType.Scriptable
            Camera.CFrame = CFrame.lookAt(myPos, targetPos)
            if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                movementPulseTimer = 0
                pulseCurveAcceleration(myPos, targetPos)
            end
        elseif currentMode == "ATTACK" then
            ensureFlight()
            if not targetWasInvisible and not isAttacking then
                performQClickAttack()
            end
        elseif currentMode == "TOO_CLOSE" then
            ensureFlight()
            if spectating then
                if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                    movementPulseTimer = 0
                    moveWhileSpectating(false)
                end
            else
                Camera.CameraType = Enum.CameraType.Scriptable
                Camera.CFrame = CFrame.lookAt(myPos, myPos + (myPos - targetPos).Unit * 50)
                if movementPulseTimer >= CONFIG.MOVEMENT_PULSE_RATE then
                    movementPulseTimer = 0
                    pulseMovementKey(Enum.KeyCode.W)
                end
            end
        end

        local stamina = getStamina() or 0
        local attackCooldown = math.max(0, CONFIG.Q_CLICK_COOLDOWN - (tick() - lastQClickTime))
        local queueNames = getSecondaryTargetNames()
        local queueStr = #queueNames > 0 and table.concat(queueNames, "‚Üí") or "none"
        local targetType = onSecondaryTarget and "SECONDARY" or "PRIMARY"
        local riverStatus = riverMethodActive and " [RIVER]" or ""
        local unavailStatus = targetUnavailable and (" [" .. (unavailableReason or "UNAVAIL") .. "]") or ""
        local statusStr = targetWasDead and "DEAD" or (targetUnavailable and unavailableReason or "ALIVE")
        updateDebug(string.format(
            [[Target: %s (%s)%s%s
Mode: %s | Spectating: %s
Distance: H=%.1f V=%.1f Total=%.1f
Optimal: %d-%d studs
Status: %s | Queue: %s
Stamina: %d | Air: %.1fs
Attack CD: %.1fs | Sustained: %s
Flight: %s]],
            targetPlayer and targetPlayer.Name or "nil",
            targetType,
            riverStatus,
            unavailStatus,
            currentMode,
            tostring(spectating),
            (Vector3.new(hVector.X,0,hVector.Z)).Magnitude, vDiff, totalDist,
            CONFIG.OPTIMAL_MIN, CONFIG.OPTIMAL_MAX,
            statusStr,
            queueStr,
            stamina,
            airRemaining,
            attackCooldown,
            tostring(sustainedAttackMode),
            tostring(hasFlight())
        ))
    end)
end

local function stopMovementLoop()
    if movementLoop then movementLoop:Disconnect(); movementLoop = nil end
    releaseKey(Enum.KeyCode.Q)
    isAttacking = false
end

-- =====================================================
-- MAIN CONTROL
-- =====================================================

local function startFollowing()
    flightDisabledForStamina = false
    spectating = false
    altIsDead = false
    justAttacked = false
    ensureFlight()
    createDebugGui()
    createTargetIndicator()

    movementPulseTimer = CONFIG.MOVEMENT_PULSE_RATE
    lastTargetCheck = 0
    targetWasDead = false
    targetWasInvisible = false
    currentMode = "IDLE"
    isAttacking = false
    lastFrameTime = 0

    isUnderwater = false
    airRemaining = CONFIG.UNDERWATER_MAX_TIME
    lastUnderwaterCheck = 0
    cachedTargetInWater = false
    stoppedFlightForDeath = false
    hasSentTaunt = false
    tauntScheduled = false
    tauntPauseActive = false
    lastBodyPosition = nil
    lastRandomWalkTime = 0
    randomWalkDirection = nil
    lastJumpTime = 0
    lastCombatJumpTime = 0
    lastCanAttackCheck = 0
    lastCanAttackResult = false
    emergencyDefenseActive = false
    preEmergencyTask = nil
    lastKnownHealth = getAltHealth()
    resurfaceStarted = false

    sustainedAttackMode = false
    sustainedDamageAccumulated = 0
    lastDamageTime = 0

    retreatActive = false
    retreatPosition = nil
    retreatReason = nil

    telekBlockStartTime = 0
    lastTelekRollTime = 0
    
    -- River method state
    riverMethodActive = false
    targetTouchedWater = false
    targetWaterStartTime = 0
    
    -- Unavailable state
    targetUnavailable = false
    unavailableReason = nil
    unavailableRetreatDone = false
    lastUnpredictableWalkTime = 0
    unpredictableWalkDirection = nil
    
    -- Secondary targeting state
    onSecondaryTarget = false
    mainTargetRespawnTime = 0

    if targetPlayer then
        rememberedTargetUserId = targetPlayer.UserId
    end

    lastVerticalDirection = 0
    verticalDirectionStartTime = 0

    cached2xStamina = nil
    cachedStaminaMin = nil
    cachedStaminaRecharge = nil

    resetStuckDetection()
    startCameraUpdate()
    startMovementLoop()

    print("Started following", targetPlayer and targetPlayer.Name)
end

local function stopFollowing()
    following = false
    targetPlayer = nil
    currentMode = "IDLE"
    flightDisabledForStamina = false
    isAttacking = false
    spectating = false
    altIsDead = false
    isUnderwater = false
    airRemaining = CONFIG.UNDERWATER_MAX_TIME
    cachedTargetInWater = false
    stoppedFlightForDeath = false
    hasSentTaunt = false
    tauntScheduled = false
    tauntPauseActive = false
    lastBodyPosition = nil
    lastRandomWalkTime = 0
    randomWalkDirection = nil
    lastJumpTime = 0
    lastCombatJumpTime = 0
    emergencyDefenseActive = false
    preEmergencyTask = nil
    lastKnownHealth = 100
    resurfaceStarted = false

    sustainedAttackMode = false
    sustainedDamageAccumulated = 0
    lastDamageTime = 0

    rememberedTargetUserId = nil
    originalPrimaryUserId = nil
    manuallySwitchedTarget = false
    mainTargetRespawnTime = 0
    onSecondaryTarget = false
    retreatActive = false
    retreatPosition = nil
    retreatReason = nil

    telekBlockStartTime = 0
    lastTelekRollTime = 0
    
    -- River method state
    riverMethodActive = false
    targetTouchedWater = false
    targetWaterStartTime = 0
    
    -- Unavailable state
    targetUnavailable = false
    unavailableReason = nil
    unavailableRetreatDone = false
    lastUnpredictableWalkTime = 0
    unpredictableWalkDirection = nil

    clearSecondaryTargets()

    resetStuckDetection()
    stopMovementLoop()
    stopCameraUpdate()
    stopAllMovementKeys()
    releaseKey(Enum.KeyCode.Q)
    releaseKey(Enum.KeyCode.Space)

    Camera.CameraType = Enum.CameraType.Custom
    local hum = getHumanoid(player)
    if hum then Camera.CameraSubject = hum end
    UserInputService.MouseBehavior = Enum.MouseBehavior.Default

    removeTargetIndicator()
    if debugGui then debugGui:Destroy(); debugGui = nil end

    print("Stopped following")
end

-- =====================================================
-- INPUT HANDLER
-- =====================================================

UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end

    if input.KeyCode == Enum.KeyCode.N then
        if not following then
            local target = getClosestPlayerToCursor()
            if target then
                targetPlayer = target
                following = true
                lastKnownPosition = nil
                manuallySwitchedTarget = false
                originalPrimaryUserId = target.UserId
                startFollowing()
            else
                warn("No player found near cursor")
            end
        else
            local newTarget = getClosestPlayerToCursor()
            if newTarget and newTarget ~= targetPlayer then
                targetPlayer = newTarget
                manuallySwitchedTarget = true
                rememberedTargetUserId = newTarget.UserId
                originalPrimaryUserId = newTarget.UserId
                targetWasDead = false
                targetWasInvisible = false
                clearSecondaryTargets()
                createTargetIndicator()
                print("Switched target to", newTarget.Name)
            else
                stopFollowing()
            end
        end

    elseif input.KeyCode == Enum.KeyCode.M then
        if following then
            local target = getClosestPlayerToCursor()
            if target then
                if target == targetPlayer then
                    print("Cannot add primary target as secondary")
                else
                    toggleSecondaryTarget(target)
                    local names = getSecondaryTargetNames()
                    if #names > 0 then
                        print("Target queue: " .. table.concat(names, " ‚Üí "))
                    else
                        print("No secondary targets")
                    end
                end
            else
                warn("No player found near cursor")
            end
        else
            warn("Not following anyone - press N first")
        end
    end
end)

Players.PlayerAdded:Connect(function(newPlayer)
    if following and rememberedTargetUserId and not manuallySwitchedTarget then
        if newPlayer.UserId == rememberedTargetUserId then
            task.wait(1)
            if following and targetPlayer ~= newPlayer then
                targetPlayer = newPlayer
                targetWasDead = false
                targetWasInvisible = false
                stoppedFlightForDeath = false
                createTargetIndicator()
                print("Target rejoined - re-acquiring:", newPlayer.Name)
            end
        end
    end

    if following then
        local isSecondary, _ = isSecondaryTargetById(newPlayer.UserId)
        if isSecondary then
            print("Secondary target rejoined: " .. newPlayer.Name)
        end
    end
end)

player.CharacterAdded:Connect(function()
    altIsDead = false
    task.wait(1)
    if targetPlayer and following then
        flightDisabledForStamina = false
        spectating = false
        isAttacking = false
        movementPulseTimer = CONFIG.MOVEMENT_PULSE_RATE
        ensureFlight()
        createTargetIndicator()
        createDebugGui()
    end
end)

player.CharacterRemoving:Connect(function()
    altIsDead = true
    stopSpectating()
    releaseKey(Enum.KeyCode.Q)
    isAttacking = false
end)

Players.PlayerRemoving:Connect(function(leavingPlayer)
    if leavingPlayer == targetPlayer then
        if not manuallySwitchedTarget then
            rememberedTargetUserId = leavingPlayer.UserId
        end

        targetPlayer = nil
        targetWasDead = true
        stoppedFlightForDeath = false

        if spectating then stopSpectating() end
        isAttacking = false

        print("Target left game - waiting for rejoin:", leavingPlayer.Name)
    end
end)

-- =====================================================
-- STARTUP
-- =====================================================

print("=" .. string.rep("=", 50))
print("ALT FOLLOW SCRIPT V5.4.45 - SMART SECONDARY + RIVER")
print("=" .. string.rep("=", 50))
print("Controls:")
print("  N - Toggle/Switch primary target")
print("  M - Add/Remove secondary target (up to 2)")
print("")
print("SECONDARY TARGETING:")
print("‚Ä¢ Range: " .. CONFIG.SECONDARY_TARGET_RANGE .. " studs | Attacks lowest HP")
print("‚Ä¢ Main dies ‚Üí Taunt ‚Üí Walk ‚Üí Attack secondary")
print("‚Ä¢ Main respawns ‚Üí Switch back (" .. CONFIG.MAIN_RESPAWN_GRACE .. "s grace)")
print("")
print("RIVER METHOD (Dolphin Dive):")
print("‚Ä¢ Target in water " .. CONFIG.RIVER_COMMIT_TIME .. "s ‚Üí Commit to river")
print("‚Ä¢ Alt must be UNDERWATER to attack")
print("‚Ä¢ Target can be up to " .. CONFIG.RIVER_EXIT_HEIGHT .. " studs above surface")
print("‚Ä¢ Pop up for air at " .. CONFIG.AIR_RESURFACE_THRESHOLD .. "s left ‚Üí Dive back")
print("")
print("UNAVAILABLE (same for all):")
print("‚Ä¢ Invisible, under map, flyro shield, boulder trap")
print("‚Ä¢ Fly to " .. CONFIG.UNAVAILABLE_RETREAT_DIST .. " studs ‚Üí Land ‚Üí Walk unpredictably")
print("‚Ä¢ Stay " .. (CONFIG.UNAVAILABLE_RETREAT_DIST - CONFIG.UNAVAILABLE_STAY_RANGE) .. "-" .. (CONFIG.UNAVAILABLE_RETREAT_DIST + CONFIG.UNAVAILABLE_STAY_RANGE) .. " studs until available")
print("")
print("Comfort: " .. CONFIG.OPTIMAL_MIN .. "-" .. CONFIG.OPTIMAL_MAX .. " studs")
print("=" .. string.rep("=", 50))
